<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo_init</title>
    <url>/%E7%BD%91%E7%AB%99%E9%85%8D%E7%BD%AE/hexo-init/</url>
    <content><![CDATA[<h1 id="踩坑日记："><a href="#踩坑日记：" class="headerlink" title="踩坑日记："></a>踩坑日记：</h1><p>​    该踩的坑是一个都没少踩，记录一下自己踩的一些坑吧，好多都忘了。</p>
<p>​    <span id="more"></span></p>
<h2 id="Git不区分大小写"><a href="#Git不区分大小写" class="headerlink" title="Git不区分大小写"></a>Git不区分大小写</h2><p>​    查看别人如何实现仅显示部分内容时，都推荐使用“&lt;！– more –&gt;”来分割文章，尝试后本地可正常工作，而部署到github后点击 阅读全文 按钮后，显示文章404。最后发现url后显示为 …/others/Introduce.html 而实际上应该是 …/Others/Introduce.html，所以找不到对应文件。出现这个问题是因为windows版的git在上传文件夹时不区分大小写，导致出错，害的我以为是hexo的锅。修改为中文后就可以正显示。</p>
<img src="/images/hexo-init/hexo-init_01.png" >

<h2 id="侧边栏头像下不显示description"><a href="#侧边栏头像下不显示description" class="headerlink" title="侧边栏头像下不显示description"></a>侧边栏头像下不显示description</h2><p>​    不管如何设置全局配置文件的description都不能显示出来，后来知道next主题配置文件中有个seo的选项配置，用来优化搜索引擎，我也用不到，就全都false。</p>
<img src="/images/hexo-init/hexo-init_02.png" >

<p>​    然后依旧无法显示，查看网页源码，  …/themes/layout/_macro/sidebar.swig文件。</p>
<img src="/images/hexo-init/hexo-init_03.png" >

<p>​    可以看出，当seo = ture时显示signature，seo = false时显示description，索性我就直接在 next的主题配置文件中新加了两行：    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#test</span><br><span class="line"></span><br><span class="line">description: 今天不学习，明天变垃圾。</span><br><span class="line"></span><br><span class="line">signature: 今天不学习，明天变垃圾。</span><br></pre></td></tr></table></figure>



<p>​    就能正常显示了。</p>
<h2 id="侧边栏点击后显示报错"><a href="#侧边栏点击后显示报错" class="headerlink" title="侧边栏点击后显示报错"></a>侧边栏点击后显示报错</h2><p>​    next 主题官方的锅，menu下的每一项后的 ‘/‘与 ‘||’不能有空格。</p>
<img src="/images/hexo-init/hexo-init_04.png" > 

<h2 id="博客添加图片"><a href="#博客添加图片" class="headerlink" title="博客添加图片"></a>博客添加图片</h2><p>​    添加图片的坑更多了！！！</p>
<p>​    目前已知的方法有：</p>
<p>​        1.使用插件。（试过，但有问题，而且每个博客都会建一个文件夹来存放图片，很烦。）</p>
<p>​        2.使用图床。（需要注册图床，然后导出图片链接，快捷方法是 Typora 与 ipic 结合使用，不过ipic仅支持mac。不过也有大佬自己写了几个插件来使用。）</p>
<p>​        3.参考hexo官网，有以下描述。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 ![](/images/image.jpg) 的方法访问它们。</span><br></pre></td></tr></table></figure>

<p>​        缺点就是本地写博客时无法浏览，其他的都很方便，我就选择的是这种方式,，在source文件中自己创建了images文件夹，在Github上浏览时发现会和已有的images文件夹相加。同时注意这里使用的是绝对路径  /images/。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    还有好多坑都不记得了，不过最后还是依靠 百度+ 谷歌，全都解决了。</p>
]]></content>
      <categories>
        <category>网站配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Introduce</title>
    <url>/%E5%85%B6%E4%BB%96/introduce/</url>
    <content><![CDATA[<p>无意间看到可以用GitHub来发博客，便心血来潮自己也搞了一个。</p>
<span id="more"></span>正好刚考上研究生，希望能够用来记录自己的一些学习路线或者学习心得之类的，也希望自己不要太懒惰(笑)。



]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>闲聊</tag>
      </tags>
  </entry>
  <entry>
    <title>learing_route</title>
    <url>/%E5%85%B6%E4%BB%96/learing-route/</url>
    <content><![CDATA[<h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><p>​    本科专业是电子工程与技术，研究生报考的也是本院的实验室，未曾想研究方向居然是CV。塞翁失马，焉知非福。不管怎么说。也算是接触一个全新的领域，还有很多东西需要去学，所以也做一个小小的规划。<span id="more"></span></p>
<h2 id="编程语言学习"><a href="#编程语言学习" class="headerlink" title="编程语言学习"></a>编程语言学习</h2><h3 id="C-：从入门到入土"><a href="#C-：从入门到入土" class="headerlink" title="C++：从入门到入土"></a>C++：从入门到入土</h3><p>​        大学时期没有了解过C++，但是OpenCV等好多底层文件都是用C++写的，那咋办嘛，学呗。</p>
<h3 id="OpenCV-C-Python"><a href="#OpenCV-C-Python" class="headerlink" title="OpenCV: C++/Python"></a>OpenCV: C++/Python</h3><p>​        总感觉和OpenCV有种莫名的缘分(笑)，OpenCV分为C++和Python两种版本，各有优劣，应该会用到很多吧。</p>
<h3 id="Python：-人人都会的编程语言"><a href="#Python：-人人都会的编程语言" class="headerlink" title="Python： 人人都会的编程语言"></a>Python： 人人都会的编程语言</h3><p>​        python只能说 会用但没完全会。</p>
<h2 id="机器学习-深度学习"><a href="#机器学习-深度学习" class="headerlink" title="机器学习/深度学习"></a>机器学习/深度学习</h2><p>​        没了解之前确实觉得机器学习和深度学习都蛮神秘的，了解之后，嗯，都是我学不会的东西呢。</p>
<h3 id="pytorch框架"><a href="#pytorch框架" class="headerlink" title="pytorch框架"></a>pytorch框架</h3><p>​        应该需要去了解一下这个框架，跟tensorflow相比好像更容易一点。</p>
<h3 id="花书-西瓜书-鱼书"><a href="#花书-西瓜书-鱼书" class="headerlink" title="花书/西瓜书/鱼书"></a>花书/西瓜书/鱼书</h3><p>​        收藏从未停止，学习从未开始。</p>
<h2 id="计算机基础四大件："><a href="#计算机基础四大件：" class="headerlink" title="计算机基础四大件："></a>计算机基础四大件：</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>​            为什么要为难我一个电子院出身的人呢。问就是北邮特色，不会真有不会编程的北邮人吧。</p>
<h2 id="LeetCode刷题"><a href="#LeetCode刷题" class="headerlink" title="LeetCode刷题"></a>LeetCode刷题</h2><p>​            刚清空之前的刷题记录，虽然也没几道就是了(/(ㄒoㄒ)/~~)。问就是要加油啊。</p>
<h2 id="Liunx-shell编程"><a href="#Liunx-shell编程" class="headerlink" title="Liunx/shell编程"></a>Liunx/shell编程</h2><p>​            多练练手，别忘光了就好。</p>
<p>​    </p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>闲聊</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读过的书</title>
    <url>/%E5%AD%A6%E4%B9%A0/readedBooks/</url>
    <content><![CDATA[<p>  今天正好是情人节，就打算从今天开始记录自己看过的一些书，也不仅仅是学习方面的书，也包括网络小说，轻小说等等，五花八本的书都算,但起码看了得有意义，看完了没什么意思的书就没什么好记录的了。别人过节我看书，我也没有特别羡慕人家了！<span id="more"></span></p>
<h3 id="lt-lt-C-primer-gt-gt-2021-08-14"><a href="#lt-lt-C-primer-gt-gt-2021-08-14" class="headerlink" title="&lt;&lt;C++ primer&gt;&gt;  2021/08/14"></a>&lt;&lt;C++ primer&gt;&gt;  2021/08/14</h3><p>这本书看了得有两个月，C++入门经典书籍，虽然看完了我也还没入门就是了。不过这本书也不是一遍就能掌握的，以后还需要经常翻阅就是了。C++11的很多新特性也没涉及到，哭了。</p>
<h3 id="lt-lt-日常系的异能战斗-gt-gt-2021-08-18"><a href="#lt-lt-日常系的异能战斗-gt-gt-2021-08-18" class="headerlink" title="&lt;&lt;日常系的异能战斗&gt;&gt;  2021/08/18"></a>&lt;&lt;日常系的异能战斗&gt;&gt;  2021/08/18</h3><p>动画是好几年前开始看的。小说看了几卷，没想到还有机会看完全本。结局或许直接给个后宫结局更好一点。动漫挺好看，虽然只有一季，但给我留了很深的印象。</p>
<img src = "/images/readedBBooks/01.png">

<h3 id="lt-lt-我的系统总想逼我表白-gt-gt-2021-08-21"><a href="#lt-lt-我的系统总想逼我表白-gt-gt-2021-08-21" class="headerlink" title="&lt;&lt;我的系统总想逼我表白&gt;&gt;  2021/08/21"></a>&lt;&lt;我的系统总想逼我表白&gt;&gt;  2021/08/21</h3><p>硬了硬了，拳头硬了。</p>
<p>不知道别人怎么看，不过很符合我的口味。国轻里面很不错的一本。对话幽默风趣，故事情节也很流畅，女主角的性格都很不错。就是结尾太仓促，不过番外很甜。</p>
<h3 id="lt-lt-祈念守护人-gt-gt-2021-08-24"><a href="#lt-lt-祈念守护人-gt-gt-2021-08-24" class="headerlink" title="&lt;&lt;祈念守护人&gt;&gt;  2021/08/24"></a>&lt;&lt;祈念守护人&gt;&gt;  2021/08/24</h3><p><strong>“我要怎样活下去呢？”</strong></p>
<p>看完感觉心里觉得很温暖。有点像解忧杂货店那样。人活着总要有个意义啊。</p>
<img src = "/images/readedBBooks/02.jpg">

<h3 id="lt-lt-SQL-必知必会-第四版-gt-gt-2021-08-25"><a href="#lt-lt-SQL-必知必会-第四版-gt-gt-2021-08-25" class="headerlink" title="&lt;&lt;SQL 必知必会 第四版&gt;&gt; 2021/08/25"></a>&lt;&lt;SQL 必知必会 第四版&gt;&gt; 2021/08/25</h3><p>已经不知道学了MySQL基础几遍的我。</p>
<p>学了就忘，我是废物。</p>
<p>知道如何创建，修改，添加，删除，联结，约束等操作。</p>
<p>依旧不会编写函数，查询事件，提高效率等。</p>
<p>难受.jpg。</p>
<h3 id="lt-lt-无人生还-gt-gt-2021-08-26"><a href="#lt-lt-无人生还-gt-gt-2021-08-26" class="headerlink" title="&lt;&lt;无人生还&gt;&gt;  2021/08/26"></a>&lt;&lt;无人生还&gt;&gt;  2021/08/26</h3><p>第二遍还是让人深受感触。尤其是最后几人绝望的心境和内心复杂的想法。让人大半夜的都有点害怕。</p>
<p>不做亏心事不怕鬼敲门。不读到最后猜不到凶手到底是谁。阿加莎yyds。</p>
<img src = "/images/readedBBooks/03.png">

<h3 id="lt-lt-信-gt-gt-2021-08-28"><a href="#lt-lt-信-gt-gt-2021-08-28" class="headerlink" title="&lt;&lt;信&gt;&gt; 2021/08/28"></a>&lt;&lt;信&gt;&gt; 2021/08/28</h3><p>比我想的内容更平淡也更真实。犯了杀人罪的哥哥会对弟弟的一生造成多大的影响。毁的并不仅是自己的一生，还有亲人的生活。</p>
<p>“我人虽在这样的地方，可一点也没有得到改造。”</p>
<h3 id="lt-lt-魔女的胎动-gt-gt-2021-08-30"><a href="#lt-lt-魔女的胎动-gt-gt-2021-08-30" class="headerlink" title="&lt;&lt;魔女的胎动&gt;&gt; 2021/08/30"></a>&lt;&lt;魔女的胎动&gt;&gt; 2021/08/30</h3><p>最后一章和前面的章节并不连贯，好像是系列书籍的一本。女主圆华对事件的处理方式还是很有效的。希望有机会可以读完这个系列的其他几本书。</p>
<h3 id="lt-lt-sql-基础教程-gt-gt-2021-09-05"><a href="#lt-lt-sql-基础教程-gt-gt-2021-09-05" class="headerlink" title="&lt;&lt;sql 基础教程&gt;&gt; 2021/09/05"></a>&lt;&lt;sql 基础教程&gt;&gt; 2021/09/05</h3><p>又读完了一本sql的基础教程书，相比于《SQL 必知必会》 感觉整个逻辑上更为清楚，两本书也算是对基础的一个相互补充吧。很不错的一本书，讲解和例题都很清楚，书的版式也很整洁。</p>
<h3 id="lt-lt-深度学习入门-基于python的理论与实现-gt-gt-2021-09-22"><a href="#lt-lt-深度学习入门-基于python的理论与实现-gt-gt-2021-09-22" class="headerlink" title="&lt;&lt;深度学习入门 基于python的理论与实现&gt;&gt; 2021/09/22"></a>&lt;&lt;深度学习入门 基于python的理论与实现&gt;&gt; 2021/09/22</h3><p>著名的“鱼书”。讲解的内容比较浅显易懂，从中学到了很多。是一本很不错的入门书。</p>
<h3 id="lt-lt-为美好世界献上祝福-gt-gt-2021-09-23"><a href="#lt-lt-为美好世界献上祝福-gt-gt-2021-09-23" class="headerlink" title="&lt;&lt;为美好世界献上祝福 &gt;&gt; 2021/09/23"></a>&lt;&lt;为美好世界献上祝福 &gt;&gt; 2021/09/23</h3><img src = "/images/readedBBooks/04.png">

<p>问：为什么这么长时间没更新。</p>
<p>答：因为这个系列实在太长了。17卷+各种番外。</p>
<p>结尾略有仓促，但整体来说很不错。鬼畜和真+智慧女神+惠惠+抖M骑士。</p>
<h3 id="lt-lt-Yolo-v1-gt-gt-2021-09-28"><a href="#lt-lt-Yolo-v1-gt-gt-2021-09-28" class="headerlink" title="&lt;&lt; Yolo v1 &gt;&gt; 2021/09/28"></a>&lt;&lt; Yolo v1 &gt;&gt; 2021/09/28</h3><p>“You Only Look Once: Unified, Real-Time Object Detection”</p>
<p>可能算是读论文的开始？之前还读了一篇 《Review Deep Learing&gt;&gt;。只能说考研英语复习的长难句不是完全没有用。</p>
<p>介绍一种不同于RCNN的one-stage的方法。（对不起，RCNN论文我还没看， 哭。）实现目标检测和分类。</p>
<img src = "/images/readedBBooks/05.png">

<h3 id="lt-lt-AlexNet-gt-gt-2021-10-02"><a href="#lt-lt-AlexNet-gt-gt-2021-10-02" class="headerlink" title="&lt;&lt; AlexNet &gt;&gt; 2021/10/02"></a>&lt;&lt; AlexNet &gt;&gt; 2021/10/02</h3><p>“ImageNet Classification with Deep Convolutional Neural Networks”</p>
<p>从AlexNet开始，深度学习在CV领域进入了新时代。</p>
<p>不过深度学习发展也太快了吧，我到底能做些什么呢。</p>
<p>大家都很厉害，只有我是fw。</p>
<h3 id="lt-lt-VGGNet-gt-gt-2021-10-08"><a href="#lt-lt-VGGNet-gt-gt-2021-10-08" class="headerlink" title="&lt;&lt; VGGNet &gt;&gt; 2021/10/08"></a>&lt;&lt; VGGNet &gt;&gt; 2021/10/08</h3><p>“VERY DEEP CONVOLUTIONAL NETWORKS FOR LARGE-SCALE IMAGE RECOGNITION”</p>
<p>慢慢的也要去读这些经典的论文。有种在看卷积网络发展的感觉。</p>
<p>是不是应该试着去复现VGGNet啊。</p>
<h3 id="lt-lt-DoogLeNet-gt-gt-2021-10-13"><a href="#lt-lt-DoogLeNet-gt-gt-2021-10-13" class="headerlink" title="&lt;&lt; DoogLeNet &gt;&gt; 2021/10/13"></a>&lt;&lt; DoogLeNet &gt;&gt; 2021/10/13</h3><p>“Going Deeper with Convolutions”</p>
<p>我真的很想看懂（bushi）。可能还没有很好的领悟他们的想法。</p>
<p>还是得花功夫去仔细研究。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>闲聊</tag>
      </tags>
  </entry>
  <entry>
    <title>关于未来</title>
    <url>/%E5%85%B6%E4%BB%96/%E9%97%B2%E8%81%8A/</url>
    <content><![CDATA[<p> 人总会有迷茫期。<span id="more"></span></p>
<p>研究方向是计算机视觉。但是自己想要学的是C++后台开发，或者嵌入式。要学的东西有很多，总感觉自己在原地踏步。什么都想学，什么都学不会。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>闲聊</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习过程中遇到的问题-01</title>
    <url>/%E5%AD%A6%E4%B9%A0/Cpp/cppProblem01/</url>
    <content><![CDATA[<h1 id="记录C-过程中遇到的一些问题"><a href="#记录C-过程中遇到的一些问题" class="headerlink" title="记录C++过程中遇到的一些问题"></a>记录C++过程中遇到的一些问题</h1><p> C++好复杂啊。(<em>¯ㅿ¯</em>;)</p>
<span id="more"></span>

<h2 id="输入cin-指令无效"><a href="#输入cin-指令无效" class="headerlink" title="输入cin 指令无效"></a>输入cin 指令无效</h2><p>​    在一个简单的交互程序中，使用 cin 来读取输入时，第一次读取输入的字符串正常读取，第二次读取输入的数字时命令被忽略，直接跳过执行。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; number; <span class="comment">//通常情况会进行输入读取一个数值，前提是cin正常。如果cin被核定为false，则cin就不会被执行啦。</span></span><br></pre></td></tr></table></figure>

<p>   上述例子中，由于输入字符串时，输入了结束符进行退出，所以 cin 已经被核定为false了，所以下边的 cin&gt;&gt;number 无法正常执行输入操作。</p>
<p>cin 被核定为 false 的情况：</p>
<p>​    （1）遇到结束符。</p>
<p>​    （2）遇到非法输入。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>​    使用cin.clear() 和 cin.sync() 使 cin 恢复正常状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两者需要同时使用。</span></span><br><span class="line">    cin.<span class="built_in">sync</span>();</span><br><span class="line">    cin.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>

<p>   更多的具体细节可以搜索函数的定义和功能。</p>
<h2 id="Null-与-nullptr"><a href="#Null-与-nullptr" class="headerlink" title="Null 与 nullptr"></a>Null 与 nullptr</h2><p>Null在C++中定义为0，在很多场合（尤其涉及到指针时）。因此更加提倡使用 nullptr 来代替Null。</p>
<h2 id="using用法"><a href="#using用法" class="headerlink" title="using用法"></a>using用法</h2><p>C/C++中可以使用  typedef 来定义别名。被重定义的类型并不是一个新的类型，仅仅只是原有的类型取了一个新的名字。</p>
<p>使用 typedef 重定义类型是很方便的，但它也有一些限制，比如，无法重定义一个模板。</p>
<p>而using 的别名语法覆盖了 typedef 的全部功能。using 别名语法比 typedef 更加清晰。因为 typedef 的别名语法本质上类似一种解方程的思路。而 using 语法通过赋值来定义别名，和我们平时的思考方式一致。</p>
<p>因此很多情况二者可以互换  但更多情况下最好使用using。</p>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>析构函数（destructor）是成员函数的一种，它的名字与类名相同，但前面要加<code>~</code>，没有参数和返回值。一个类有且仅有一个析构函数。如果定义类时没写析构函数，则编译器生成默认析构函数。析构函数在对象消亡时即自动被调用。可以定义析构函数在对象消亡前做善后工作。例如，对象如果在生存期间用 new 运算符动态分配了内存，则在各处写 delete 语句以确保程序的每条执行路径都能释放这片内存是比较麻烦的事情。有了析构函数，只要在析构函数中调用 delete 语句，就能确保对象运行中用 new 运算符分配的空间在对象消亡时被释放。</p>
<h2 id="const的不同用法"><a href="#const的不同用法" class="headerlink" title="const的不同用法"></a>const的不同用法</h2><p>关键问题点：const 属于修饰符 ，关键是看const 修饰的位置在那里</p>
<p>​    在 C++ 中const是用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。</p>
<p>​    C++ const 允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。如果在编程中确实有某个值保持不变，就应该明确使用const，这样可以获得编译器的帮助。</p>
<h3 id="修饰普通类型变量"><a href="#修饰普通类型变量" class="headerlink" title="修饰普通类型变量"></a>修饰普通类型变量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int num = 7;</span><br><span class="line">num = 8;//错误，num不可修改。</span><br></pre></td></tr></table></figure>

<h3 id="修饰指针变量"><a href="#修饰指针变量" class="headerlink" title="修饰指针变量"></a>修饰指针变量</h3><p>const 修饰指针变量有以下三种情况。</p>
<ul>
<li>A: const 修饰指针指向的内容，则内容为不可变量。</li>
<li>B: const 修饰指针，则指针为不可变量。</li>
<li>C: const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//A情形：</span><br><span class="line">const int *p = 8;</span><br><span class="line">//左定值，指针指向的内容不可改变。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//B情形:</span><br><span class="line">int a = 8;</span><br><span class="line">int* const p = &amp;a;</span><br><span class="line">*p =9; //正确</span><br><span class="line">int b = 7;</span><br><span class="line">p = &amp;b; //错误</span><br><span class="line">//对于 const 指针 p 其指向的内存地址不能够被改变，但其内容可以改变。简称，右定向。因为 const 位于 * 号的右边。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//C情形</span><br><span class="line">int a = 8;</span><br><span class="line">const int * const  p = &amp;a;</span><br><span class="line">//const p 的指向的内容和指向的内存地址都已固定，不可改变。</span><br></pre></td></tr></table></figure>

<p>根据 const 位于 * 号的位置不同，可总结三句话便于记忆的话：**”左定值，右定向，const修饰不变量”**。</p>
<p>int const *a 和 const int *a 的意义是相同的 他们两个的作用等价</p>
<h3 id="const参数传递和函数返回值"><a href="#const参数传递和函数返回值" class="headerlink" title="const参数传递和函数返回值"></a>const参数传递和函数返回值</h3><p>对于 const 修饰函数参数可以分为三种情况。</p>
<p>A：值传递的 const 修饰传递，一般这种情况不需要 const 修饰，因为函数会自动产生临时变量复制实参值。</p>
<p>B：当 const 参数为指针时，可以防止指针被意外篡改。</p>
<p>C：自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取 const 外加引用传递的方法。并且对于一般的 int、double 等内置类型，我们不采用引用的传递方式。</p>
<p>Const 修饰返回值分三种情况。</p>
<p>A：const 修饰内置类型的返回值，修饰与不修饰返回值作用一样。</p>
<p>B: const 修饰自定义类型的作为返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。</p>
<p>C: const 修饰返回的指针或者引用，是否返回一个指向 const 的指针，取决于我们想让用户干什么。</p>
<h3 id="const修饰类成员函数"><a href="#const修饰类成员函数" class="headerlink" title="const修饰类成员函数"></a>const修饰类成员函数</h3><p>const 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。</p>
<p><strong>注意：</strong>const 关键字不能与 static 关键字同时使用，因为 static 关键字修饰静态成员函数，静态成员函数不含有 this 指针，即不能实例化，const 成员函数必须具体到某一实例。</p>
<p>如果有个成员函数想修改对象中的某一个成员可以使用 mutable 关键字修饰这个成员，被 mutable 关键字修饰的成员可以处于不断变化中.</p>
<h2 id="int-array"><a href="#int-array" class="headerlink" title="int array[[]][][]"></a>int array[[]][][]</h2><p>如果想要将一个二维数组当作函数形参或应用， 则必须实现定义第二维的大小，相比之下，更应该使用vector&lt;vector<int> &gt;.</p>
<p>此外C++11有了一个新的array容器。</p>
<h2 id="函数返回值为引用类型"><a href="#函数返回值为引用类型" class="headerlink" title="函数返回值为引用类型"></a>函数返回值为引用类型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">Vector&lt;T&gt;&amp; Vector&lt;T&gt;::operator=(Vector&lt;T&gt; const&amp; V)&#123;  //重载 =</span><br><span class="line">    //释放原有内容</span><br><span class="line">    if(_elem)</span><br><span class="line">        delete[] _elem;</span><br><span class="line">    //整体复制</span><br><span class="line">    copyFrom(V._elem, 0, V.size());</span><br><span class="line">    //返回当前对象的引用，以便链式复制</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回类型为引用类型，需要注意返回值是全局变量、局部变量、类对象等。防止发生错误。</p>
<p>对应很多不同的情况，值得仔细研究一下。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习过程中遇到的问题-01</title>
    <url>/%E5%AD%A6%E4%B9%A0/Cpp/cppProblem02/</url>
    <content><![CDATA[<h1 id="记录C-过程中遇到的一些问题"><a href="#记录C-过程中遇到的一些问题" class="headerlink" title="记录C++过程中遇到的一些问题"></a>记录C++过程中遇到的一些问题</h1><p> C++好复杂啊  + 1。(<em>¯ㅿ¯</em>;)</p>
<span id="more"></span>

<h2 id="make-pair报错"><a href="#make-pair报错" class="headerlink" title="make_pair报错"></a>make_pair报错</h2><p>使用语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nodeDepth.emplace_back(make_pair&lt;int, TreeNode*&gt;(depth, stk.top()));</span><br></pre></td></tr></table></figure>

<p>会直接报错，<strong>Cannot convert parameter from ‘int’ to ‘int &amp;&amp;’</strong></p>
<p>原因：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt; class T1, class T2 &gt;</span><br><span class="line">std::pair&lt;T1,T2&gt; make_pair( T1 t, T2 u );           (until C++11)</span><br><span class="line"></span><br><span class="line">template&lt; class T1, class T2 &gt;</span><br><span class="line">std::pair&lt;V1,V2&gt; make_pair( T1&amp;&amp; t, T2&amp;&amp; u );       (since C++11)</span><br></pre></td></tr></table></figure>

<p>make_pair修改了定义，如果直接使用变量名的话，编译器会认为这是一个左值，而不能使用。</p>
<p>解决方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.直接使用pair</span><br><span class="line">nodeDepth.emplace_back(pair&lt;int, TreeNode*&gt;(depth, stk.top()));</span><br><span class="line">2.用int(depth)将左值转为右值</span><br><span class="line">nodeDepth.emplace_back(make_pair&lt;int, TreeNode*&gt;(int(depth), stk.top()));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>DSA 基础知识</title>
    <url>/%E5%AD%A6%E4%B9%A0/DSA/DSA_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><p>数据结构和算法的重要性毋庸置疑啊，一方面刷题，一方面学习一下。<span id="more"></span></p>
<h2 id="数据结构的基础知识"><a href="#数据结构的基础知识" class="headerlink" title="数据结构的基础知识"></a>数据结构的基础知识</h2><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>​    O(1):常数时间复杂度算法</p>
<p>​    O(logn):对数时间复杂度——高效算法</p>
<p>​    O(n):多项式时间复杂度算法.某问题若存在一个复杂度在此范围以内的算法，则称该问题是可有效求解的或易解的（tractable）</p>
<p>​    O(x**n):指数复杂度，无法接受的算法。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>​        递归则是函数和过程调用的一种特殊形式，即允许函数和过程进行<br>自我调用。</p>
<p>​        递归的价值在于，许多应用问题都可简洁而准确地描述为递归形式。</p>
<p>​    递归也是一种基本而典型的算法设计模式。这一模式可以对实际问题中反复出现的结构和形式做高度概括，并从本质层面加以描述与刻画，进而导出高效的算法。</p>
<h4 id="递归的基本模式"><a href="#递归的基本模式" class="headerlink" title="递归的基本模式"></a>递归的基本模式</h4><h5 id="线性递归"><a href="#线性递归" class="headerlink" title="线性递归"></a>线性递归</h5><p>举例：数组元素求和</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组求和：数组的前A[0,n-1)个数的和与末元素A[n-1]之和。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arraySum</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span>&gt;n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (<span class="built_in">arraySum</span>(A, n<span class="number">-1</span>) + A[n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度：O(1)*递归深度 = O(1) * (n+1) = O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)</span></span><br></pre></td></tr></table></figure>

<p>​        算法可能朝着更深一层进行自我调用，且每一递归实例对自身的调用至多一次。于是，每一层次上至多只有一个实例，且它们构成一个线性的次序关系。此类递归模式因而称作“线性递归”（linear recursion），它也是递归的最基本形式。</p>
<p>​    线性递归往往对应于<em><strong>减而治之</strong></em>的算法策略：递归每深入一层，待求解问题的规模都缩减一个常数，直至最终蜕化为平凡的小（简单）问题。</p>
<h5 id="递归分析"><a href="#递归分析" class="headerlink" title="递归分析"></a>递归分析</h5><p>1.递归跟踪：作为一种直观且可视的方法，递归跟踪（recursion trace）可用以分析递归算法的总体运行时间与空间。</p>
<p>2.递推方程：通过对递归模式的数学归纳，导出复杂度定界函数的递推方程（组）及其边界条件，从而将复杂度的分析，转化为递归方程（组）的求解。</p>
<h5 id="递归模式"><a href="#递归模式" class="headerlink" title="递归模式"></a>递归模式</h5><p>1.多递归基：为保证有穷性，递归算法都必须设置递归基，且确保总能执行到。</p>
<p>举例：数组倒置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(lo &lt; hi)&#123;</span><br><span class="line">		<span class="built_in">swap</span>(A[lo], A[hi]);</span><br><span class="line">		<span class="built_in">reverse</span>(A, lo+<span class="number">1</span>, hi<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//O(hi + lo -1)</span></span><br></pre></td></tr></table></figure>

<p>2.多向递归：递归算法中，不仅递归基可能有多个，递归调用也可能有多种可供选择的分支。</p>
<p>举例：求2**n</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inline __int64 sqr ( __int64 a ) &#123; return a * a; &#125;</span><br><span class="line">__int64 power2 ( int n ) &#123; //幂函数2^n算法（优化逑弻版），n &gt;= 0</span><br><span class="line"> 	if ( 0 == n ) return 1; //逑弻基；否则，规n癿奇偶分删逑弻</span><br><span class="line">    return ( n &amp; 1 ) ? sqr ( power2 ( n &gt;&gt; 1 ) ) &lt;&lt; 1 : sqr ( power2 ( n &gt;&gt; 1 ) );</span><br><span class="line">&#125; //O(logn) = O(r)，r为输入指数n癿比特位数</span><br></pre></td></tr></table></figure>

<h5 id="递归消除"><a href="#递归消除" class="headerlink" title="递归消除"></a>递归消除</h5><p>空间成本:递归算法所消耗的空间量主要取决于递归深度，故较之同一算法的迭代版，递归版往往需耗费更多空间，并进而影响实际的运行速度。</p>
<p>举例：尾递归消除</p>
<p>在线性递归算法中，若递归调用在递归实例中恰好以最后一步操作的形式出现，则称作尾递<br>归（tail recursion）。属于尾递归形式的算法，均可以简捷地转换为等效的迭代版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#数组倒置</span><br><span class="line">void reverse(int* A, int lo, int hi)&#123;</span><br><span class="line">next:</span><br><span class="line">	if(lo &lt; hi)&#123;</span><br><span class="line">		swap(A[lo], A[hi]);</span><br><span class="line">		lo++;</span><br><span class="line">		hi--;</span><br><span class="line">		goto next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;//O(hi - lo + 1)</span><br><span class="line"></span><br><span class="line">#用while 代替 next if</span><br><span class="line">void reverse(int* A, int lo, int hi)&#123;</span><br><span class="line">	while( lo &lt; hi )&#123;</span><br><span class="line">		swap(A[lo++], A[hi--]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二分递归"><a href="#二分递归" class="headerlink" title="二分递归"></a>二分递归</h5><p>分而治之：将大问题分解为若干规模更小的子问题，再通过递归机制分别求解。这种分解持续进行，直到子问题规模缩减至平凡情况。这也就是所谓的分而治之（divide-and-conquer）策略。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arraySum(int A[], int lo, int hi)&#123;</span><br><span class="line">	if( lo == hi)&#123;</span><br><span class="line">		return A[lo];</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		int mi = (lo + hi) &gt;&gt; 1;</span><br><span class="line">		return sum(A, lo, mi) + sum(A, mi+1, hi);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;//O(hi - lo +1)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Deep Learning</title>
    <url>/%E5%AD%A6%E4%B9%A0/DeepLearning/DL_01/</url>
    <content><![CDATA[<h1 id="Deep-Learning-入门"><a href="#Deep-Learning-入门" class="headerlink" title="Deep Learning 入门"></a>Deep Learning 入门</h1><p>​    记录Deep Learning 学习过程中遇到的一些问题。<span id="more"></span></p>
<h2 id="saturating-nonlinearity-和-non-saturating-nonlinearity"><a href="#saturating-nonlinearity-和-non-saturating-nonlinearity" class="headerlink" title="saturating nonlinearity 和 non-saturating nonlinearity"></a>saturating nonlinearity 和 non-saturating nonlinearity</h2><p>在AlexNet论文《 ImageNet Classification with Deep Convolutional Neural Networks》第3节中提到了饱和非线性（saturating nonlinearity）和非饱和非线性（non-saturating nonlinearity）的概念。</p>
<h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>一个饱和的激活函数，会将输出结果压缩到有限的区间。</p>
<p>如果函数是非饱和的，那么有：</p>
<p>​    当x趋近无穷大时，f(x)也趋近于无穷大。</p>
<p>反之，则为饱和函数。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><ol>
<li>  ReLU激活函数定义为f ( x ) = m a x ( 0 , x )，  f(x)=max(0,x)f(x)=max(0,x)，由于x-&gt;+∞时，f(x)也趋近于正无穷，因此ReLU不饱和。</li>
<li>  sigmoid激活函数定义f(x) = 1 / (1 + exp(-x)), 由于它将实数压缩到区间[ 0 , 1 ]之间，因此sigmoid是饱和的。</li>
<li>  tanh激活函数定义为tanh(x) = (1 - exp(-zx)) / (1 + exp(-zx)) , 由于它将实数压缩到区间[ − 1 , 1 ] 之间，因此tanh是饱和的.</li>
</ol>
<p>论文中提到说，饱和非线性的激活函数训练时比非饱和非线性的激活函数要慢的多。</p>
<h2 id="Data-Augmentation"><a href="#Data-Augmentation" class="headerlink" title="Data Augmentation"></a>Data Augmentation</h2><p>在深度学习中，为了丰富图像数据的训练集，更好的提取图像特征，泛化模型（防止模型过拟合），一般都会对图像数据进行数据增强（Data Augmentation）。</p>
<h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><p>AlexNet：针对具有3通道的彩色图片的训练任务，进行减去图片均值的预处理操作。</p>
<p>- Color Jittering：对颜色的数据增强：图像亮度、饱和度、对比度变化；<br>- PCA Jittering：首先按照RGB三个颜色通道计算均值和标准差，再在整个训练集上计算协方差矩阵，进行特征分解，得到特征向量和特征值，用来做PCA Jittering；<br>- Random Scale：尺度变换；<br>- Random Crop：采用随机图像差值方式，对图像进行裁剪、缩放；包括Scale Jittering方法（VGG及ResNet模型使用）或者尺度和长宽比增强变换；<br>- Horizontal/Vertical Flip：水平/垂直翻转；<br>- Shift：平移变换；<br>- Rotation/Reflection：旋转/仿射变换；<br>- Noise：高斯噪声、模糊处理；<br>- Label shuffle：类别不平衡数据的增广；</p>
<p>需要注意的是，在对图片做Affine时，可能还需要对对应的标签做相应的处理，比如BBox， keypoints，以及polygons等。</p>
<h2 id="end-to-end"><a href="#end-to-end" class="headerlink" title="end-to-end"></a>end-to-end</h2><p>与机器学习不同，卷积神经网络的输入是由原始像素值或是经过简单预处理（例如居中、缩放）的像素值组成的，不需要进行其余更加精心的设计，来达到更好的预期结果。</p>
<h2 id="ReLU-与-Sigmoid"><a href="#ReLU-与-Sigmoid" class="headerlink" title="ReLU 与 Sigmoid"></a>ReLU 与 Sigmoid</h2><p>在AlexNet中，提出了ReLU这样一个激活函数。</p>
<p>ReLU 对比于 SIgmoid 的优势：</p>
<ol>
<li>  ReLU激活函数的计算更简单，它不需要如sigmoid激活函数那般复杂的求幂运算。</li>
<li>  当使用不同的参数初始化方法时，ReLU激活函数使训练模型更加容易。 当sigmoid激活函数的输出非常接近于0或1时，这些区域的梯度几乎为0，因此反向传播无法继续更新一些模型参数。 相反，ReLU激活函数在正区间的梯度总是1。 因此，如果模型参数没有正确初始化，sigmoid函数可能在正区间内得到几乎为0的梯度，从而使模型无法得到有效的训练。</li>
</ol>
<h2 id="dropout"><a href="#dropout" class="headerlink" title="dropout"></a>dropout</h2><p>以下摘选自&lt;&lt; Alexnet &gt;&gt;.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将许多不同模型的预测结合起来是降低测试误差的一个非常成功的方法，但对于需要花费几天来训练的大型神经网络来说，这似乎太昂贵了。然而，有一个非常有效的模型结合版本，它只花费两倍的训练成本。这种最近引入的技术，叫做“dropout”，它会以0.5的概率对每个隐层神经元的输出设为0。那些“失活的”的神经元不再进行前向传播并且不参与反向传播。因此每次输入时，神经网络会采样一个不同的架构，但所有架构共享权重。这个技术减少了复杂的神经元互适应，因为一个神经元不能依赖特定的其它神经元的存在。因此，神经元被强迫学习更鲁棒的特征，它在与许多不同的其它神经元的随机子集结合时是有用的。在测试时，我们使用所有的神经元但它们的输出乘以0.5，对指数级的许多失活网络的预测分布进行几何平均，这是一种合理的近似。</span><br></pre></td></tr></table></figure>

<p>dropout是一种有效的能够降低overfitting 的方法。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记01</title>
    <url>/%E5%AD%A6%E4%B9%A0/Git/gitNote01/</url>
    <content><![CDATA[<h2 id="系统的学习一下Git和Github的使用"><a href="#系统的学习一下Git和Github的使用" class="headerlink" title="系统的学习一下Git和Github的使用"></a>系统的学习一下Git和Github的使用</h2><p>​    已经了解和使用过Git和Github，但是并没有具体的学习过。通过系统学习能进一步加深影响。<span id="more"></span></p>
<p>​    参考书籍《ProGit》。</p>
<h3 id="获取Git仓库"><a href="#获取Git仓库" class="headerlink" title="获取Git仓库"></a>获取Git仓库</h3><p>​    获取方式通常有两种：</p>
<p>​        1、使用语句 git init ，将本地文件初始化为仓库。</p>
<p>​        2、使用给git clone <url>语句，clone一个已有的仓库下来。</p>
<h3 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h3><p>​    如图所示：</p>
<img src="/images/git/git_01.png" >

<p>​    文件所处的状态一定是图中几种状态之一。</p>
<p>​    查看当前不同文件的状态可以使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>

<h3 id="跟踪新文件-暂存文件"><a href="#跟踪新文件-暂存文件" class="headerlink" title="跟踪新文件/暂存文件"></a>跟踪新文件/暂存文件</h3><p>​    使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p>​    可以用 git add <file>开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适.</p>
<h3 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h3><p>​    使用参数查看状态简洁输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status --short</span><br><span class="line">git status -s</span><br></pre></td></tr></table></figure>

<p>  新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。</p>
<h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>​    通过创建   .gitignore 文件来选择忽略的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#示例</span><br><span class="line">#以下是忽略内容，使用正则表达式来匹配、</span><br><span class="line">*.[co]</span><br><span class="line">*~</span><br><span class="line">/folderName</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>文件 .gitignore 的格式规范如下：<br>• 所有空行或者以 # 开头的行都会被 Git 忽略。<br>• 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。<br>• 匹配模式可以以（/）开头防止递归。<br>• 匹配模式可以以（/）结尾指定目录。<br>• 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。</p>
<h3 id="对比差异"><a href="#对比差异" class="headerlink" title="对比差异"></a>对比差异</h3><p>git status只能反映当前文件的状态，如果想查看文件修改的内容或历史差异需要使用语句git diff.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff  #比较的是工作目录中当前文件和暂存区域快照之间的差异</span><br><span class="line">git diff --staged  </span><br><span class="line">git diff --cached </span><br><span class="line">#上面两条语句作用相同，比对已暂存文件与最后一次提交的文件差异：</span><br></pre></td></tr></table></figure>

<h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><p> 可以直接使用 git commit 来提交更新，接着会启动文本编辑器提示你输入版本更新信息。</p>
<p>也可以直接使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;版本更新信息&quot;</span><br></pre></td></tr></table></figure>

<h3 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -a </span><br><span class="line">#Git 会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤</span><br></pre></td></tr></table></figure>

<h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>情形一：</p>
<p>  直接删除文件，使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm  &lt;filename&gt;</span><br><span class="line">#如果文件修改后未暂存</span><br><span class="line">git rm -f &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p>情形二：</p>
<p>不删除文件而从跟踪状态下移除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remove --cached &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<h3 id="移动文件-重命名"><a href="#移动文件-重命名" class="headerlink" title="移动文件/重命名"></a>移动文件/重命名</h3><p>类似于Linux一样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git mv file_from file_to</span><br></pre></td></tr></table></figure>

<h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p>使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>

<p>也可以为 git log 附带一系列的总结性选项。 比如你想看到每次提交的简略统计信息，可以使用 –stat 选项</p>
<h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit amend</span><br></pre></td></tr></table></figure>

<p>用来修改提交信息或补充几个忘记提交的文件而不至于弄乱提交历史。</p>
<h3 id="取消暂存文件"><a href="#取消暂存文件" class="headerlink" title="取消暂存文件"></a>取消暂存文件</h3><p>与git add filename对应：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset HEAD &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout --&lt;fiename&gt;</span><br></pre></td></tr></table></figure>

<p> 请务必记得 git checkout – <file> 是一个危险的命令。 对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令</p>
<h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote </span><br><span class="line">#列出指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字</span><br></pre></td></tr></table></figure>

<h3 id="添加、移除远程仓库"><a href="#添加、移除远程仓库" class="headerlink" title="添加、移除远程仓库"></a>添加、移除远程仓库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add &lt;shortname&gt; &lt;url&gt; </span><br><span class="line">git remote remove &lt;ahortname&gt;</span><br></pre></td></tr></table></figure>

<p>添加一个新的远程 Git 仓库，同时指定一个方便使用的简写</p>
<h3 id="从远程仓库抓取"><a href="#从远程仓库抓取" class="headerlink" title="从远程仓库抓取"></a>从远程仓库抓取</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch &lt;remote&gt;</span><br></pre></td></tr></table></figure>

<p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p>
<h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。</p>
<h3 id="查看远程仓库的信息"><a href="#查看远程仓库的信息" class="headerlink" title="查看远程仓库的信息"></a>查看远程仓库的信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote show &lt;shortname&gt;</span><br></pre></td></tr></table></figure>

<h3 id="远程仓库重命名"><a href="#远程仓库重命名" class="headerlink" title="远程仓库重命名"></a>远程仓库重命名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote  rename name1 name2</span><br></pre></td></tr></table></figure>

<h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p>​    像其他版本控制系统（VCS）一样，Git 可以给仓库历史中的某一个提交打上标签，以示重要。</p>
<h3 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag </span><br><span class="line">git tag -l &quot;关键词&quot;</span><br></pre></td></tr></table></figure>

<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>git支持两种标签：</p>
<p>​    1.轻量标签</p>
<p>​        某个特定提交的引用。</p>
<p>​    2.附注标签</p>
<p>​     附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。</p>
<p>创建附注标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建附注标签</span><br><span class="line">git tag -a &lt;tagname&gt; -m &quot;注释信息&quot;</span><br><span class="line">#查看所有标签</span><br><span class="line">git tag </span><br><span class="line">#显示注释信息</span><br><span class="line">git show &lt;tagname&gt;</span><br></pre></td></tr></table></figure>

<p>创建轻量标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag &lt;tagname&gt;</span><br></pre></td></tr></table></figure>

<h3 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h3><p>​    默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#推送特定标签</span><br><span class="line">git push origin &lt;tagname&gt;</span><br><span class="line">#推送所有标签 </span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>

<h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -d &lt;tagname&gt;</span><br><span class="line">#注意上述命令并不会从任何远程仓库中移除这个标签，你必须用 </span><br><span class="line">git push &lt;remote&gt; :refs/tags/&lt;tagname&gt; </span><br><span class="line">#来更新你的远程仓库,或者</span><br><span class="line">git push origin --delete &lt;tagname&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Git别名"><a href="#Git别名" class="headerlink" title="Git别名"></a>Git别名</h2><p>Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#git 别名</span><br><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.unstage &#x27;reset HEAD --&#x27;</span><br><span class="line">git config --global alias.last &#x27;log -1 HEAD&#x27;</span><br></pre></td></tr></table></figure>

<p>也可以在用户的配置文件下修改：</p>
<p>Windows下.config文件路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\username\.gitconfig</span><br></pre></td></tr></table></figure>

<p>添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[alias]</span><br><span class="line">	co = checkout</span><br><span class="line">	br = branch</span><br><span class="line">	ci = commit</span><br><span class="line">	st = status</span><br><span class="line">	unstage = reset HEAD --=</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Deep Learning 02</title>
    <url>/%E5%AD%A6%E4%B9%A0/DeepLearning/DL_AlexNet/</url>
    <content><![CDATA[<h1 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h1><p> 深度卷积网络的开创者。将从手工对图片的的特征进行提取，进而利用机器学习的方式实现图像识别转别为由机器自己实现特征提取和图片识别。真正实现了“end-to-end”。<span id="more"></span></p>
<h2 id="取得成功的原因"><a href="#取得成功的原因" class="headerlink" title="取得成功的原因"></a>取得成功的原因</h2><h3 id="更大更丰富的数据集"><a href="#更大更丰富的数据集" class="headerlink" title="更大更丰富的数据集"></a>更大更丰富的数据集</h3><p>包含许多特征的深度模型需要大量的有标签数据，才能显著优于基于凸优化的传统方法。越来越多的大规模的数据集给深度学习提供了数据基础。同时还包括各种各样的图像增强方法，进一步对数据集进行扩充。</p>
<h3 id="GPU-加快神经网络的训练速度"><a href="#GPU-加快神经网络的训练速度" class="headerlink" title="GPU-加快神经网络的训练速度"></a>GPU-加快神经网络的训练速度</h3><p>GPU特殊的硬件结构使得矩阵运算更加迅速。极大的减少了网络训练的时间。GPU强大的运算能力使得CNN的是实现成为了可能。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="使用ReLU作为激活函数"><a href="#使用ReLU作为激活函数" class="headerlink" title="使用ReLU作为激活函数"></a>使用ReLU作为激活函数</h3><p>作者通过实验证明，ReLU相比于Sigmoid等其他激活函数，更容易进行训练，达到同样的识别精度所需要的时间和迭代次数更少。</p>
<p>同时ReLU也成为最为常见的激活函数。</p>
<h3 id="在多块GPU上同时进行计算"><a href="#在多块GPU上同时进行计算" class="headerlink" title="在多块GPU上同时进行计算"></a>在多块GPU上同时进行计算</h3><p>由于当时的GPU性能还不是太强，所以作者采用了两块GPU来实现网络的计算。如今GPU的计算能力已经得到了飞速提升，但更大型的网络依旧需要使用多个GPU并行计算。同时GPU硬件加速也是一个重要的研究方向。</p>
<h3 id="LRN"><a href="#LRN" class="headerlink" title="LＲＮ"></a>LＲＮ</h3><p>作者提出的一种局部归一化的方法，在后来的VGGNet中证明用处不大。</p>
<h3 id="重叠池化"><a href="#重叠池化" class="headerlink" title="重叠池化"></a>重叠池化</h3><p>之前的池化层都是池化层的大小等于步进，这里作者采用了池化层的大小大于步进，因此会产生部分重叠。作者通过实验证明，这样做有利于抑制过拟合。</p>
<h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p>AlexNet网络结构相对简单，使用了8层卷积神经网络，前5层是卷积层，剩下的3层是全连接层。中间还包括池化层和激活层。</p>
<img src = "/images/DeepLearning/01.png">

<p>这里将两部分网络拼在了一起，易于理解。</p>
<p>值得注意的一点：原图输入224 × 224，实际上进行了随机裁剪，实际大小为227 × 227。</p>
<p>AlexNet的第一层，卷积窗口的形状是 11×11。 由于ImageNet中大多数图像的宽和高比MNIST图像的多10倍以上，因此，需要一个更大的卷积窗口来捕获目标。 第二层中的卷积窗口形状被缩减为 5×55×5，然后是 3×33×3。 此外，在第一层、第二层和第五层卷积层之后，加入窗口形状为 3×33×3、步幅为2的最大汇聚层。 而且，AlexNet的卷积通道数目是LeNet的10倍。</p>
<p>在最后一个卷积层后有两个全连接层，分别有4096个输出。 这两个巨大的全连接层拥有将近1GB的模型参数。 </p>
<h3 id="网络大小的计算"><a href="#网络大小的计算" class="headerlink" title="网络大小的计算"></a>网络大小的计算</h3><p>这里参考了《鱼书》。</p>
<img src = "/images/DeepLearning/03.png">

<img src = "/images/DeepLearning/02.png">

<h2 id="抑制过拟合的方法"><a href="#抑制过拟合的方法" class="headerlink" title="抑制过拟合的方法"></a>抑制过拟合的方法</h2><h3 id="图像增广"><a href="#图像增广" class="headerlink" title="图像增广"></a>图像增广</h3><p>作者做了两种处理。</p>
<p>１.　对２５６＊２５６的图像进行裁剪。变为大小为２２４＊２２４，同时进行翻转。</p>
<p>这样一张照片就变为了２０４８张，但是这样的处理，图片的关联性是很大的。</p>
<p>２.　ＰＣＡ处理：对图像进行一系列的计算处理，排除光照等其他因素引起的问题。</p>
<h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><p>下面摘抄于原文，很好的解释了dropout的使用原因和作用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Combining the predictions of many different models is a very successful way to reduce test errors, but it appears to be too expensive for big neural networks that already take several days to train. There is, however, a very efficient version of model combination that only costs about a factor of two during training. The recently-introduced technique, called “dropout”, consists of setting to zero the output of each hidden neuron with probability 0.5. The neurons which are “dropped out” in this way do not contribute to the forward pass and do not participate in backpropagation. So every time an input is presented, the neural network samples a different architecture, but all these architectures share weights. This technique reduces complex co-adaptations of neurons, since a neuron cannot rely on the presence of particular other neurons. It is, therefore, forced to learn more robust features that are useful in conjunction with many different random subsets of the other neurons. At test time, we use all the neurons but multiply their outputs by 0.5, which is a reasonable approximation to taking the geometric mean of the predictive distributions produced by the exponentially-many dropout networks.</span><br></pre></td></tr></table></figure>

<p>简单理解就是，Dropout将集成学习的效果（模拟地）通过一个网络实现了，所有的这些网络全都共用权重。</p>
<h2 id="更多的细节"><a href="#更多的细节" class="headerlink" title="更多的细节"></a>更多的细节</h2><h3 id="SGD-Momentum-权重衰减"><a href="#SGD-Momentum-权重衰减" class="headerlink" title="SGD+Momentum+权重衰减"></a>SGD+Momentum+权重衰减</h3><p>作者在更新参数时使用了较为复杂的更新方式，而并不是简单拿到SGD。</p>
<h3 id="参数初始值"><a href="#参数初始值" class="headerlink" title="参数初始值"></a>参数初始值</h3><p>权重使用了高斯分布来初始化。</p>
<p>偏置部分层使用了 0 ，其余层使用了1。</p>
<p>lr也就是学习率，最初设置为0.01，每次学习停止时，就将lr除于10，进一步更新参数。</p>
<h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><img src = "/images/DeepLearning/04.jpg">

<h3 id="进一步分析"><a href="#进一步分析" class="headerlink" title="进一步分析"></a>进一步分析</h3><img src = "/images/DeepLearning/05.png">

<p>作者了考虑由最后4096维隐藏层的图像引起的特征激活，认为如果两幅图像产生的特征激活向量具有较小的欧氏分离，我们可以说神经网络的高层认为它们是相似的。这里的特征激活向量应该是所有前面层计算出来的结果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作者认为：更深的网络层数 + 更丰富的数据集 + 更强大的运算/更多的训练时间 = 更好的识别效果。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记02</title>
    <url>/%E5%AD%A6%E4%B9%A0/Git/gitNote02/</url>
    <content><![CDATA[<p>  Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。</p>
<span id="more"></span>

<h2 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h2><p>​        Git 保存的不是文件的变化或者差异，而是一系列不同时刻的快照 。在进行提交操作时，Git 会保存一个提交对象（commit object）。做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 master 分支会在每次提交时自动向前移动。</p>
<h3 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h3><p>创建新的分支实际就是创建一个新的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch &lt;branchname&gt;</span><br></pre></td></tr></table></figure>

<p>从而在当前所提交的对象上创建一个新的指针。</p>
<h3 id="查看分支所指对象"><a href="#查看分支所指对象" class="headerlink" title="查看分支所指对象"></a>查看分支所指对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --oneline  --decorate</span><br></pre></td></tr></table></figure>

<h3 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<p>此时，HEAD指针就指向了新的分支。</p>
<p><em><strong>分支切换会改变你工作目录中的文件</strong></em><br>在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。</p>
<p>不同的分支提交文件后就会产生项目分叉。</p>
<h3 id="查看分叉历史"><a href="#查看分叉历史" class="headerlink" title="查看分叉历史"></a>查看分叉历史</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --oneline --decorate --graph --all</span><br></pre></td></tr></table></figure>

<p>会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p>
<h3 id="创建分支的同时切换过去"><a href="#创建分支的同时切换过去" class="headerlink" title="创建分支的同时切换过去"></a>创建分支的同时切换过去</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;newbranchname&gt;</span><br></pre></td></tr></table></figure>

<h3 id="快进"><a href="#快进" class="headerlink" title="快进"></a>快进</h3><p>当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#先切换到你要保留的分支</span><br><span class="line">git checkout master</span><br><span class="line">#快进</span><br><span class="line">git merge &lt;branchName&gt;</span><br><span class="line">#删除已经合并的分支</span><br><span class="line">git branch -d &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>三方分别为：第一个分支，第二个分支，两分支的分叉点。</p>
<p>Git 将三方合并的结果做了一个新的快照并且自动创建一个新的提<br>交指向它。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#先切换到你要保留的分支</span><br><span class="line">git checkout master</span><br><span class="line">#三方合并</span><br><span class="line">git merge &lt;branchName&gt;</span><br><span class="line">#删除已经合并的分支</span><br><span class="line">git branch -d &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<h4 id="合并时遇到冲突"><a href="#合并时遇到冲突" class="headerlink" title="合并时遇到冲突"></a>合并时遇到冲突</h4><p>​        如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。</p>
<p>​        Git 会暂停下来，等待你去解决合并产生的冲突。你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件</p>
<p>​    在手动解决文件冲突后，可以再次提交，并确认分支合并。</p>
<h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看已有分支和当前所处分支</span><br><span class="line">git branch</span><br><span class="line">#查看已合并的分支</span><br><span class="line">git branch --merged</span><br><span class="line">#查看未合并的分支</span><br><span class="line">git branch --no-merged</span><br></pre></td></tr></table></figure>

<h2 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h2><h3 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h3><p>​        因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。</p>
<h3 id="主题分支"><a href="#主题分支" class="headerlink" title="主题分支"></a>主题分支</h3><p>​        主题分支对任何规模的项目都适用。 主题分支是一种短期分支，它被用来实现单一特性或其相关工作。</p>
<h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git ls-remote &lt;remote&gt; </span><br></pre></td></tr></table></figure>

<p>来显式地获得远程引用的完整列表， 或者通过 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote show &lt;remote&gt; </span><br></pre></td></tr></table></figure>

<p>获得远程分支的更多信息。 然而，一个更常见的做法是利用远程跟踪分支。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用过程中遇到的一些问题-01</title>
    <url>/%E5%AD%A6%E4%B9%A0/Git/gitPushProblem/</url>
    <content><![CDATA[<h1 id="记录Git使用过程中存在的一些问题"><a href="#记录Git使用过程中存在的一些问题" class="headerlink" title="记录Git使用过程中存在的一些问题"></a>记录Git使用过程中存在的一些问题</h1><p>使用git的过程中总会遇到一些问题。</p>
<span id="more"></span>

<h2 id="用户绑定"><a href="#用户绑定" class="headerlink" title="用户绑定"></a>用户绑定</h2><p>​    用户使用前必须通过SSL密匙连接欸到GitHub账号。这样才能正常使用上传和下拉功能。</p>
<h2 id="push时使用-git-git"><a href="#push时使用-git-git" class="headerlink" title="push时使用 git@git"></a>push时使用 git@git</h2><p>​    向Github仓库push代码时显示;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://github.com/wz1114841863/OpenCV-SampleCode.git/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="出错原因"><a href="#出错原因" class="headerlink" title="出错原因"></a>出错原因</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/wz1114841863/OpenCV-SampleCode.git</span><br></pre></td></tr></table></figure>

<p>​    这里使用了 https传输协议，其他的解决方法并未尝试，这里直接换成了git@github</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>​    解除绑定，换成git@github：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git remote add origin git@github.com:wz1114841863/OpenCV-SampleCode.git</span><br></pre></td></tr></table></figure>

<p>​    接着重新上传，成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">Enumerating objects: 11, done.</span><br><span class="line">Counting objects: 100% (11/11), done.</span><br><span class="line">Delta compression using up to 16 threads</span><br><span class="line">Compressing objects: 100% (9/9), done.</span><br><span class="line">Writing objects: 100% (11/11), 16.79 MiB | 1.62 MiB/s, done.</span><br><span class="line">Total 11 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">To github.com:wz1114841863/OpenCV-SampleCode.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch &#x27;master&#x27; set up to track remote branch &#x27;master&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure>

<h2 id="忽略文件夹名大小写"><a href="#忽略文件夹名大小写" class="headerlink" title="忽略文件夹名大小写"></a>忽略文件夹名大小写</h2><p>git默认在提交时会忽略文件夹名的大小写，从而导致出现问题。</p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看本地仓库git忽略大小写是否打开</span><br><span class="line">$ git config --get core.ignorecase</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>true 表示忽略文件名大小写，可以将其设置为false。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config core.ignorecase false</span><br></pre></td></tr></table></figure>

<h2 id="warning-LF-will-be-replaced-by-CRLF-in-files"><a href="#warning-LF-will-be-replaced-by-CRLF-in-files" class="headerlink" title="warning: LF will be replaced by CRLF in files"></a>warning: LF will be replaced by CRLF in files</h2><p>原因是存在符号转义问题，windows中的换行符为 CRLF， 而在linux下的换行符为LF，所以在执行add . 时出现提示，解决办法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf false=</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 基础知识 01</title>
    <url>/%E5%AD%A6%E4%B9%A0/MySQL/MySQL_01/</url>
    <content><![CDATA[<p>MySQL学习笔记。记录数据库、表的查看、创建、删除和更改等基础操作。</p>
<span id="more"></span>

<h1 id="数据库、表的查看、创建、修改-和-删除"><a href="#数据库、表的查看、创建、修改-和-删除" class="headerlink" title="数据库、表的查看、创建、修改 和 删除"></a>数据库、表的查看、创建、修改 和 删除</h1><h2 id="SHOW"><a href="#SHOW" class="headerlink" title="SHOW"></a>SHOW</h2><p>查询数据库和表等其他信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查看已有的数据库</span><br><span class="line">show database;</span><br><span class="line">//查看已有的表</span><br><span class="line">show tables;</span><br><span class="line">//查看表的具体信息，不包含数据本身</span><br><span class="line">show crearte table tablename；</span><br></pre></td></tr></table></figure>



<h2 id="CREATE"><a href="#CREATE" class="headerlink" title="CREATE"></a>CREATE</h2><p>利用create 创建数据库， 利用use选择数据库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建数据库。</span><br><span class="line">CREATE DATABASE &lt;数据库名称&gt;;</span><br><span class="line">-- 使用数据库</span><br><span class="line">use &lt;数据库名称&gt;;</span><br></pre></td></tr></table></figure>

<p>进入数据库后，才能对表进行操作，利用CREATE TABLE 语句创建表，必须给出下列信息：</p>
<p>​    1.新表的名字，在关键字CREATE TABLE 之后给出；<br>​    2.表列的名字和定义，用逗号分隔；<br>​    3.有的DBMS 还要求指定表的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &lt;表名&gt;</span><br><span class="line">（  &lt;列名1&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;，</span><br><span class="line">    &lt;列名2&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;，</span><br><span class="line">    &lt;列名3&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;，</span><br><span class="line">    &lt;列名4&gt; &lt;数据类型&gt; &lt;该列所需约束&gt;，</span><br><span class="line">    .. .</span><br><span class="line">    &lt;该表的约束1&gt;， &lt;该表的约束2&gt;，……）；</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 示例</span><br><span class="line">create table products(</span><br><span class="line">	prod_id  char(10) not null primary key,</span><br><span class="line">	vend_id  char(10) not null,</span><br><span class="line">	prod_name char(254) not null,</span><br><span class="line">	prod_price decimal(8, 2) not null,</span><br><span class="line">	prod_desc  text(100) null</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="NULL-值"><a href="#NULL-值" class="headerlink" title="NULL 值"></a>NULL 值</h3><p>NULL 值就是没有值或缺值，是表中非常特殊的一类值。允许NULL 值的列也允许在插入行时不给出该列的值。不允许NULL 值的列不接受没有列值的行，换句话说，在插入或更新行时，该列必须有值。</p>
<p>NULL 为默认设置，如果不指定NOT NULL，就认为指定的是NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Vendors(</span><br><span class="line">    vend_id CHAR(10) NOT NULL,</span><br><span class="line">    vend_name CHAR(50) NOT NULL,</span><br><span class="line">    vend_address CHAR(50) ,</span><br><span class="line">    vend_city CHAR(50) ,</span><br><span class="line">    vend_state CHAR(5) ,</span><br><span class="line">    vend_zip CHAR(10) ,</span><br><span class="line">    vend_country CHAR(50)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>只有不允许NULL值的列可作为主键，允许NULL 值的列不能作为唯一标识。</p>
<p>不要把NULL 值与空字符串相混淆。NULL 值是没有值，不是空字符串。如果指定’’（两个单引号，其间没有字符），这在NOT NULL 列中是允许的。空字符串是一个有效的值，它不是无值。NULL 值用关键字NULL而不是空字符串指定。</p>
<h3 id="DEFAULT"><a href="#DEFAULT" class="headerlink" title="DEFAULT"></a>DEFAULT</h3><p>MySQL 允许指定默认值，在插入行时如果不给出值，DBMS 将自动采用默认值。默认值在CREATE TABLE 语句的列定义中用关键字DEFAULT 指定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table Nums(</span><br><span class="line">		num int not null default 0  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="AUTO-INCREMENT-修饰符"><a href="#AUTO-INCREMENT-修饰符" class="headerlink" title="AUTO_INCREMENT 修饰符"></a>AUTO_INCREMENT 修饰符</h3><p>AUTO_INCREMENT 修饰符只适用于 INT 字段，表明 MySQL 应该自动为该字段生成一个数(每次在上一次生成的数值上面加 1)。对于主键，这是非常有用的。因为其允许开发者使用 MySQL 为每条记录创建唯一的标识符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE items( </span><br><span class="line">    id int( 5 ) NOT NULL AUTO_INCREMENT PRIMARY KEY , </span><br><span class="line">    label varchar( 255 ) NOT NULL</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="ALTER"><a href="#ALTER" class="headerlink" title="ALTER"></a>ALTER</h2><p>使用ALTER TABLE 更改表结构，必须给出下面的信息：<br>    1.在ALTER TABLE 之后给出要更改的表名（该表必须存在，否则将出错）；<br>    2.列出要做哪些更改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 添加列</span><br><span class="line">alter table vendors</span><br><span class="line">	add vend_phone char(20);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 删除列</span><br><span class="line">ALTER TABLE Vendors</span><br><span class="line">	DROP COLUMN vend_phone;</span><br></pre></td></tr></table></figure>

<p>**数据库表的删除、更改不能撤销!!!.**除非使用了rollback事务命令。</p>
<h2 id="DROP"><a href="#DROP" class="headerlink" title="DROP"></a>DROP</h2><p>删除数据库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP database &lt;数据库名称&gt;；</span><br></pre></td></tr></table></figure>

<p>删除表（删除整个表而不是其内容）非常简单，使用DROP TABLE 语句即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE CustCopy;</span><br></pre></td></tr></table></figure>

<p>标准SQL 中用来从表中删除数据的只有DELETE 语句。但是，很多数据库产品中还存在另外一种被称为<strong>TRUNCATE</strong> 的语句。这些产品主要包括Oracle、SQLServer、PostgreSQL、MySQL 和DB2。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TRUNCATE &lt;表名&gt;;</span><br></pre></td></tr></table></figure>

<p>与DELETE 不同的是，TRUNCATE 只能删除表中的全部数据，而不能通过WHERE 子句指定条件来删除部分数据。也正是因为它不能具体地控制删除对象，所以其处理速度比DELETE 要快得多。实际上，DELETE 语句在DML 语句中也属于处理时间比较长的，因此需要删除全部数据行时，使用TRUNCATE 可以缩短执行时间。</p>
<h2 id="RENAME"><a href="#RENAME" class="headerlink" title="RENAME"></a>RENAME</h2><p>重命名表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rename table product to products;</span><br></pre></td></tr></table></figure>

<p>重命名表很简单，但是重命名数据库很麻烦。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL Problem 01</title>
    <url>/%E5%AD%A6%E4%B9%A0/MySQL/MySQLProblem01/</url>
    <content><![CDATA[<p>MySQL 学习过程中遇到的一些问题和总结。<span id="more"></span></p>
<h3 id="min等聚集函数不能再where中使用"><a href="#min等聚集函数不能再where中使用" class="headerlink" title="min等聚集函数不能再where中使用"></a>min等聚集函数不能再where中使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#错误代码</span><br><span class="line">select </span><br><span class="line">	e1.name  as employee</span><br><span class="line">from</span><br><span class="line">	employee as e1, employee as e2</span><br><span class="line">where</span><br><span class="line">	e1.managerId = e2.Id</span><br><span class="line">	and</span><br><span class="line">	e1.salary &gt; min(e2.salary)</span><br><span class="line">#这里的min其实并不是必须的，但是用来之后反倒报错</span><br></pre></td></tr></table></figure>

<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>聚合函数是针对结果集进行的，但是where条件并不是在查询出结果集之后运行，所以主函数放在where语句中，会出现错误。</p>
<p>而having不一样，having是针对结果集做筛选的，所以一般把聚集函数放在having中。having一般跟在group by后。</p>
<h3 id="limit-1-1-不能再使用"><a href="#limit-1-1-不能再使用" class="headerlink" title="limit 1, -1 不能再使用"></a>limit 1, -1 不能再使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table limit 3，-1</span><br></pre></td></tr></table></figure>

<p> 这样的语句之前可以执行，现在无法执行。新版本的MySQL对此作出了修复，替代方法是第二个参数用一个较大的正数代替。</p>
<h3 id="You-can’t-specify-target-table-for-update-in-FROM-clause"><a href="#You-can’t-specify-target-table-for-update-in-FROM-clause" class="headerlink" title="You can’t specify target table for update in FROM clause"></a>You can’t specify target table for update in FROM clause</h3><p>错误的意思是说，不能先select出同一表中的某些值，再update/delete这个表(在同一语句中)。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#报错</span><br><span class="line">delete from Person</span><br><span class="line">where</span><br><span class="line">    id in (</span><br><span class="line">            select id</span><br><span class="line">            from Person</span><br><span class="line">            group by Email</span><br><span class="line">    )</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>解决方法1：将select出的结果再通过中间表select一遍，这样就规避了错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from Person</span><br><span class="line">where</span><br><span class="line">    id in (</span><br><span class="line">        select a.id from(</span><br><span class="line">            select id</span><br><span class="line">            from Person</span><br><span class="line">            group by Email</span><br><span class="line">            order by id</span><br><span class="line">            limit 1, 1000</span><br><span class="line">        )a</span><br><span class="line">    )</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>解决方法2：使用；left join 替换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update x set available_material_id = null where id not in (select id from x where additional_info = 1);</span><br><span class="line"> </span><br><span class="line">-- 使用left join 改写</span><br><span class="line">update x left join</span><br><span class="line">       x xx</span><br><span class="line">       on x.id = xx.id and xx.additional_info = 1</span><br><span class="line">    set available_material_id = null</span><br><span class="line">    where xx.id is null;</span><br></pre></td></tr></table></figure>

<h3 id="UNION-与-Order-by-的使用"><a href="#UNION-与-Order-by-的使用" class="headerlink" title="UNION 与 Order by 的使用"></a>UNION 与 Order by 的使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--错误用法</span><br><span class="line">SELECT * FROM t1 WHERE username LIKE &#x27;l%&#x27; ORDER BY score ASC</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM t1 WHERE username LIKE &#x27;%m%&#x27; ORDER BY score ASC</span><br><span class="line">--union在没有括号的情况下只能使用一个order by</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--1.仅在最后一个select语句中使用order by</span><br><span class="line">SELECT * FROM t1 WHERE username LIKE &#x27;l%&#x27; score ASC</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM t1 WHERE username LIKE &#x27;%m%&#x27; ORDER BY score ASC</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--2.通过两个查询分别加括号的方式</span><br><span class="line">SELECT * FROM</span><br><span class="line">(SELECT * FROM t1 WHERE username LIKE &#x27;l%&#x27; ORDER BY score ASC) t3</span><br><span class="line">UNION </span><br><span class="line">SELECT * FROM</span><br><span class="line">(SELECT * FROM t1 WHERE username LIKE &#x27;%m%&#x27; ORDER BY score ASC) t4</span><br><span class="line">--order by不能直接出现在union的子句中，但是可以出现在子句的子句中。</span><br></pre></td></tr></table></figure>

<h3 id="select-后面的列于order-by"><a href="#select-后面的列于order-by" class="headerlink" title="select 后面的列于order by"></a>select 后面的列于order by</h3><p>一般来说，select 后面的列必须出现于 order by 之后。</p>
<p>除非有以下特殊情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.使用了聚合函数的列</span><br><span class="line">2.order by 后已经包含了主键</span><br><span class="line">3.sql_mode动态去除ONLY_FULL_GROUP_BY限制</span><br></pre></td></tr></table></figure>

<h3 id="‘’中再出现‘需要使用转义字符"><a href="#‘’中再出现‘需要使用转义字符" class="headerlink" title="‘’中再出现‘需要使用转义字符"></a>‘’中再出现‘需要使用转义字符</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * </span><br><span class="line">from nobel</span><br><span class="line">where winner = &#x27;EUGENE O\&#x27;NEILL&#x27;</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h3 id="distinct不能同时筛选两列"><a href="#distinct不能同时筛选两列" class="headerlink" title="distinct不能同时筛选两列"></a>distinct不能同时筛选两列</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from Person</span><br><span class="line">where id not in(</span><br><span class="line">        select a.id from(</span><br><span class="line">            select  distinct id, Email </span><br><span class="line">            from Person</span><br><span class="line">            group by Email</span><br><span class="line">        ) as a </span><br><span class="line">)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>由于id是主键，所以筛选出来的每一列都表示不同， 而并不会去筛选email是否不同。</p>
<p>所以distinct的功能并没有的我想的那么强大。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实际中我们往往用distinct来返回不重复字段的条数（count(distinct id)）,其原因是distinct只能返回他的目标字段，而无法返回其他字段。</span><br></pre></td></tr></table></figure>

<h3 id="All"><a href="#All" class="headerlink" title="All"></a>All</h3><p>使用关键字All  &gt;、&lt;  …一个列表内的所有内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">from world</span><br><span class="line">where gdp &gt; All(</span><br><span class="line">          select gdp</span><br><span class="line">          from world</span><br><span class="line">          where continent = &#x27;Europe&#x27; and   gdp&gt;0 </span><br><span class="line">) </span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h3 id="MySQL语句执行顺序"><a href="#MySQL语句执行顺序" class="headerlink" title="MySQL语句执行顺序"></a>MySQL语句执行顺序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY</span><br></pre></td></tr></table></figure>

<h3 id="IN-、NOT-IN-中不能使用-NULL"><a href="#IN-、NOT-IN-中不能使用-NULL" class="headerlink" title="IN 、NOT IN  中不能使用 NULL"></a>IN 、NOT IN  中不能使用 NULL</h3><p><strong>结论 ： MySQL中NULL是不参与计算的，对NULL进行计算，只可以使用预设的IS NULL和IS NOT NULL来操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1.查询表</span><br><span class="line">mysql&gt; select product_name, purchase_price  from  product;</span><br><span class="line">+--------------+----------------+</span><br><span class="line">| product_name | purchase_price |</span><br><span class="line">+--------------+----------------+</span><br><span class="line">| T恤衫        |            500 |</span><br><span class="line">| 打孔器       |            320 |</span><br><span class="line">| 运动T恤      |           2800 |</span><br><span class="line">| 菜刀         |           2800 |</span><br><span class="line">| 高压锅       |           5000 |</span><br><span class="line">| 叉子         |           NULL |</span><br><span class="line">| 擦菜板       |            790 |</span><br><span class="line">| 圆珠笔       |           NULL |</span><br><span class="line">+--------------+----------------+</span><br><span class="line"></span><br><span class="line">-- 2. 使用not in 查询</span><br><span class="line">mysql&gt; SELECT product_name, purchase_price</span><br><span class="line">    -&gt; FROM Product</span><br><span class="line">    -&gt; WHERE purchase_price NOT IN (500, 2800, 5000);</span><br><span class="line">+--------------+----------------+</span><br><span class="line">| product_name | purchase_price |</span><br><span class="line">+--------------+----------------+</span><br><span class="line">| 打孔器       |            320 |</span><br><span class="line">| 擦菜板       |            790 |</span><br><span class="line">+--------------+----------------+</span><br><span class="line">-- 可以看到NULL查询不到</span><br><span class="line"></span><br><span class="line">-- 3. 使用 NOT　in（ＮＵＬＬ）　查询</span><br><span class="line">mysql&gt; SELECT product_name, purchase_price</span><br><span class="line">    -&gt;   FROM Product</span><br><span class="line">    -&gt;  WHERE purchase_price NOT IN (500, 2800, 5000, NULL);</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">-- 为空，　因为　NULL　影响了　NOT IN　的计算，所以直接返回空。</span><br></pre></td></tr></table></figure>

<h3 id="mysql-实现nulls-first"><a href="#mysql-实现nulls-first" class="headerlink" title="mysql 实现nulls first"></a>mysql 实现nulls first</h3><p>mysql中不像oracle，nulls first nulls last无效。可以使用下面的语句代替。</p>
<p>nulls first:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> IF(ISNULL(my_field),<span class="number">0</span>,<span class="number">1</span>),my_field;  </span><br></pre></td></tr></table></figure>

<p>nulls last:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> IF(ISNULL(my_field),<span class="number">1</span>,<span class="number">0</span>),my_field; </span><br></pre></td></tr></table></figure>

<p>ISNULL函数当my_field字段为空是，返回1，当不为空时返回0</p>
<p>IF函数，如果第一个表达式为真，则返回第二个参数的值，否则，返回第三个参数的值。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 基础知识 02</title>
    <url>/%E5%AD%A6%E4%B9%A0/MySQL/MySQL_02/</url>
    <content><![CDATA[<p>MySQL学习笔记。 向表中插入、 更新 和 删除数据。<span id="more"></span></p>
<h1 id="数据的插入、更新-和-删除"><a href="#数据的插入、更新-和-删除" class="headerlink" title="数据的插入、更新 和 删除"></a>数据的插入、更新 和 删除</h1><h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><p>INSERT 用来将行插入（或添加）到数据库表。</p>
<p>​    1.插入完整的行。</p>
<p>​    2.插入行的一部分。</p>
<p>​    3.插入某些查询到结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO Customers VALUES(</span><br><span class="line">    &#x27;1000000006&#x27;,</span><br><span class="line">    &#x27;Toy Land&#x27;,</span><br><span class="line">    &#x27;123 Any Street&#x27;,</span><br><span class="line">    &#x27;New York&#x27;,</span><br><span class="line">    &#x27;NY&#x27;,</span><br><span class="line">    &#x27;11111&#x27;,</span><br><span class="line">    &#x27;USA&#x27;,</span><br><span class="line">    NULL,</span><br><span class="line">    NULL);</span><br></pre></td></tr></table></figure>

<p>繁琐但更安全的方式：对应列名进行插入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO Customers(</span><br><span class="line">    cust_id,</span><br><span class="line">    cust_name,</span><br><span class="line">    cust_address,</span><br><span class="line">    cust_city,</span><br><span class="line">    cust_state,</span><br><span class="line">    cust_zip,</span><br><span class="line">    cust_country,</span><br><span class="line">    cust_contact,</span><br><span class="line">    cust_email)</span><br><span class="line">VALUES(</span><br><span class="line">    &#x27;1000000006&#x27;,</span><br><span class="line">    &#x27;Toy Land&#x27;,</span><br><span class="line">    &#x27;123 Any Street&#x27;,</span><br><span class="line">    &#x27;New York&#x27;,</span><br><span class="line">    &#x27;NY&#x27;,</span><br><span class="line">    &#x27;11111&#x27;,</span><br><span class="line">    &#x27;USA&#x27;,</span><br><span class="line">    NULL,</span><br><span class="line">    NULL);</span><br></pre></td></tr></table></figure>

<p>如果表的定义允许，则可以在INSERT 操作中省略某些列。但是省略的列必须满足以下某个条件。<br>    1.该列定义为允许NULL 值（无值或空值）。<br>    2.在表定义中给出默认值。这表示如果不给出值，将使用默认值。</p>
<h3 id="INSERT-SELECT"><a href="#INSERT-SELECT" class="headerlink" title="INSERT SELECT"></a>INSERT SELECT</h3><p>i除此之外还能使用 <strong>insert  select</strong> 语句。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO Customers(cust_id,</span><br><span class="line">        cust_contact,</span><br><span class="line">        cust_email,</span><br><span class="line">        cust_name,</span><br><span class="line">        cust_address,</span><br><span class="line">        cust_city,</span><br><span class="line">        cust_state,</span><br><span class="line">        cust_zip,</span><br><span class="line">        cust_country)</span><br><span class="line">SELECT cust_id,</span><br><span class="line">        cust_contact,</span><br><span class="line">        cust_email,</span><br><span class="line">        cust_name,</span><br><span class="line">        cust_address,</span><br><span class="line">        cust_city,</span><br><span class="line">        cust_state,</span><br><span class="line">        cust_zip,</span><br><span class="line">        cust_country</span><br><span class="line">FROM CustNew;</span><br></pre></td></tr></table></figure>

<p>​    1.INSERT SELECT 中SELECT 语句可以包含WHERE 子句，以过滤插入的数据。</p>
<p>​    2.不管SELECT语句返回多少行，都将被INSERT 插入。</p>
<p>​    3.INSERT语句的SELECT语句中，可以使用WHERE子句或者GROUP BY子句等任何SQL语法（ ORDER BY子句并不会产生任何效果）。</p>
<h3 id="SELECT-INTO"><a href="#SELECT-INTO" class="headerlink" title="SELECT INTO"></a>SELECT INTO</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">INTO CustCopy</span><br><span class="line">FROM Customers;</span><br></pre></td></tr></table></figure>

<h3 id="插入默认值或NULL值"><a href="#插入默认值或NULL值" class="headerlink" title="插入默认值或NULL值"></a>插入默认值或NULL值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--插入默认值</span><br><span class="line">INSERT INTO ProductIns (product_id, product_name, product_type, sale_price, purchase_price, regist_date) VALUES (&#x27;0007&#x27;, &#x27;擦菜板&#x27;, &#x27;厨房用具&#x27;, DEFAULT, 790, &#x27;2009-04-28&#x27;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--插入NULL</span><br><span class="line">INSERT INTO ProductIns (product_id, product_name, product_type, sale_price, purchase_price, regist_date) VALUES (&#x27;0006&#x27;, &#x27;叉子&#x27;, &#x27;厨房用具&#x27;, 500, NULL, &#x27;2009-09-20&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h2><h3 id="有两种使用UPDATE的方式"><a href="#有两种使用UPDATE的方式" class="headerlink" title="有两种使用UPDATE的方式"></a>有两种使用UPDATE的方式</h3><p>​    1.更新表中的特定行；</p>
<p>​    2.更新表中的所有行。</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>​    1.要更新的表；</p>
<p>​    2.列名和它们的新值；</p>
<p>​    3.确定要更新哪些行的过滤条件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE Customers</span><br><span class="line">SET cust_email = &#x27;kim@thetoystore.com&#x27;</span><br><span class="line">WHERE cust_id = &#x27;1000000005&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE Customers</span><br><span class="line">SET cust_contact = &#x27;Sam Roberts&#x27;,</span><br><span class="line">	cust_email = &#x27;sam@toyland.com&#x27;</span><br><span class="line">WHERE cust_id = &#x27;1000000006&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 将列用()括起来的清单形式</span><br><span class="line">UPDATE Product</span><br><span class="line">SET (sale_price, purchase_price) = (sale_price * 10, purchase_price / 2)</span><br><span class="line">WHERE product_type = &#x27;厨房用具&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><h3 id="有两种使用DELETE的方式"><a href="#有两种使用DELETE的方式" class="headerlink" title="有两种使用DELETE的方式"></a>有两种使用DELETE的方式</h3><p>​    1.从表中删除特定的行；  </p>
<p>​    2.从表中删除所有行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM Customers</span><br><span class="line">WHERE cust_id = &#x27;1000000006&#x27;;</span><br></pre></td></tr></table></figure>

<p>DELETE 不需要列名或通配符。DELETE 删除整行而不是删除列。要删除指定的列，请使用UPDATE 语句。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 基础知识 03</title>
    <url>/%E5%AD%A6%E4%B9%A0/MySQL/MySQL_03/</url>
    <content><![CDATA[<p>MySQL学习笔记。从表中检索数据。<span id="more"></span></p>
<h1 id="检索表中的数据"><a href="#检索表中的数据" class="headerlink" title="检索表中的数据"></a>检索表中的数据</h1><p>SQL 语句不区分大小写。在处理SQL 语句时，其中所有空格都被忽略。</p>
<p>在MySQL中一般都不区分大小写，也可以设置表明区分大小写等。</p>
<h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 如果没有明确排序查询结果，则返回的数据没有特定的顺序。</span><br><span class="line">select * from table;</span><br><span class="line"></span><br><span class="line">-- 这样检索出来的数据显示的都是数据的原始储存格式。</span><br><span class="line">select column1, column2, column3 from table;</span><br></pre></td></tr></table></figure>

<p>SELECT 子句中不仅可以书写列名，还可以书写常数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT &#x27;商品&#x27; AS string, 38 AS number, &#x27;2009-02-24&#x27; AS date,</span><br><span class="line">product_id, product_name</span><br><span class="line">FROM Product;</span><br></pre></td></tr></table></figure>

<h3 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h3><p>检索不同的值。</p>
<h4 id="注意：不能部分使用DISTINCT"><a href="#注意：不能部分使用DISTINCT" class="headerlink" title="注意：不能部分使用DISTINCT"></a>注意：不能部分使用DISTINCT</h4><p>DISTINCT 关键字作用于所有的列，不仅仅是跟在其后的那一列。例如，你指定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT vend_id, prod_price；</span><br></pre></td></tr></table></figure>

<p>除非指定的两列完全相同，否则所有的行都会被检索出来。</p>
<p>在使用DISTINCT 时，NULL 也被视为一类数据。NULL 存在于多行中时，也会被合并为一条NULL 数据。</p>
<h3 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h3><p>对查找到结果进行限制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询前5行。</span><br><span class="line">select vend_id from products limit 5;</span><br></pre></td></tr></table></figure>

<h3 id="OFFSET"><a href="#OFFSET" class="headerlink" title="OFFSET"></a>OFFSET</h3><p>偏移量。第一个被检索的行是第0 行，而不是第1 行。因此，LIMIT 1 OFFSET1 会检索第2 行，而不是第1 行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询从第五行开始的五行数据。</span><br><span class="line">select vend_id from products limit 5 offset 5;</span><br><span class="line">#limit 和 offset 顺序不能颠倒。</span><br><span class="line">#简写</span><br><span class="line">select vend_id from products limit 5 ,3;</span><br><span class="line">#使用这个语法，逗号之前的值对应OFFSET，逗号之后的值对应LIMIT。</span><br></pre></td></tr></table></figure>

<h2 id="ORDER-BY-排序数据"><a href="#ORDER-BY-排序数据" class="headerlink" title="ORDER BY  排序数据"></a>ORDER BY  排序数据</h2><p>为了明确地排序用SELECT 语句检索出的数据，可使用ORDER BY 子句。ORDER BY 子句取一个或多个列的名字，据此对输出进行排序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select prod_name from products order by prod_name;</span><br><span class="line">#并不一定要是最后一条语句。</span><br><span class="line">select prod_name from products order by prod_name limit 5 offset 2;</span><br><span class="line">#按多个列进行排序，只有在前一列出现重复行时，后一列的排序效果才有用。</span><br><span class="line"> SELECT </span><br><span class="line"> 	prod_id, prod_price, prod_name</span><br><span class="line"> FROM </span><br><span class="line"> 	Products</span><br><span class="line"> Order by</span><br><span class="line"> 	prod_price, prod_name;</span><br><span class="line">#按多个列进行排序，还可以使用列的相对位置。</span><br><span class="line">#prod_price 是select选定的第二列, prod_name是第三列。</span><br><span class="line"> SELECT </span><br><span class="line"> 	prod_id, prod_price, prod_name</span><br><span class="line"> FROM </span><br><span class="line"> 	Products</span><br><span class="line"> Order by</span><br><span class="line"> 	2, 3;</span><br></pre></td></tr></table></figure>

<h3 id="DESC"><a href="#DESC" class="headerlink" title="DESC"></a>DESC</h3><p>降序排列，与DISTINCT不同，DESC 关键字只应用到直接位于其前面的列名，如果想在多个列上进行降序排序，必须对每一列指定DESC 关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_id, prod_price, prod_name</span><br><span class="line">FROM Products</span><br><span class="line">ORDER BY prod_price DESC, prod_name DESC;</span><br></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="单行注释："><a href="#单行注释：" class="headerlink" title="单行注释："></a>单行注释：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 注释1   注意： -- 后面必须跟空格</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 注释2</span><br></pre></td></tr></table></figure>

<h3 id="多行注释："><a href="#多行注释：" class="headerlink" title="多行注释："></a>多行注释：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">	多行注释3.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*!</span><br><span class="line">	多行注释4.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 基础知识 04</title>
    <url>/%E5%AD%A6%E4%B9%A0/MySQL/MySQL_04/</url>
    <content><![CDATA[<p>MySQL学习笔记。对数据进行过滤。<span id="more"></span></p>
<h1 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h1><p>只检索所需数据需要指定<strong>搜索条件</strong>，搜索条件也称为过滤条件。</p>
<h2 id="利用where进行过滤"><a href="#利用where进行过滤" class="headerlink" title="利用where进行过滤"></a>利用where进行过滤</h2><p><strong>where</strong> 用来对每行数据指定搜索条件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM Products</span><br><span class="line">WHERE prod_price = 3.49</span><br><span class="line">order by prod_id;</span><br><span class="line">-- order by 必须在where之后。</span><br></pre></td></tr></table></figure>

<img src = "/images/MySQL/MySQL01.png">

<p>单引号用来限定字符串。如果将值与字符串类型的列进行比较，就需要限定引号。用来与数值列进行比较的值不用引号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_id, prod_name</span><br><span class="line">FROM Products</span><br><span class="line">WHERE vend_id != &#x27;DLL01&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM Products</span><br><span class="line">WHERE prod_price BETWEEN 5 AND 10;</span><br></pre></td></tr></table></figure>

<p>通过过滤选择不包含指定值的所有行时，你可能希望返回含NULL 值的行。但是这做不到。因为未知（unknown）有特殊的含义，数据库不知道它们是否匹配，所以在进行匹配过滤或非匹配过滤时，不会返回这些结果。过滤数据时，一定要验证被过滤列中含NULL 的行确实出现在返回的数据中。</p>
<p><strong>SQL 允许给出多个WHERE 子句</strong>。这些子句有两种使用方式，即以AND 子句或OR 子句的方式使用。</p>
<h2 id="利用操作符号进行过滤"><a href="#利用操作符号进行过滤" class="headerlink" title="利用操作符号进行过滤"></a>利用操作符号进行过滤</h2><h3 id="AND操作符"><a href="#AND操作符" class="headerlink" title="AND操作符"></a>AND操作符</h3><p>用在WHERE 子句中的关键字，用来指示检索满足所有给定条件的行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select prod_id, prod_price, prod_name</span><br><span class="line">from products</span><br><span class="line">where vend_id = &#x27;DLL01&#x27; AND prod_price &lt;= 4;</span><br></pre></td></tr></table></figure>

<h3 id="OR操作符"><a href="#OR操作符" class="headerlink" title="OR操作符"></a>OR操作符</h3><p>OR 操作符与AND 操作符正好相反，它指示DBMS 检索匹配任一条件的行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select prod_id, prod_price, prod_name</span><br><span class="line">from products</span><br><span class="line">where vend_id = &#x27;DLL01&#x27; or  prod_price &lt;= 10;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src = "/images/MySQL/MySQL02.png">

<h3 id="运算顺序"><a href="#运算顺序" class="headerlink" title="运算顺序"></a>运算顺序</h3><p>SQL（像多数语言一样）在处理OR 操作符前，优先处理AND 操作符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM Products</span><br><span class="line">WHERE (vend_id = &#x27;DLL01&#x27; OR vend_id = &#x27;BRS01&#x27;)</span><br><span class="line">AND prod_price &gt;= 10;</span><br></pre></td></tr></table></figure>

<p>任何时候使用具有AND 和OR 操作符的WHERE 子句，都应该使用圆括号明确地分组操作符。</p>
<h3 id="IN操作符"><a href="#IN操作符" class="headerlink" title="IN操作符"></a>IN操作符</h3><p>WHERE 子句中用来指定要匹配值的清单的关键字，功能与OR 相当。</p>
<p>IN 操作符用来指定条件范围，范围中的每个条件都可以进行匹配。IN 取一组由逗号分隔、括在圆括号中的合法值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM Products</span><br><span class="line">WHERE vend_id IN ( &#x27;DLL01&#x27;, &#x27;BRS01&#x27; )</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>

<p>为什么要使用IN 操作符？其优点如下。</p>
<p>​    1.在有很多合法选项时，IN 操作符的语法更清楚，更直观。</p>
<p>​    2.在与其他AND 和OR 操作符组合使用IN 时，求值顺序更容易管理。</p>
<p>​    3.IN 操作符一般比一组OR 操作符执行得更快.</p>
<p>​    4.IN 的最大优点是可以包含其他SELECT 语句，能够更动态地建立WHERE 子句。</p>
<h3 id="NOT操作符"><a href="#NOT操作符" class="headerlink" title="NOT操作符"></a>NOT操作符</h3><p>WHERE 子句中用来否定其后条件的关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM Products</span><br><span class="line">WHERE NOT vend_id = &#x27;DLL01&#x27;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>

<h3 id="EXIST-操作符"><a href="#EXIST-操作符" class="headerlink" title="EXIST 操作符"></a>EXIST 操作符</h3><p>EXIST 是只有1 个参数的谓词。EXIST 只需要在右侧书写1 个参数，该参数通常都会是一个关联子查询。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作为EXIST参数的子查询中经常会使用SELECT *。</span><br><span class="line">关联子查询的返回值并不重要。</span><br></pre></td></tr></table></figure>

<h2 id="利用CASE表达式"><a href="#利用CASE表达式" class="headerlink" title="利用CASE表达式"></a>利用CASE表达式</h2><p>CASE表达式的语法分为简单CASE表达式和搜索CASE表达式两种。<br>其中搜索CASE 表达式包含了简单CASE 表达式的全部功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CASE    WHEN &lt;求值表达式&gt; THEN &lt;表达式&gt;</span><br><span class="line">        WHEN &lt;求值表达式&gt; THEN &lt;表达式&gt;</span><br><span class="line">        WHEN &lt;求值表达式&gt; THEN &lt;表达式&gt;</span><br><span class="line">        .. .</span><br><span class="line">        ELSE &lt;表达式&gt;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>WHEN 子句中的“&lt; 求值表达式&gt;”就是类似“列 = 值”这样，返回值为真值（TRUE/FALSE/UNKNOWN）的表达式。我们也可以将其看作使用=、!= 或者LIKE、BETWEEN 等谓词编写出来的表达式。</p>
<p>CASE 表达式会从对最初的WHEN 子句中的“&lt; 求值表达式&gt;”进行求值开始执行。所谓求值，就是要调查该表达式的真值是什么。如果结果为真（TRUE），那么就返回THEN 子句中的表达式，CASE 表达式的执行到此为止。如果结果不为真，那么就跳转到下一条WHEN 子句的求值之中。如果直到最后的WHEN 子句为止返回结果都不为真，那么就会返回ELSE中的表达式，执行终止。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 使用简单CASE表达式的情况</span><br><span class="line">SELECT product_name,</span><br><span class="line">        CASE product_type</span><br><span class="line">            WHEN &#x27;衣服&#x27; THEN &#x27;A ：&#x27; | | product_type</span><br><span class="line">            WHEN &#x27;办公用品&#x27; THEN &#x27;B ：&#x27; | | product_type</span><br><span class="line">            WHEN &#x27;厨房用具&#x27; THEN &#x27;C ：&#x27; | | product_type</span><br><span class="line">        ELSE NULL</span><br><span class="line">        END AS abc_product_type</span><br><span class="line">FROM Product;</span><br><span class="line"></span><br><span class="line">-- 使用搜索case表达式的情况</span><br><span class="line">select product_name,</span><br><span class="line">          case WHEN product_type = &#x27;衣服&#x27;  THEN concat(&#x27;A:&#x27;, product_type)</span><br><span class="line">               WHEN product_type = &#x27;办公用品&#x27;  THEN concat(&#x27;B:&#x27;,product_type)</span><br><span class="line">               WHEN product_type = &#x27;厨房用具&#x27; THEN concat(&#x27;C:&#x27;, product_type)</span><br><span class="line">         ELSE NULL</span><br><span class="line">          END AS abc_product_type</span><br><span class="line">FROM product;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--实现行列转换</span><br><span class="line">select  sum(case when product_type = &#x27;衣服&#x27; THEN sale_price else 0 END) as sum_price_clothes,</span><br><span class="line">        sum(case when product_type = &#x27;厨房用具&#x27; THEN sale_price else 0 END) as sum_price_kitchen,</span><br><span class="line">        sum(case when product_type = &#x27;办公用品&#x27; THEN sale_price else 0 END) as sum_price_oddice</span><br><span class="line">from product;</span><br></pre></td></tr></table></figure>

<h2 id="利用通配符进行过滤"><a href="#利用通配符进行过滤" class="headerlink" title="利用通配符进行过滤"></a>利用通配符进行过滤</h2><p>利用通配符，可以创建比较特定数据的搜索模式。</p>
<p>通配符本身实际上是SQL 的WHERE 子句中有特殊含义的字符，SQL 支持几种通配符。为在搜索子句中使用通配符，必须使用LIKE 操作符。LIKE指示DBMS，后跟的搜索模式利用通配符匹配而不是简单的相等匹配进行比较。</p>
<p>通配符搜索只能用于文本字段（字符串），非文本数据类型字段不能使用通配符搜索。</p>
<h3 id="号通配符"><a href="#号通配符" class="headerlink" title="%号通配符"></a>%号通配符</h3><p>在搜索串中，%表示任何字符出现任意次数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_id, prod_name</span><br><span class="line">FROM Products</span><br><span class="line">WHERE prod_name LIKE &#x27;Fish%&#x27;;</span><br></pre></td></tr></table></figure>

<p>%代表搜索模式中给定位置的0 个、1 个或多个字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意：</span><br><span class="line">包括Access 在内的许多DBMS 都用空格来填补字段的内容。例如，如果某列有50 个字符，而存储的文本为Fish bean bag toy（17 个字符），则为填满该列需要在文本后附加33 个空格。这样做一般对数据</span><br><span class="line">及其使用没有影响，但是可能对上述SQL语句有负面影响。子句WHEREprod_name LIKE &#x27;F%y&#x27;只匹配以F 开头、以y 结尾的prod_name。如果值后面跟空格，则不是以y 结尾，所以Fish bean bag toy 就</span><br><span class="line">不会检索出来。简单的解决办法是给搜索模式再增加一个%号：&#x27;F%y%&#x27;还匹配y 之后的字符（或空格）。更好的解决办法是用函数去掉空格。</span><br></pre></td></tr></table></figure>

<h4 id="注意：请注意NULL"><a href="#注意：请注意NULL" class="headerlink" title="注意：请注意NULL"></a>注意：请注意NULL</h4><p>通配符%看起来像是可以匹配任何东西，但有个例外，这就是NULL。子句WHERE prod_name LIKE ‘%’不会匹配产品名称为NULL 的行。</p>
<h3 id="下划线（-）通配符"><a href="#下划线（-）通配符" class="headerlink" title="下划线（_）通配符"></a>下划线（_）通配符</h3><p>下划线的用途与%一样，但它只匹配单个字符，而不是多个字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_id, prod_name</span><br><span class="line">FROM Products</span><br><span class="line">WHERE prod_name LIKE &#x27;__ inch teddy bear&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="正则表达式REGEXP"><a href="#正则表达式REGEXP" class="headerlink" title="正则表达式REGEXP"></a>正则表达式REGEXP</h3><p>使用通配符时的技巧</p>
<p> 1.不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。<br> 2.在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。<br> 3.仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 基础知识 05</title>
    <url>/%E5%AD%A6%E4%B9%A0/MySQL/MySQL_05/</url>
    <content><![CDATA[<p>MySQL学习笔记。通过使用计算字段对检索到的数据进行初步处理<span id="more"></span></p>
<h1 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h1><p>我们需要直接从数据库中检索出转换、计算或格式化过的数据，而不是检索出数据，然后再在客户端应用程序中重新格式化。</p>
<p>计算字段并不实际存在于数据库表中。计算字段是运行时在SELECT 语句内创建的。</p>
<h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h2><p>SQL 语句中进行运算时，需要特别注意含有NULL 的运算。所有包含NULL 的计算，结果肯定是NULL。</p>
<h2 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h2><p>将值联结到一起（将一个值附加到另一个值）构成单个值。MySQL使用Concat（）函数来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT Concat(vend_name, &#x27; (&#x27;, vend_country, &#x27;)&#x27;)</span><br><span class="line">FROM Vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>

<h2 id="使用别名-（ALIAS）"><a href="#使用别名-（ALIAS）" class="headerlink" title="使用别名 （ALIAS）"></a>使用别名 （ALIAS）</h2><p>别名（alias）是一个字段或值的替换名。别名用AS 关键字赋予。可以减少代码的冗余。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select concat(vend_name, &#x27;(&#x27; , vend_country, &#x27;)&#x27; )  as line</span><br><span class="line">from vendors</span><br><span class="line">order by vend_name;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#结果</span><br><span class="line">+------------------------+</span><br><span class="line">| line                   |</span><br><span class="line">+------------------------+</span><br><span class="line">| Bear Emporium(USA)     |</span><br><span class="line">| Bears R Us(USA)        |</span><br><span class="line">| Doll House Inc.(USA)   |</span><br><span class="line">| Fun and Games(England) |</span><br><span class="line">| Furball Inc.(USA)      |</span><br><span class="line">| Jouets et ours(France) |</span><br><span class="line">+------------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="执行算数运算"><a href="#执行算数运算" class="headerlink" title="执行算数运算"></a>执行算数运算</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_id,</span><br><span class="line">        quantity,</span><br><span class="line">        item_price,</span><br><span class="line">        quantity*item_price AS expanded_price</span><br><span class="line">FROM OrderItems</span><br><span class="line">WHERE order_num = 20008;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------+----------+------------+----------------+</span><br><span class="line">| prod_id | quantity | item_price | expanded_price |</span><br><span class="line">+---------+----------+------------+----------------+</span><br><span class="line">| RGAN01  |        5 |       4.99 |          24.95 |</span><br><span class="line">| BR03    |        5 |      11.99 |          59.95 |</span><br><span class="line">| BNBG01  |       10 |       3.49 |          34.90 |</span><br><span class="line">| BNBG02  |       10 |       3.49 |          34.90 |</span><br><span class="line">| BNBG03  |       10 |       3.49 |          34.90 |</span><br><span class="line">+---------+----------+------------+----------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="使用SELECT语句测试计算"><a href="#使用SELECT语句测试计算" class="headerlink" title="使用SELECT语句测试计算"></a>使用SELECT语句测试计算</h3><p>SELECT 语句为测试、检验函数和计算提供了很好的方法。虽然SELECT通常用于从表中检索数据，但是省略了FROM 子句后就是简单地访问和处理表达式，例如SELECT 3 * 2;将返回6，SELECT Trim(‘ abc ‘);将返回abc，SELECT Now();使用Now()函数返回当前日期和时间。可以根据需要使用SELECT 语句进行检验。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select now();</span><br><span class="line">+---------------------+</span><br><span class="line">| now()               |</span><br><span class="line">+---------------------+</span><br><span class="line">| 2021-08-23 11:14:12 |</span><br><span class="line">+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>与几乎所有DBMS 都等同地支持SQL 语句（如SELECT）不同，每一个DBMS 都有特定的函数。事实上，只有少数几个函数被所有主要的DBMS等同地支持。虽然所有类型的函数一般都可以在每个DBMS 中使用，但各个函数的名称和语法可能极其不同。</p>
<h2 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h2><p>对某些行运行的函数，计算并返回一个值。</p>
<img src = "/images/MySQL/MySQL05.png">

<h3 id="AVG"><a href="#AVG" class="headerlink" title="AVG()"></a>AVG()</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT AVG(prod_price) AS avg_price</span><br><span class="line">FROM Products;</span><br></pre></td></tr></table></figure>

<p>AVG()函数忽略列值为NULL 的行。</p>
<h3 id="COUNT-函数"><a href="#COUNT-函数" class="headerlink" title="COUNT()函数"></a>COUNT()函数</h3><p>COUNT()函数进行计数。可利用COUNT()确定表中行的数目或符合特定条件的行的数目。</p>
<p>COUNT()函数有两种使用方式：<br>1.使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL 值。</p>
<p>2.使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(cust_email) AS num_cust</span><br><span class="line">FROM Customers;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*) AS num_cust</span><br><span class="line">FROM Customers;</span><br></pre></td></tr></table></figure>

<p>如果指定列名，则COUNT()函数会忽略指定列的值为空的行，但如果COUNT()函数中用的是星号（*），则不忽略。</p>
<h3 id="MAX-函数"><a href="#MAX-函数" class="headerlink" title="MAX()函数"></a>MAX()函数</h3><p>MAX()返回指定列中的最大值。MAX()要求指定列名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT MAX(prod_price) AS max_price</span><br><span class="line">FROM Products;</span><br></pre></td></tr></table></figure>

<p>虽然MAX()一般用来找出最大的数值或日期值，但许多（并非所有）DBMS 允许将它用来返回任意列中的最大值，包括返回文本列中的最大值。在用于文本数据时，MAX()返回按该列排序后的最后一行。</p>
<p>MAX()函数忽略列值为NULL 的行。</p>
<h3 id="MIN-函数"><a href="#MIN-函数" class="headerlink" title="MIN()函数"></a>MIN()函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT MIN(prod_price) AS min_price</span><br><span class="line">FROM Products;</span><br></pre></td></tr></table></figure>

<h3 id="SUM-函数"><a href="#SUM-函数" class="headerlink" title="SUM()函数"></a>SUM()函数</h3><p>SUM()用来返回指定列值的和（总计）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT SUM(quantity) AS items_ordered</span><br><span class="line">FROM OrderItems</span><br><span class="line">WHERE order_num = 20005;</span><br></pre></td></tr></table></figure>

<h3 id="以上5-个聚集函数都可以如下使用："><a href="#以上5-个聚集函数都可以如下使用：" class="headerlink" title="以上5 个聚集函数都可以如下使用："></a>以上5 个聚集函数都可以如下使用：</h3><p>​    1.对所有行执行计算，指定ALL 参数或不指定参数（因为ALL 是默认行为）。</p>
<p>​    2.只包含不同的值，指定DISTINCT 参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT AVG(DISTINCT prod_price) AS avg_price</span><br><span class="line">FROM Products</span><br><span class="line">WHERE vend_id = &#x27;DLL01&#x27;;</span><br></pre></td></tr></table></figure>

<p>类似地，DISTINCT 必须使用列名，不能用于计算或表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*) AS num_items,</span><br><span class="line">    MIN(prod_price) AS price_min,</span><br><span class="line">    MAX(prod_price) AS price_max,</span><br><span class="line">    AVG(prod_price) AS price_avg</span><br><span class="line">FROM Products;</span><br></pre></td></tr></table></figure>

<p>​    3.MAX/MIN函数几乎适用于所有数据类型的列。SUM/AVG函数只适用于数值类型的列。</p>
<p>​    ４.where语句中不能跟聚集函数，但是having语句中可以。</p>
<h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><h3 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h3><h3 id="TRIM"><a href="#TRIM" class="headerlink" title="TRIM()"></a>TRIM()</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_name, TRIM(vend_name) AS vend_name_trim</span><br><span class="line">FROM Vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>

<h3 id="UPPER"><a href="#UPPER" class="headerlink" title="UPPER()"></a>UPPER()</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_name, UPPER(vend_name) AS vend_name_upcase</span><br><span class="line">FROM Vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>

<img src = "/images/MySQL/MySQL03.png">

<h3 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT order_num</span><br><span class="line">FROM Orders</span><br><span class="line">WHERE YEAR(order_date) = 2012;</span><br></pre></td></tr></table></figure>

<h3 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h3><p>数值处理函数仅处理数值数据。这些函数一般主要用于代数、三角或几何运算，因此不像字符串或日期时间处理函数使用那么频繁。</p>
<img src = "/images/MySQL/MySQL04.png">

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h3 id="ROUND"><a href="#ROUND" class="headerlink" title="ROUND()"></a>ROUND()</h3><p>在mysql中，round函数用于数据的四舍五入，它有两种形式：</p>
<p>1、round(x,d)  ，x指要处理的数，d是指保留几位小数</p>
<p>这里有个值得注意的地方是，d可以是负数，这时是指定小数点左边的d位整数位为0,同时小数位均为0；</p>
<p>2、round(x)  ,其实就是round(x,0),也就是默认d为0</p>
<h3 id="LENGTH"><a href="#LENGTH" class="headerlink" title="LENGTH()"></a>LENGTH()</h3><p>返回字符串的长度。</p>
<h3 id="CAST"><a href="#CAST" class="headerlink" title="CAST()"></a>CAST()</h3><p>数据格式转换函数，将字符串转为数字，日期转为数字等。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 基础知识 06</title>
    <url>/%E5%AD%A6%E4%B9%A0/MySQL/MySQL_06/</url>
    <content><![CDATA[<p>MySQL学习笔记。对数据进行分组和进行查询。<span id="more"></span></p>
<h1 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h1><p>使用分组可以将数据分为多个逻辑组，对每个组进行聚集计算。</p>
<p>分组是使用SELECT 语句的<strong>GROUP BY</strong> 子句建立的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_id, COUNT(*) AS num_prods</span><br><span class="line">FROM Products</span><br><span class="line">GROUP BY vend_id;</span><br></pre></td></tr></table></figure>

<p>GROUP BY 子句指示DBMS 分组数据，然后对每个组而不是整个结果集进行聚集。</p>
<h2 id="GROUP-BY-子句"><a href="#GROUP-BY-子句" class="headerlink" title="GROUP BY 子句"></a>GROUP BY 子句</h2><p> 1.GROUP BY 子句可以包含任意数目的列，因而可以对分组进行嵌套，更细致地进行数据分组。</p>
<p> 2.如果在GROUP BY 子句中嵌套了分组，数据将在最后指定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</p>
<p> 3.GROUP BY 子句中列出的每一列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT 中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。</p>
<p> 4.大多数SQL 实现不允许GROUP BY 列带有长度可变的数据类型（如文本或备注型字段）。</p>
<p> 5.除聚集计算语句外，SELECT 语句中的每一列都必须在GROUP BY 子句中给出。</p>
<p> 6.如果分组列中包含具有NULL 值的行，则NULL 将作为一个分组返回。如果列中有多行NULL 值，它们将分为一组。</p>
<p> 7.GROUP BY 子句必须出现在WHERE 子句之后，ORDER BY 子句之前。</p>
<h2 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h2><p>除了能用GROUP BY 分组数据外，SQL 还允许过滤分组，规定包括哪些分组，排除哪些分组。</p>
<p>目前为止所学过的所有类型的WHERE 子句都可以用<strong>HAVING</strong> 来替代。唯一的差别是，<strong>WHERE过滤行，而HAVING 过滤分组。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_id, COUNT(*) AS orders</span><br><span class="line">FROM Orders</span><br><span class="line">GROUP BY cust_id</span><br><span class="line">HAVING COUNT(*) &gt;= 2;</span><br></pre></td></tr></table></figure>

<p>WHERE 在数据分组前进行过滤，HAVING 在数据分组后进行过滤。这是一个重要的区别，WHERE 排除的行不包括在分组中。这可能会改变计算值，从而影响HAVING 子句中基于这些值过滤掉的分组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_id, COUNT(*) AS num_prods</span><br><span class="line">FROM Products</span><br><span class="line">WHERE prod_price &gt;= 4</span><br><span class="line">GROUP BY vend_id</span><br><span class="line">HAVING COUNT(*) &gt;= 2;</span><br></pre></td></tr></table></figure>

<img src = "/images/MySQL/MySQL06.png">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT order_num, COUNT(*) AS items</span><br><span class="line">FROM OrderItems</span><br><span class="line">GROUP BY order_num</span><br><span class="line">HAVING COUNT(*) &gt;= 3;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT order_num, COUNT(*) AS items</span><br><span class="line">FROM OrderItems</span><br><span class="line">GROUP BY order_num</span><br><span class="line">HAVING COUNT(*) &gt;= 3</span><br><span class="line">ORDER BY items, order_num;</span><br></pre></td></tr></table></figure>

<h1 id="进行子查询"><a href="#进行子查询" class="headerlink" title="进行子查询"></a>进行子查询</h1><p>列出订购物品RGAN01 的所有顾客：</p>
<p>1.检索包含物品 RGAN01的所有订单编号。</p>
<p>2.检索具有前一步骤列出的顶单编号的顾客的ID。</p>
<p>3.检索前一步骤返回的所有顾客的顾客信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM Customers</span><br><span class="line">WHERE cust_id IN (SELECT cust_id</span><br><span class="line">				  FROM Orders</span><br><span class="line">				  WHERE order_num IN (SELECT order_num</span><br><span class="line">									  FROM OrderItems</span><br><span class="line">							  		  WHERE prod_id = &#x27;RGAN01&#x27;));</span><br></pre></td></tr></table></figure>

<p><strong>作为子查询的SELECT 语句只能查询单个列。企图检索多个列将返回错误。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_state,</span><br><span class="line">		(SELECT COUNT(*)</span><br><span class="line">			FROM Orders</span><br><span class="line">			WHERE Orders.cust_id = Customers.cust_id) AS orders</span><br><span class="line">FROM Customers</span><br><span class="line">ORDER BY cust_name;</span><br></pre></td></tr></table></figure>

<h1 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h1><h2 id="UNION-并集"><a href="#UNION-并集" class="headerlink" title="UNION  并集"></a>UNION  并集</h2><p>SQL 允许执行多个查询（多条SELECT 语句），并将结果作为一个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compound query）。</p>
<p>主要有两种情况需要使用组合查询：</p>
<ol>
<li>在一个查询中从不同的表返回结构数据；</li>
<li>对一个表执行多个查询，按一个查询返回数据。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_contact, cust_email</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_state IN (&#x27;IL&#x27;,&#x27;IN&#x27;,&#x27;MI&#x27;)</span><br><span class="line">UNION</span><br><span class="line">SELECT cust_name, cust_contact, cust_email</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_name = &#x27;Fun4All&#x27;;</span><br><span class="line">3. 列数据类型必须兼容：类型不必完全相同，但必须是DBMS 可以隐含</span><br><span class="line">转换的类型（例如，不同的数值类型或不同的日期类型）。</span><br></pre></td></tr></table></figure>

<p>1.UNION 必须由两条或两条以上的SELECT 语句组成，语句之间用关键字UNION 分隔（因此，如果组合四条SELECT 语句，将要使用三个UNION关键字）。<br>2.UNION 中的每个查询必须包含相同的列、表达式或聚集函数（不过，各个列不需要以相同的次序列出）。</p>
<p>3.列数据类型必须兼容：类型不必完全相同，但必须是DBMS 可以隐含转换的类型（例如，不同的数值类型或不同的日期类型）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_contact, cust_email</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_state IN (&#x27;IL&#x27;,&#x27;IN&#x27;,&#x27;MI&#x27;)</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT cust_name, cust_contact, cust_email</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_name = &#x27;Fun4All&#x27;;</span><br></pre></td></tr></table></figure>

<p>使用UNION ALL，DBMS 不取消重复的行。</p>
<p>SELECT 语句的输出用ORDER BY 子句排序。在用UNION 组合查询时，只能使用一条ORDER BY 子句，它必须位于最后一条SELECT 语句之后。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_contact, cust_email</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_state IN (&#x27;IL&#x27;,&#x27;IN&#x27;,&#x27;MI&#x27;)</span><br><span class="line">UNION</span><br><span class="line">SELECT cust_name, cust_contact, cust_email</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_name = &#x27;Fun4All&#x27;</span><br><span class="line">ORDER BY cust_name, cust_contact;</span><br></pre></td></tr></table></figure>

<h2 id="INTERSECT-交集"><a href="#INTERSECT-交集" class="headerlink" title="INTERSECT  交集"></a>INTERSECT  交集</h2><p>MySQL不支持<code>INTERSECT</code>操作符。 但是可以模拟<code>INTERSECT</code>操作符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT product_id, product_name</span><br><span class="line">    FROM Product</span><br><span class="line">INTERSECT</span><br><span class="line">SELECT product_id, product_name</span><br><span class="line">    FROM Product2</span><br><span class="line">ORDER BY product_id;</span><br></pre></td></tr></table></figure>

<h2 id="EXCEPT-减法"><a href="#EXCEPT-减法" class="headerlink" title="EXCEPT 减法"></a>EXCEPT 减法</h2><p>MYSQL不支持EXCEPT操作符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT product_id, product_name</span><br><span class="line">FROM Product</span><br><span class="line">EXCEPT</span><br><span class="line">SELECT product_id, product_name</span><br><span class="line">FROM Product2</span><br><span class="line">ORDER BY product_id;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 基础知识 07</title>
    <url>/%E5%AD%A6%E4%B9%A0/MySQL/MySQL_07/</url>
    <content><![CDATA[<p>MySQL学习笔记。 表的联结： 内联结 + 外联结。<span id="more"></span></p>
<h1 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h1><h2 id="关系表"><a href="#关系表" class="headerlink" title="关系表"></a>关系表</h2><p>相同的数据出现多次决不是一件好事，这是关系数据库设计的基础。关系表的设计就是要把信息分解成多个表，一类数据一个表。各表通过某些共同的值互相关联（所以才叫关系数据库）。</p>
<p>联结是一种机制，用来在一条SELECT 语句中关联表，因此称为联结。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price</span><br><span class="line">FROM Vendors, Products</span><br><span class="line">WHERE Vendors.vend_id = Products.vend_id;</span><br></pre></td></tr></table></figure>

<p>要保证所有联结都有WHERE 子句，否则DBMS 将返回比想要的数据多得多的数据。同理，要保证WHERE 子句的正确性。不正确的过滤条件会导致DBMS 返回不正确的数据。</p>
<h2 id="内联结"><a href="#内联结" class="headerlink" title="内联结"></a>内联结</h2><p>目前为止使用的联结称为等值联结（equijoin），它基于两个表之间的相等测试。这种联结也称为内联结（inner join）。可以对这种联结使用稍微不同的语法，明确指定联结的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price</span><br><span class="line">FROM Vendors INNER JOIN Products</span><br><span class="line">ON Vendors.vend_id = Products.vend_id;</span><br></pre></td></tr></table></figure>

<p>这里，两个表之间的关系是以INNER JOIN 指定的部分FROM 子句。在使用这种语法时，联结条件用特定的ON 子句而不是WHERE 子句给出。传递给ON 的实际条件与传递给WHERE 的相同。</p>
<p>SQL 不限制一条SELECT 语句中可以联结的表的数目。创建联结的基本规则也相同。首先列出所有表，然后定义表之间的关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, vend_name, prod_price, quantity</span><br><span class="line">FROM OrderItems, Products, Vendors</span><br><span class="line">WHERE Products.vend_id = Vendors.vend_id</span><br><span class="line">AND OrderItems.prod_id = Products.prod_id</span><br><span class="line">AND order_num = 20007;</span><br></pre></td></tr></table></figure>

<p>select子语句可用联结来代替。但具体的性能需要结合数据库进行考虑。</p>
<h3 id="使用带聚集函数的联结"><a href="#使用带聚集函数的联结" class="headerlink" title="使用带聚集函数的联结"></a>使用带聚集函数的联结</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT Customers.cust_id,</span><br><span class="line">COUNT(Orders.order_num) AS num_ord</span><br><span class="line">FROM Customers INNER JOIN Orders</span><br><span class="line">ON Customers.cust_id = Orders.cust_id</span><br><span class="line">GROUP BY Customers.cust_id;</span><br></pre></td></tr></table></figure>

<img src = "/images/MySQL/MySQL07.jpg">

<h2 id="交叉联结"><a href="#交叉联结" class="headerlink" title="交叉联结"></a>交叉联结</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT SP.shop_id, SP.shop_name, SP.product_id, P.product_name</span><br><span class="line">FROM ShopProduct AS SP CROSS JOIN Product AS P;</span><br></pre></td></tr></table></figure>

<p>满足笛卡尔积。</p>
<h2 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT c1.cust_id, c1.cust_name, c1.cust_contact</span><br><span class="line">FROM Customers AS c1, Customers AS c2</span><br><span class="line">WHERE c1.cust_name = c2.cust_name</span><br><span class="line">AND c2.cust_contact = &#x27;Jim Jones&#x27;;</span><br></pre></td></tr></table></figure>

<p>自联结的效率一般比子查询要高。</p>
<h2 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h2><p>无论何时对表进行联结，应该至少有一列不止出现在一个表中（被联结的列）。标准的联结（内联结）返回所有数据，相同的列甚至多次出现。自然联结排除多次出现，使每一列只返回一次。</p>
<p>自然联结要求你只能选择那些唯一的列，一般通过对一个表使用通配符（SELECT *），而对其他表的列使用明确的子集来完成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT C.*, O.order_num, O.order_date,</span><br><span class="line">OI.prod_id, OI.quantity, OI.item_price</span><br><span class="line">FROM Customers AS C, Orders AS O, OrderItems AS OI</span><br><span class="line">WHERE C.cust_id = O.cust_id</span><br><span class="line">AND OI.order_num = O.order_num</span><br><span class="line">AND prod_id = &#x27;RGAN01&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="外联结"><a href="#外联结" class="headerlink" title="外联结"></a>外联结</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT Customers.cust_id, Orders.order_num</span><br><span class="line">FROM Customers LEFT OUTER JOIN Orders</span><br><span class="line">ON Customers.cust_id = Orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>在使用OUTERJOIN 语法时，必须使用RIGHT 或LEFT 关键字指定包括其所有行的表（RIGHT 指出的是OUTER JOIN 右边的表，而LEFT 指出的是OUTER JOIN左边的表）。</p>
<h3 id="三个表的联结"><a href="#三个表的联结" class="headerlink" title="三个表的联结"></a>三个表的联结</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sp.shop_id, sp.shop_name, sp.product_id, p.product_name, p.sale_price, ip.inventory_quantity</span><br><span class="line">from shopproduct as sp </span><br><span class="line">    inner join product as p on sp.product_id = p.product_id</span><br><span class="line">    inner join inventoryProduct as ip on sp.product_id = ip.product_id</span><br><span class="line">where ip.inventory_id = &#x27;P001&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 基础知识 08</title>
    <url>/%E5%AD%A6%E4%B9%A0/MySQL/MySQL_08/</url>
    <content><![CDATA[<p>MySQL学习笔记。使用视图可以提高检索效率，保存select语句。利用存储过程可以批量的使用一系列SQL语句。<span id="more"></span></p>
<h1 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h1><p>视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</p>
<h2 id="视图的一些常见应用"><a href="#视图的一些常见应用" class="headerlink" title="视图的一些常见应用"></a>视图的一些常见应用</h2><p> 1.重用SQL 语句。</p>
<p> 2.简化复杂的SQL 操作。在编写查询后，可以方便地重用它而不必知道其基本查询细节。</p>
<p> 3.使用表的一部分而不是整个表。</p>
<p> 4.保护数据。可以授予用户访问表的特定部分的权限，而不是整个表的访问权限。</p>
<p> 5.更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时需要的所有检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，性能可能会下降得很厉害。</p>
<h2 id="常见的规则和限制"><a href="#常见的规则和限制" class="headerlink" title="常见的规则和限制"></a>常见的规则和限制</h2><p> 1.与表一样，视图必须唯一命名。对于可以创建的视图数目没有限制。</p>
<p> 2.视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造视图。所允许的嵌套层数在不同的DBMS 中有所不同（嵌套视图可能会严重降低查询的性能，因此在产品环境中使用之前，应该对其进行全面测试）。</p>
<p> 3.许多DBMS 禁止在视图查询中使用ORDER BY 子句。</p>
<p> 4.有些DBMS 要求对返回的所有列进行命名，如果列是计算字段，则需要使用别名。</p>
<p> 5.视图不能索引，也不能有关联的触发器或默认值。</p>
<h2 id="创建-删除-视图"><a href="#创建-删除-视图" class="headerlink" title="创建/删除 视图"></a>创建/删除 视图</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建视图 </span><br><span class="line">create view viewName</span><br><span class="line">as  &lt;select 语句&gt; ;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 删除视图 </span><br><span class="line">drop view viewName;</span><br></pre></td></tr></table></figure>

<h3 id="创建一个视图"><a href="#创建一个视图" class="headerlink" title="创建一个视图"></a>创建一个视图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW pro_cus AS</span><br><span class="line">SELECT cust_name, cust_contact, prod_id</span><br><span class="line">FROM Customers, Orders, OrderItems</span><br><span class="line">WHERE Customers.cust_id = Orders.cust_id</span><br><span class="line">AND OrderItems.order_num = Orders.order_num;</span><br></pre></td></tr></table></figure>

<p>查看表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br><span class="line">+--------------+</span><br><span class="line">| Tables_in_wz |</span><br><span class="line">+--------------+</span><br><span class="line">| customers    |</span><br><span class="line">| orderitems   |</span><br><span class="line">| orders       |</span><br><span class="line">| pro_cus      |</span><br><span class="line">| products     |</span><br><span class="line">| vendors      |</span><br><span class="line">+--------------+</span><br><span class="line">6 rows in set (0.03 sec)</span><br></pre></td></tr></table></figure>

<h2 id="利用视图检索数据"><a href="#利用视图检索数据" class="headerlink" title="利用视图检索数据"></a>利用视图检索数据</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM pro_cus</span><br><span class="line">WHERE prod_id = &#x27;RGAN01&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="用视图重新格式化检索出的数据"><a href="#用视图重新格式化检索出的数据" class="headerlink" title="用视图重新格式化检索出的数据"></a>用视图重新格式化检索出的数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW Ven_loc AS</span><br><span class="line">SELECT concat(RTRIM(vend_name),&#x27;(&#x27;, RTRIM(vend_country) ,&#x27;)&#x27;)</span><br><span class="line">as ventitle</span><br><span class="line">from vendors;</span><br><span class="line"></span><br><span class="line"> select * from ven_loc;</span><br></pre></td></tr></table></figure>

<h3 id="用视图过滤不想要的数据"><a href="#用视图过滤不想要的数据" class="headerlink" title="用视图过滤不想要的数据"></a>用视图过滤不想要的数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW CustomerEMailList AS</span><br><span class="line">SELECT cust_id, cust_name, cust_email</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_email IS NOT NULL;</span><br></pre></td></tr></table></figure>

<p>从视图检索数据时如果使用了一条WHERE 子句，则两组子句（一组在视图中，另一组是传递给视图的）将自动组合。</p>
<h3 id="使用视图与计算字段"><a href="#使用视图与计算字段" class="headerlink" title="使用视图与计算字段"></a>使用视图与计算字段</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW OrderItemsExpanded AS</span><br><span class="line">    SELECT order_num,</span><br><span class="line">    prod_id,</span><br><span class="line">    quantity,</span><br><span class="line">    item_price,</span><br><span class="line">	quantity*item_price AS expanded_price</span><br><span class="line">FROM OrderItems;</span><br></pre></td></tr></table></figure>

<p>视图为虚拟的表。它们包含的不是数据而是根据需要检索数据的查询。视图提供了一种封装SELECT 语句的层次，可用来简化数据处理，重新格式化或保护基础数据。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>1.使用视图时不要使用 order by， 因为视图和表一样，数据行都是没有顺序的。</p>
<p>2.标准SQL 中有这样的规定：如果定义视图的SELECT 语句能够满足某些条件，那么这个视图就可以被更新。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.SELECT 子句中未使用DISTINCT</span><br><span class="line">2.FROM 子句中只有一张表</span><br><span class="line">3.未使用GROUP BY 子句</span><br><span class="line">4.未使用HAVING 子句</span><br></pre></td></tr></table></figure>

<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>存储过程就是为以后使用而保存的一条 或多条SQL 语句。可将其视为批文件，虽然它们的作用不仅限于批处理。</p>
<h2 id="存储过程的执行"><a href="#存储过程的执行" class="headerlink" title="存储过程的执行"></a>存储过程的执行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXECUTE AddNewProduct( &#x27;JTS01&#x27;,</span><br><span class="line">    &#x27;Stuffed Eiffel Tower&#x27;,</span><br><span class="line">    6.49,</span><br><span class="line">    &#x27;Plush stuffed toy with the text La</span><br><span class="line">    Tour Eiffel in red white and blue&#x27; );</span><br></pre></td></tr></table></figure>

<p>对于具体的DBMS，可能包括以下的执行选择：<br>1.参数可选，具有不提供参数时的默认值；<br>2.不按次序给出参数，以“参数=值”的方式给出参数值。<br>3.输出参数，允许存储过程在正执行的应用程序中更新所用的参数。<br>4.用SELECT 语句检索数据。<br>5.返回代码，允许存储过程返回一个值到正在执行的应用程序。</p>
<h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><p>Oracle ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE MailingListCount (</span><br><span class="line">	ListCount OUT INTEGER</span><br><span class="line">)</span><br><span class="line">IS</span><br><span class="line">v_rows INTEGER;</span><br><span class="line">BEGIN</span><br><span class="line">    SELECT COUNT(*) INTO v_rows</span><br><span class="line">    FROM Customers</span><br><span class="line">    WHERE NOT cust_email IS NULL;</span><br><span class="line">    ListCount := v_rows;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>这个存储过程有一个名为ListCount 的参数。此参数从存储过程返回一个值而不是传递一个值给存储过程。关键字OUT 用来指示这种行为。Oracle 支持IN（传递值给存储过程）、OUT（从存储过程返回值，如这里）、INOUT（既传递值给存储过程也从存储过程传回值）类型的参数。存储过程的代码括在BEGIN 和END 语句中，这里执行一条简单的SELECT 语句，它检索具有邮件地址的顾客。然后用检索出的行数设置ListCount（要传递的输出参数）。</p>
<p>调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var ReturnValue NUMBER</span><br><span class="line">EXEC MailingListCount(:ReturnValue);</span><br><span class="line">SELECT ReturnValue;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 基础知识 09</title>
    <url>/%E5%AD%A6%E4%B9%A0/MySQL/MySQL_09/</url>
    <content><![CDATA[<p>MySQL学习笔记。使用事务避免仅执行了部分语句。<span id="more"></span></p>
<h1 id="管理事务"><a href="#管理事务" class="headerlink" title="管理事务"></a>管理事务</h1><p>使用事务处理（transaction processing），通过确保成批的SQL 操作要么完全执行，要么完全不执行，来维护数据库的完整性。</p>
<p>事务处理是一种机制，用来管理必须成批执行的SQL 操作，保证数据库不包含不完整的操作结果。利用事务处理，可以保证一组操作不会中途停止，它们要么完全执行，要么完全不执行（除非明确指示）。如果没有错误发生，整组语句提交给（写到）数据库表；如果发生错误，则进行回退（撤销），将数据库恢复到某个已知且安全的状态。</p>
<h2 id="事务（transaction）"><a href="#事务（transaction）" class="headerlink" title="事务（transaction）"></a>事务（transaction）</h2><p>指一组SQL 语句；</p>
<h2 id="回退（rollback）"><a href="#回退（rollback）" class="headerlink" title="回退（rollback）"></a>回退（rollback）</h2><p>指撤销指定SQL 语句的过程；</p>
<h2 id="提交（commit）"><a href="#提交（commit）" class="headerlink" title="提交（commit）"></a>提交（commit）</h2><p>指将未存储的SQL 语句结果写入数据库表；</p>
<h2 id="保留点（savepoint）"><a href="#保留点（savepoint）" class="headerlink" title="保留点（savepoint）"></a>保留点（savepoint）</h2><p>指事务处理中设置的临时占位符（placeholder），可以对它发布回退（与回退整个事务处理不同）。</p>
<p>事务处理用来管理INSERT、UPDATE 和DELETE 语句。不能回退SELECT语句（回退SELECT 语句也没有必要），也不能回退CREATE 或DROP 操作。事务处理中可以使用这些语句，但进行回退时，这些操作也不撤销。</p>
<p>管理事务的关键在于将SQL 语句组分解为逻辑块，并明确规定数据何时应该回退，何时不应该回退。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="ROLLBACK"><a href="#ROLLBACK" class="headerlink" title="ROLLBACK"></a>ROLLBACK</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM Orders;</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>

<h3 id="COMMIT"><a href="#COMMIT" class="headerlink" title="COMMIT"></a>COMMIT</h3><p>一般的SQL 语句都是针对数据库表直接执行和编写的。这就是所谓的隐式提交（implicit commit），即提交（写或保存）操作是自动进行的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION</span><br><span class="line">DELETE OrderItems WHERE order_num = 12345</span><br><span class="line">DELETE Orders WHERE order_num = 12345</span><br><span class="line">COMMIT TRANSACTION</span><br></pre></td></tr></table></figure>

<h2 id="使用保留点"><a href="#使用保留点" class="headerlink" title="使用保留点"></a>使用保留点</h2><p>使用简单的ROLLBACK 和COMMIT 语句，就可以写入或撤销整个事务。但是，只对简单的事务才能这样做，复杂的事务可能需要部分提交或回退。</p>
<p>要支持回退部分事务，必须在事务处理块中的合适位置放置占位符。这样，如果需要回退，可以回退到某个占位符。</p>
<p>在SQL 中，这些占位符称为保留点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAVEPOINT delete1;</span><br></pre></td></tr></table></figure>

<p>每个保留点都要取能够标识它的唯一名字，以便在回退时，DBMS 知道回退到何处。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROLLBACK TO delete1;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start TRANSACTION</span><br><span class="line">INSERT INTO Customers(cust_id, cust_name)</span><br><span class="line">VALUES(&#x27;1000000010&#x27;, &#x27;Toys Emporium&#x27;);</span><br><span class="line">SAVE TRANSACTION StartOrder;</span><br><span class="line">INSERT INTO Orders(order_num, order_date, cust_id)</span><br><span class="line">VALUES(20100,&#x27;2001/12/1&#x27;,&#x27;1000000010&#x27;);</span><br><span class="line">IF @@ERROR &lt;&gt; 0 ROLLBACK TRANSACTION StartOrder;</span><br><span class="line">INSERT INTO OrderItems(order_num, order_item, prod_id, quantity,</span><br><span class="line">➥item_price)</span><br><span class="line">VALUES(20100, 1, &#x27;BR01&#x27;, 100, 5.49);</span><br><span class="line">IF @@ERROR &lt;&gt; 0 ROLLBACK TRANSACTION StartOrder;</span><br><span class="line">INSERT INTO OrderItems(order_num, order_item, prod_id, quantity,</span><br><span class="line">➥item_price)</span><br><span class="line">VALUES(20100, 2, &#x27;BR03&#x27;, 100, 10.99);</span><br><span class="line">IF @@ERROR &lt;&gt; 0 ROLLBACK TRANSACTION StartOrder;</span><br><span class="line">COMMIT TRANSACTION</span><br></pre></td></tr></table></figure>

<h1 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h1><p>SQL 检索操作返回一组称为结果集的行，这组返回的行都是与SQL 语句相匹配的行（零行或多行）。简单地使用SELECT 语句，没有办法得到第一行、下一行或前10 行。但这是关系DBMS 功能的组成部分。</p>
<p>有时，需要在检索出来的行中前进或后退一行或多行，这就是游标的用途所在。</p>
<p>游标（cursor）是一个存储在DBMS 服务器上的数据库查询，它不是一条SELECT 语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。</p>
<h2 id="选项和特性"><a href="#选项和特性" class="headerlink" title="选项和特性"></a>选项和特性</h2><p>1.能够标记游标为只读，使数据能读取，但不能更新和删除。<br>2.能控制可以执行的定向操作（向前、向后、第一、最后、绝对位置、相对位置等）。<br>3.能标记某些列为可编辑的，某些列为不可编辑的。<br>4.规定范围，使游标对创建它的特定请求（如存储过程）或对所有请求可访问。<br>5.指示DBMS 对检索出的数据（而不是指出表中活动数据）进行复制，使数据在游标打开和访问期间不变化。</p>
<p>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</p>
<h2 id="游标的使用步骤"><a href="#游标的使用步骤" class="headerlink" title="游标的使用步骤"></a>游标的使用步骤</h2><p>1.在使用游标前，必须声明（定义）它。这个过程实际上没有检索数据，它只是定义要使用的SELECT 语句和游标选项。<br>2.一旦声明，就必须打开游标以供使用。这个过程用前面定义的SELECT语句把数据实际检索出来。<br>3.对于填有数据的游标，根据需要取出（检索）各行。<br>4.在结束游标使用时，必须关闭游标，可能的话，释放游标（有赖于具体的DBMS）。</p>
<p>5.声明游标后，可根据需要频繁地打开和关闭游标。在游标打开时，可根据需要频繁地执行取操作</p>
<h3 id="创建游标"><a href="#创建游标" class="headerlink" title="创建游标"></a>创建游标</h3><p>DECLARE 命名游标，并定义相应的SELECT 语句，根据需要带WHERE 和其他子句。<br><strong>游标只能用在存储过程中</strong></p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE CustCursor CURSOR</span><br><span class="line">FOR</span><br><span class="line">SELECT * FROM Customers</span><br><span class="line">WHERE cust_email IS NULL</span><br></pre></td></tr></table></figure>

<h3 id="打开游标"><a href="#打开游标" class="headerlink" title="打开游标"></a>打开游标</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPEN CURSOR CustCursor</span><br></pre></td></tr></table></figure>

<p>用FETCH 语句访问游标数据。FETCH 指出要检索哪些行，从何处检索它们以及将它们放于何处（如变量名）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE TYPE CustCursor IS REF CURSOR</span><br><span class="line">	RETURN Customers%ROWTYPE;</span><br><span class="line">DECLARE CustRecord Customers%ROWTYPE</span><br><span class="line">BEGIN</span><br><span class="line">OPEN CustCursor;</span><br><span class="line">FETCH CustCursor INTO CustRecord;</span><br><span class="line">CLOSE CustCursor;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<h3 id="关闭游标"><a href="#关闭游标" class="headerlink" title="关闭游标"></a>关闭游标</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLOSE CustCursor</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV-Tutorials</title>
    <url>/%E5%AD%A6%E4%B9%A0/OpenCV/openCVtutorials/</url>
    <content><![CDATA[<h2 id="OpenCV官网例程实现"><a href="#OpenCV官网例程实现" class="headerlink" title="OpenCV官网例程实现"></a>OpenCV官网例程实现</h2><p>OpenCV官网提供了一系列例程，先照着实现一下，同时记录遇到的一些问题。</p>
<span id="more"></span>

<h3 id="CV与Matplotlib的颜色冲突"><a href="#CV与Matplotlib的颜色冲突" class="headerlink" title="CV与Matplotlib的颜色冲突"></a>CV与Matplotlib的颜色冲突</h3><p> OpenCV中读取彩图的颜色是以BGR来排序的，而Matplotlib中图片是以RGB排序的，因此如果想要使用pyplot来展示图片，就需要对图片的颜色域顺序进行处理，不过实现起来也很方便。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv.imread(<span class="string">&quot;o1.png&quot;</span>)</span><br><span class="line">img = img[:,:,::-<span class="number">1</span>]</span><br><span class="line">plt.show(<span class="string">&quot;Image&quot;</span>,img)</span><br></pre></td></tr></table></figure>

<h3 id="使用拉普拉斯算子获取图像边缘"><a href="#使用拉普拉斯算子获取图像边缘" class="headerlink" title="使用拉普拉斯算子获取图像边缘"></a>使用拉普拉斯算子获取图像边缘</h3><p>以下是示例和我按照示例的到的结果：</p>
<p>官方示例：</p>
<img src="/images/OpenCV/openCV_01.png">

<p>我的结果：</p>
<img src="/images/OpenCV/openCV_02.png">

<p>可以看出并没有得到示例中所展示的效果。</p>
<p>查看函数参数说明，可以看到有一项参数为：</p>
<p><strong>CV_<bit_depth>(S|U|F)C<number_of_channels></strong></p>
<p>说明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bit_depth：比特数---代表8bite,16bites,32bites,64bites...</span><br><span class="line"></span><br><span class="line">如果你现在创建了一个存储--灰度图片的Mat对象,这个图像的大小为宽100,高100,那么,现在这张灰度图片中有10000个像素点，它每一个像素点在内存空间所占的空间大小是8bite,8位--所以它对应的就是CV_8。</span><br><span class="line">-------------</span><br><span class="line"></span><br><span class="line">S|U|F:</span><br><span class="line"></span><br><span class="line">S--代表---signed int---有符号整形</span><br><span class="line"></span><br><span class="line">U--代表--unsigned int--无符号整形</span><br><span class="line"></span><br><span class="line">F--代表--float---------单精度浮点型</span><br><span class="line"></span><br><span class="line">---------</span><br><span class="line"></span><br><span class="line">C&lt;number_of_channels&gt;----代表---一张图片的通道数,比如:</span><br><span class="line"></span><br><span class="line">channels = 1：灰度图片--grayImg---是--单通道图像</span><br><span class="line"></span><br><span class="line">channels = 3：RGB彩色图像---------是--3通道图像</span><br><span class="line"></span><br><span class="line">channels = 4：带Alph通道的RGB图像--是--4通道图像</span><br><span class="line">————————————————</span><br></pre></td></tr></table></figure>

<p>修改参数为CV_8U后，调整内核大小，得到预期结果。</p>
<h3 id="绘制轮廓"><a href="#绘制轮廓" class="headerlink" title="绘制轮廓"></a>绘制轮廓</h3><p>看函数说明时，需要使用二值图片才能更好的识别轮廓。所以我就直接选择了使用二值图片去查找轮廓。但是再绘制轮廓时发现无法绘制轮廓，观察函数发现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv2.drawContours(image, contours, contourIdx, color, thickness=None, lineType=None, hierarchy=None, maxLevel=None, offset=None)</span><br></pre></td></tr></table></figure>

<p>其中要求image类型为彩色图片。所以就需要使用彩色图片从BGR-&gt;GRAY,在进行阈值化处理变为二值图片识别轮廓，最后再原图上画图。</p>
<h3 id="多对象模板匹配"><a href="#多对象模板匹配" class="headerlink" title="多对象模板匹配"></a>多对象模板匹配</h3><p>源代码见github仓库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#函数：cv.matchTemplate(), cv.minMaxLoc()</span><br><span class="line">import numpy as np</span><br><span class="line">import cv2 as cv </span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line">img7 = cv.imread(&quot;../Images/img7.jpg&quot;)</span><br><span class="line">img7 = cv.cvtColor(img7, cv.COLOR_BGR2GRAY)</span><br><span class="line">target = img7.copy()</span><br><span class="line">template = cv.imread(&quot;../Images/img7_1.png&quot;)</span><br><span class="line">template = cv.cvtColor(template, cv.COLOR_BGR2GRAY)</span><br><span class="line">w, h = template.shape[::-1]</span><br><span class="line">#列表中所有的6种比较方法</span><br><span class="line">methods = [&#x27;cv.TM_CCOEFF&#x27;, &#x27;cv.TM_CCOEFF_NORMED&#x27;, &#x27;cv.TM_CCORR&#x27;,</span><br><span class="line">            &#x27;cv.TM_CCORR_NORMED&#x27;, &#x27;cv.TM_SQDIFF&#x27;, &#x27;cv.TM_SQDIFF_NORMED&#x27;]</span><br><span class="line">for meth in methods:</span><br><span class="line">    img7 = target.copy()</span><br><span class="line">    method = eval(meth)</span><br><span class="line">    # 应用模板匹配</span><br><span class="line">    res = cv.matchTemplate(img7,template,method)</span><br><span class="line">    min_val, max_val, min_loc, max_loc = cv.minMaxLoc(res)</span><br><span class="line">    # 如果方法是TM_SQDIFF或TM_SQDIFF_NORMED，则取最小值</span><br><span class="line">    if method in [cv.TM_SQDIFF, cv.TM_SQDIFF_NORMED]:</span><br><span class="line">        top_left = min_loc</span><br><span class="line">    else:</span><br><span class="line">        top_left = max_loc</span><br><span class="line">    bottom_right = (top_left[0] + w, top_left[1] + h)</span><br><span class="line">    cv.rectangle(img7,top_left, bottom_right, 255, 2)</span><br><span class="line">    plt.subplot(121),plt.imshow(res,cmap = &#x27;gray&#x27;)</span><br><span class="line">    plt.title(&#x27;Matching Result&#x27;), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(122),plt.imshow(img7,cmap = &#x27;gray&#x27;)</span><br><span class="line">    plt.title(&#x27;Detected Point&#x27;), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.suptitle(meth)</span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line">#多对象匹配</span><br><span class="line">img22 = cv.imread(&quot;../Images/img22.png&quot;)</span><br><span class="line">img22_gray = cv.cvtColor(img22, cv.COLOR_BGR2GRAY)</span><br><span class="line">#plt.imshow(img22_gray,&#x27;gray&#x27;)</span><br><span class="line">#plt.show()</span><br><span class="line">template = cv.imread(&#x27;../Images/img22_1.png&#x27;)</span><br><span class="line">template_gray = cv.cvtColor(template, cv.COLOR_BGR2GRAY)</span><br><span class="line">#plt.imshow(template_gray,&#x27;gray&#x27;)</span><br><span class="line">#plt.show()</span><br><span class="line">w, h = template_gray.shape[:: -1]</span><br><span class="line">print(w,h)</span><br><span class="line">res = cv.matchTemplate(img22_gray, template_gray, cv.TM_CCOEFF_NORMED)</span><br><span class="line">threshold = 0.55</span><br><span class="line">loc = np.where( res &gt;= threshold)</span><br><span class="line">for pt in zip(*loc[::-1]):</span><br><span class="line">    cv.rectangle(img22, pt, (pt[0] + w , pt[1]+ h), (0,255,255), 2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">cv.imshow(&quot;image&quot;,img22 )</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">img22 = img22[:, :, :: -1]</span><br><span class="line">plt.imshow(img22)</span><br><span class="line">plt.show()</span><br><span class="line">#错误原因分析：因为匹配时采用灰度图像，所以水管被匹配到了</span><br></pre></td></tr></table></figure>

<p>遇到的问题：</p>
<p>​    刚开始绘制正方形时，整个图片全部变为黄色，后来意识到是因为阈值太低和匹配模式选择的问题。通过调整匹配模式和阈值，能大致匹配到合适位置，但由于匹配时采用的是灰度图片，所以水管口依旧被匹配到了，还需要进一步改进。</p>
<h3 id="图片绘制形状"><a href="#图片绘制形状" class="headerlink" title="图片绘制形状"></a>图片绘制形状</h3><p>由于OpenCV读取的图片以BGR格式存储，如果想用plot绘图就需要用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">img = img[:, :, :: -1]</span><br></pre></td></tr></table></figure>

<p>但是如果想要在图形上绘图就不能先转变将图片变为RGB格式，否则无法绘制矩形等形状且不报错。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 基础知识 10</title>
    <url>/%E5%AD%A6%E4%B9%A0/MySQL/MySQL_10/</url>
    <content><![CDATA[<p>MySQL学习笔记。SQL的一些特性和其他功能。<span id="more"></span></p>
<h1 id="MySQL的一些特性和高级功能"><a href="#MySQL的一些特性和高级功能" class="headerlink" title="MySQL的一些特性和高级功能"></a>MySQL的一些特性和高级功能</h1><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>主键是一种特殊的约束，用来保证一列（或一组列）中的值是唯一的，而且永不改动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Vendors</span><br><span class="line">(</span><br><span class="line">    vend_id CHAR(10) NOT NULL PRIMARY KEY,</span><br><span class="line">    vend_name CHAR(50) NOT NULL,</span><br><span class="line">    vend_address CHAR(50) NULL,</span><br><span class="line">    vend_city CHAR(50) NULL,</span><br><span class="line">    vend_state CHAR(5) NULL,</span><br><span class="line">    vend_zip CHAR(10) NULL,</span><br><span class="line">    vend_country CHAR(50) NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Vendors</span><br><span class="line">ADD CONSTRAINT PRIMARY KEY (vend_id);</span><br></pre></td></tr></table></figure>

<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>外键是表中的一列，其值必须列在另一表的主键中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Orders</span><br><span class="line">(</span><br><span class="line">order_num INTEGER NOT NULL PRIMARY KEY,</span><br><span class="line">order_date DATETIME NOT NULL,</span><br><span class="line">cust_id CHAR(10) NOT NULL REFERENCES Customers(cust_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Orders</span><br><span class="line">ADD CONSTRAINT</span><br><span class="line">FOREIGN KEY (cust_id) REFERENCES Customers (cust_id)</span><br></pre></td></tr></table></figure>

<p>帮助保证引用完整性外，外键还有另一个重要作用。在定义外键后，DBMS 不允许删除在另一个表中具有关联行的行。例如，不能删除关联订单的顾客。删除该顾客的唯一方法是首先删除相关的订单（这表示还要删除相关的订单项）。由于需要一系列的删除，因而利用外键可以防止意外删除数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//s</span><br><span class="line">alter table orders drop foreign key FK_Orders_Customers;</span><br></pre></td></tr></table></figure>

<h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><p>唯一约束用来保证一列（或一组列）中的数据是唯一的。它们类似于主=键，但存在以下重要区别。</p>
<p>1.表可包含多个唯一约束，但每个表只允许一个主键。<br>2.唯一约束列可包含NULL 值。<br>3.唯一约束列可修改或更新。<br>4.唯一约束列的值可重复使用。<br>5.与主键不一样，唯一约束不能用来定义外键。</p>
<p>唯一约束的语法类似于其他约束的语法。唯一约束既可以用UNIQUE 关键字在表定义中定义，也可以用单独的CONSTRAINT 定义。</p>
<h3 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h3><p>检查约束用来保证一列（或一组列）中的数据满足一组指定的条件。</p>
<p>检查约束的常见用途有以下几点。<br>1.检查最小或最大值。例如，防止0 个物品的订单（即使0 是合法的数）。</p>
<p>2.指定范围。例如，保证发货日期大于等于今天的日期，但不超过今天起一年后的日期。</p>
<p>3.只允许特定的值。例如，在性别字段中只允许M 或F。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE OrderItems</span><br><span class="line">(</span><br><span class="line">    order_num INTEGER NOT NULL,</span><br><span class="line">    order_item INTEGER NOT NULL,</span><br><span class="line">    prod_id CHAR(10) NOT NULL,</span><br><span class="line">    quantity INTEGER NOT NULL CHECK (quantity &gt; 0),</span><br><span class="line">    item_price MONEY NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table table_name</span><br><span class="line">ADD CONSTRAINT CHECK (gender LIKE &#x27;[MF]&#x27;)</span><br></pre></td></tr></table></figure>

<p>有的DBMS 允许用户定义自己的数据类型。它们是定义检查约束（或其他约束）的基本简单数据类型。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引用来排序数据以加快搜索和排序操作的速度。</p>
<p>可以在一个或多个列上定义索引，使DBMS 保存其内容的一个排过序的列表。在定义了索引后，DBMS 以使用书的索引类似的方法使用它。DBMS 搜索排过序的索引，找出匹配的位置，然后检索这些行。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>1.索引数据可能要占用大量的存储空间。</p>
<p>2.并非所有数据都适合做索引。取值不多的数据（如州）不如具有更多可能值的数据（如姓或名），能通过索引得到那么多的好处。</p>
<p>3.索引改善检索操作的性能，但降低了数据插入、修改和删除的性能。在执行这些操作时，DBMS 必须动态地更新索引。</p>
<p>4.索引用于数据过滤和数据排序。如果你经常以某种特定的顺序排序数据，则该数据可能适合做索引。</p>
<p>5.可以在索引中定义多个列（例如，州加上城市）。这样的索引仅在以州加城市的顺序排序时有用。如果想按城市排序，则这种索引没有用处。</p>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX prod_name_ind</span><br><span class="line">ON Products (prod_name);</span><br></pre></td></tr></table></figure>

<h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show index from products;</span><br></pre></td></tr></table></figure>

<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX  prod_name_ind  ON products;</span><br></pre></td></tr></table></figure>

<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是特殊的存储过程，它在特定的数据库活动发生时自动执行。触发器可以与特定表上的INSERT、UPDATE 和DELETE 操作（或组合）相关联。</p>
<p>触发器内的代码具有以下数据的访问权：<br>1.INSERT 操作中的所有新数据；<br>2.UPDATE 操作中的所有新数据和旧数据；<br>3.DELETE 操作中删除的数据。</p>
<h3 id="常见用途。"><a href="#常见用途。" class="headerlink" title="常见用途。"></a>常见用途。</h3><p>1.保证数据一致。</p>
<p>2.基于某个表的变动在其他表上执行活动。</p>
<p>3.进行额外的验证并根据需要回退数据。</p>
<p>4.计算计算列的值或更新时间戳。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create trigger triggerName  </span><br><span class="line">after/before insert/update/delete on 表名  </span><br><span class="line">for each row   #这句话在mysql是固定的  </span><br><span class="line">begin  </span><br><span class="line">    sql语句;  </span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<p>一般来说，约束的处理比触发器快，因此在可能的时候，应该尽量使用约束。</p>
<h2 id="数据库安全"><a href="#数据库安全" class="headerlink" title="数据库安全"></a>数据库安全</h2><p>一般说来，需要保护的操作有：<br>1.对数据库管理功能（创建表、更改或删除已存在的表等）的访问；<br>2.对特定数据库或表的访问；<br>3.访问的类型（只读、对特定列的访问等）；<br>4.仅通过视图或存储过程对表进行访问；<br>5.创建多层次的安全措施，从而允许多种基于登录的访问和控制；<br>6.限制管理用户账号的能力。</p>
<p>安全性使用SQL 的GRANT 和REVOKE 语句来管理。</p>
<h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;窗口函数&gt; OVER ([PARTITION BY &lt;列清单&gt;]</span><br><span class="line">	ORDER BY &lt;排序用列清单&gt;)</span><br></pre></td></tr></table></figure>

<h3 id="窗口函数大体可以分为以下两种"><a href="#窗口函数大体可以分为以下两种" class="headerlink" title="窗口函数大体可以分为以下两种"></a>窗口函数大体可以分为以下两种</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.能够作为窗口函数的聚合函数（SUM、AVG、COUNT、MAX、MIN）</span><br><span class="line">2.RANK、DENSE_RANK、ROW_NUMBER 等专用窗口函数</span><br></pre></td></tr></table></figure>

<h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><p>原则上窗口函数只能在SELECT子句中使用。</p>
<h3 id="窗口函数：RANK"><a href="#窗口函数：RANK" class="headerlink" title="窗口函数：RANK( )"></a>窗口函数：RANK( )</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT product_name, product_type, sale_price,</span><br><span class="line">    RANK () OVER (PARTITION BY product_type ORDER BY sale_price) AS ranking</span><br><span class="line">FROM Product;</span><br></pre></td></tr></table></figure>

<p>PARTITION BY 在横向上对表进行分组，而ORDER BY决定了纵向排序的规则。</p>
<h3 id="窗口函数兼具分组和排序两种功能。"><a href="#窗口函数兼具分组和排序两种功能。" class="headerlink" title="窗口函数兼具分组和排序两种功能。"></a>窗口函数兼具分组和排序两种功能。</h3><p>1.窗口函数兼具之前我们学过的GROUP BY 子句的分组功能以及ORDER BY 子句的排序功能。但是，PARTITION BY 子句并不具备GROUP BY 子句的汇总功能。因此，使用RANK 函数并不会减少原表中记录的行数，结果中仍然包含8 行数据。</p>
<p>2.使用窗口函数时起到关键作用的是PARTITION BY 和GROUP BY。其中，PARTITION BY 并不是必需的，即使不指定也可以正常使用窗口函数。</p>
<p>3.OVER 子句中的ORDER BY 只是用来决定窗口函数按照什么样的顺序进行计算的，对结果的排列顺序并没有影响。</p>
<h3 id="RANK函数"><a href="#RANK函数" class="headerlink" title="RANK函数"></a>RANK函数</h3><p>计算排序时，如果存在相同位次的记录，则会跳过之后的位次。<br>例）有3 条记录排在第1 位时：1 位、1 位、1 位、4 位……</p>
<h3 id="DENSE-RANK函数"><a href="#DENSE-RANK函数" class="headerlink" title="DENSE_RANK函数"></a>DENSE_RANK函数</h3><p>同样是计算排序，即使存在相同位次的记录，也不会跳过之后的位次。<br>例）有3 条记录排在第1 位时：1 位、1 位、1 位、2 位……</p>
<h3 id="ROW-NUMBER函数"><a href="#ROW-NUMBER函数" class="headerlink" title="ROW_NUMBER函数"></a>ROW_NUMBER函数</h3><p>赋予唯一的连续位次。<br>例）有3 条记录排在第1 位时：1 位、2 位、3 位、4 位……</p>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>以“自身记录（当前记录）”作为基准进行统计，就是将聚合函数当作窗口函数使用时的最大特征。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT product_id, product_name, sale_price,</span><br><span class="line">AVG (sale_price) OVER (ORDER BY product_id) AS current_avg</span><br><span class="line">FROM Product;</span><br></pre></td></tr></table></figure>

<h2 id="Grouping-运算符"><a href="#Grouping-运算符" class="headerlink" title="Grouping 运算符"></a>Grouping 运算符</h2><h3 id="GROUPING-运算符包含以下3-种："><a href="#GROUPING-运算符包含以下3-种：" class="headerlink" title="GROUPING 运算符包含以下3 种："></a>GROUPING 运算符包含以下3 种：</h3><p>1.ROLLUP<br>2.CUBE<br>3.GROUPING SETS</p>
<h3 id="ROLLUP"><a href="#ROLLUP" class="headerlink" title="ROLLUP"></a>ROLLUP</h3><p>作用：一次计算出不同聚合键组合的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT product_type, regist_date, SUM(sale_price) AS sum_price</span><br><span class="line">FROM Product</span><br><span class="line">GROUP BY product_type, regist_date with rollup;</span><br></pre></td></tr></table></figure>

<p>相当于使用UNION联结下面三条语句：</p>
<p>1.GROUP BY () – 相当于不使用group by 语句。<br>2.GROUP BY (product_type)<br>3.GROUP BY (product_type, regist_date)</p>
<h3 id="GROUPING"><a href="#GROUPING" class="headerlink" title="GROUPING"></a>GROUPING</h3><p>作用：该函数在其参数列的值为超级分组记录所产生的NULL 时返回1，其他情况返回0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT GROUPING(product_type) AS product_type,</span><br><span class="line">GROUPING(regist_date) AS regist_date, SUM(sale_price) AS sum_price</span><br><span class="line">FROM Product</span><br><span class="line">GROUP BY product_type,regist_date with ROLLUP;</span><br></pre></td></tr></table></figure>

<p>利用grouping完善查找信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select case when grouping(product_type) = 1 THEN &#x27;商品种类 合计&#x27; else product_type end as product_type,</span><br><span class="line">       case when grouping(regist_date) = 1 THEN &#x27;登记日期 合计&#x27; else regist_date end as regist_date,</span><br><span class="line">       sum(sale_price) as sum_sale_price</span><br><span class="line">From product</span><br><span class="line">group by product_type, regist_date with ROLLUP;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CUBE"><a href="#CUBE" class="headerlink" title="CUBE"></a>CUBE</h3><p>作用：将GROUP BY 子句中聚合键的“所有可能的组合”的汇总结果集中到一个结果中。因此，组合的个数就是2n（n 是聚合键的个数）。</p>
<p>MYSQL 不支持。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select case when grouping(product_type) = 1 THEN &#x27;商品种类 合计&#x27; else product_type end as product_type,</span><br><span class="line">       case when grouping(regist_date) = 1 THEN &#x27;登记日期 合计&#x27; else regist_date end as regist_date,</span><br><span class="line">       sum(sale_price) as sum_sale_price</span><br><span class="line">From product</span><br><span class="line">group by product_type, regist_date with cube;</span><br></pre></td></tr></table></figure>

<p>相当于执行以下一系列语句：</p>
<p>1.GROUP BY ()<br>2.GROUP BY (product_type)<br>3.GROUP BY (regist_date)     ←添加的组合， 与ROLLUP 的区别。<br>4.GROUP BY (product_type, regist_date)</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>一些有用的小技巧</title>
    <url>/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/Systems/systemUsing_01/</url>
    <content><![CDATA[<h1 id="系统配置及软件安装"><a href="#系统配置及软件安装" class="headerlink" title="系统配置及软件安装"></a>系统配置及软件安装</h1><p>遇到的一些有用的软件或者一些比较有用的设置。<span id="more"></span></p>
<h2 id="Windows右键新建中增加新建md文件"><a href="#Windows右键新建中增加新建md文件" class="headerlink" title="Windows右键新建中增加新建md文件"></a>Windows右键新建中增加新建md文件</h2><p>推荐使用Typora来编写MarkDown文档。</p>
<h3 id="添加方式"><a href="#添加方式" class="headerlink" title="添加方式"></a>添加方式</h3><p> 1.右键新建 .txt 文件，不用命名不重要， 在文件中写进以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\.md]</span><br><span class="line">@=&quot;typora.md&quot;</span><br><span class="line">&quot;icon&quot;=&quot;D:\\Typora\\typora.exe&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\.md\OpenWithProgids]</span><br><span class="line">&quot;Typora.md&quot;=&quot;&quot;</span><br><span class="line">&quot;VSCode.md&quot;=&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\.md\ShellNew]</span><br><span class="line">&quot;NullFile&quot;=&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>注意：修改上述的typora文件路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;icon&quot;=&quot;D:\\Typora\\typora.exe&quot; --&gt; “修改成你自己的文件路径”</span><br></pre></td></tr></table></figure>

<p>2.保存后重命名，修改后缀为  .reg 文件。</p>
<p>3.双击执行，一路点是就行。</p>
<h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><img src = "/images/createMd/createMd01.png">

<h2 id="Adobe-Acrobat-Pro-DC设置文档打开时铺满全局"><a href="#Adobe-Acrobat-Pro-DC设置文档打开时铺满全局" class="headerlink" title="Adobe Acrobat Pro DC设置文档打开时铺满全局"></a>Adobe Acrobat Pro DC设置文档打开时铺满全局</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>修改首选项里的页面设置，全局视图—&gt;适合宽度。</p>
<h4 id="缺点：点击书签访问时，依旧会出现不能铺满屏幕的状况。"><a href="#缺点：点击书签访问时，依旧会出现不能铺满屏幕的状况。" class="headerlink" title="缺点：点击书签访问时，依旧会出现不能铺满屏幕的状况。"></a>缺点：点击书签访问时，依旧会出现不能铺满屏幕的状况。</h4><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>选中所有书签（ctrl+A）——属性——动作——添加动作选择——执行菜单项——添加——“视图&gt;缩放&gt;适合宽度”</p>
<p>这样点击书签后，就是适合宽度了。</p>
<h2 id="使用Ubuntu图形界面"><a href="#使用Ubuntu图形界面" class="headerlink" title="使用Ubuntu图形界面"></a>使用Ubuntu图形界面</h2><p>​    之前使用一直都用服务器所以没有接触过Ubuntu的图形界面，还是第一次电脑上装Ubuntu系统。<!--more--></p>
<h2 id="语言选择"><a href="#语言选择" class="headerlink" title="语言选择"></a>语言选择</h2><p>   没想到语言选择第一步就难住了我，安装的是中文版到但是一直没能成功设置为中文。直到看到一个鬼才方法。具体步骤如下：</p>
<p>​    1.找到Ubuntu中Language support软件</p>
<p>​    2.打开软件后添加简体中文语言包</p>
<p>​    3.现在依然显示汉语为灰色无法选中，但是可以拖动！！！将汉语那一框拖动到最上面去，然后重启就可以了。</p>
<p>参考的博客链接为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://blog.csdn.net/qq_42007712/article/details/82832725?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.base&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.base</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>系统配置</category>
      </categories>
      <tags>
        <tag>system</tag>
      </tags>
  </entry>
  <entry>
    <title>Uniform Initialization</title>
    <url>/%E5%AD%A6%E4%B9%A0/Cpp/cpp11%E6%96%B0%E7%89%B9%E6%80%A7/UniformeInitialization/</url>
    <content><![CDATA[<p>在C++11之前，初始化操作可以用很多种方法来实现，比如说小括号，大括号以及赋值符号，C++11之后，统一都可以使用花括号来初始化变量，当然，所有之前可以使用的方式依然可以使用。</p>
<span id="more"></span>

<h2 id="Uniform-Initialization"><a href="#Uniform-Initialization" class="headerlink" title="Uniform Initialization"></a>Uniform Initialization</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在C++11之前，初始化操作可以用很多种方法来实现，比如说小括号，大括号以及赋值符号。</p>
<p>如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rect r1 = &#123; 3, 7, 20, 25, &amp;area, &amp;print &#125;;</span><br><span class="line">Rect r1(3, 7, 20, 25);</span><br><span class="line">int ia[6] = &#123;1, 2, 3, 4, 5, 6&#125;;</span><br></pre></td></tr></table></figure>

<p>为了解决初始化操作的不统一，C++11引入了uniform initialization，也就是一致性初始化的概念，对于所有初始化操作，都可以统一地使用大括号来解决。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>编译器看到{ t1, t2, t3, …, tn }便做出一个initializer_list<T>，它关联至一个array&lt;T, n&gt;。调用函数(例如构造函数)时该array内的元素可以被编译器分解逐一传给函数。但如果函数参数本来就是一个initializer_list<T>，整个initializer_list<T>就会被整个传过去。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//举例</span><br><span class="line">vector&lt;string&gt; cities&#123;&quot;Berlin&quot;, &quot;New York&quot;, &quot;London&quot; &#125;;</span><br></pre></td></tr></table></figure>

<p>这就会形成一个initializer_list<string>，背后有个array&lt;string, 3&gt;。调用vector<string>的构造函数时编译器找到了一个构造函数接受initializer_list<string>。所有容器都有这样的构造函数.</p>
<h3 id="initializer-list-lt-gt"><a href="#initializer-list-lt-gt" class="headerlink" title="initializer_list&lt;&gt;"></a>initializer_list&lt;&gt;</h3><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>使用{}会强制为变量初始化，即使是基本类型，如果没有赋予初值的话，那它的值也是不确定的。但是如果使用initializer_list&lt;&gt;也就是{}来初始化，初始值会赋值为0，指针会赋值为空指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i;  // i 的值不确定</span><br><span class="line">int j&#123;&#125;; // j = 0;</span><br><span class="line">int *p; //p 的值不确定</span><br><span class="line">int *q&#123;&#125;; // q = nullptr</span><br></pre></td></tr></table></figure>

<p>除此之外，{}也就是initializer_list是一种狭义的初始化，不能实现数据格式转换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x1(5.3); //ok x1 = 5;</span><br><span class="line">int x2 = 5.2; //ok x2 = 5;</span><br><span class="line">int x3&#123;5.3&#125;; //error narrowing.</span><br></pre></td></tr></table></figure>

<p>为了支持用户自定义类型实现列表初始化，C++11提供了一种新的模板类。叫做std::initializer_list.</p>
<p>只要输入值为一系列的值，或者数值列表都可以使用initializer_list来实现初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//举例</span><br><span class="line">void print(std::initializer_list&lt;int&gt; vals)&#123;</span><br><span class="line">	for(auto p = vals.begin(); p!= vals.end(); ++p)&#123;</span><br><span class="line">		//a list of value</span><br><span class="line">		std::cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//传给 initializer_list的一定是 initializer_list 或者是 &#123;&#125;。</span><br><span class="line"></span><br><span class="line">//传递一个列表给函数。</span><br><span class="line">print(&#123;1, 2, 3, 4, 11&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>当选择输入一串数字或输入一个列表时，输入列表时一种更好的选择。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class P</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    P(int a, int b)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;P(int, int), a=&quot; &lt;&lt; a &lt;&lt; &quot;, b=&quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    P(initializer_list&lt;int&gt; initlist)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;P(initailizer_list&lt;int&gt;), values=&quot;;</span><br><span class="line">        for(auto i : initlist)</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; &#x27; &#x27;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">P p(77, 5);      //调用P(int, int)</span><br><span class="line">P p&#123; 77, 5 &#125;;    //调用P(initializer_list&lt;int&gt;)</span><br></pre></td></tr></table></figure>

<h3 id="部分源码"><a href="#部分源码" class="headerlink" title="部分源码"></a>部分源码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template &lt;class _E&gt;</span><br><span class="line">    class initializer_list</span><br><span class="line">    &#123;</span><br><span class="line">    public:</span><br><span class="line">        typedef _E           value_type;</span><br><span class="line">        typedef const _E&amp;    reference;</span><br><span class="line">        typedef const _E&amp;    const_reference;</span><br><span class="line">        typedef size_t       size_type;</span><br><span class="line">        typedef const _E*    iterator;</span><br><span class="line">        typedef const _E*    const_iterator;</span><br><span class="line">    </span><br><span class="line">    private:</span><br><span class="line">        iterator        _M_array;</span><br><span class="line">        size_type       _M_len;</span><br><span class="line">        </span><br><span class="line">        //编译器会在看到&#123;&#125;后，创造出一个array，再调用这个私有构造函数</span><br><span class="line">        constexpr initializer_list(const_iterator __a, size_type __l)</span><br><span class="line">            :_M_array(__a), _M_len(__l) &#123; &#125;</span><br><span class="line"> </span><br><span class="line">    public:</span><br><span class="line">        constexpr initializer_list() noexcept</span><br><span class="line">        : _M_array(0), _M_len(0) &#123; &#125;</span><br><span class="line"> </span><br><span class="line">        //Number of elements</span><br><span class="line">        constexpr size_type</span><br><span class="line">        size() const noexcept &#123; return _M_len; &#125;</span><br><span class="line">        </span><br><span class="line">        //First element</span><br><span class="line">        constexpr const_iterator</span><br><span class="line">        begin() const noexcept &#123; return _M_array; &#125;</span><br><span class="line"> </span><br><span class="line">        //One past the last element</span><br><span class="line">        end() const noexcept &#123; return begin() + _M_len; &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出class initializer_list&lt;&gt;中的成员是一个迭代器和一个长度，迭代器指向array的首元素，长度就是array的长度。并且它有一个私有构造函数，我们不能调用，但是编译器会在看到{}之后，先创建出一个array&lt;&gt;，然后再创建出相应的initializer_list&lt;&gt;。下面是array的部分源码，选自TR1，现在的版本会更加复杂，但是原理都相同：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;typename _Tp, std::size_t _Nm&gt;</span><br><span class="line">    struct array</span><br><span class="line">    &#123;</span><br><span class="line">        typedef _Tp             value_type;</span><br><span class="line">        typedef _Tp*            pointer;</span><br><span class="line">        typedef value_type*     iterator;</span><br><span class="line"> </span><br><span class="line">        // Support for zero-sized arrays mandatory</span><br><span class="line">        value_type _M_instance[_Nm ? _Nm : 1];</span><br><span class="line">        </span><br><span class="line">        iterator begin()</span><br><span class="line">        &#123; return iterator(&amp;_M_instance[0]); &#125; </span><br><span class="line">        </span><br><span class="line">        iterator end()</span><br><span class="line">        &#123; return iterator(&amp;_M_instance[_Nm]); &#125;</span><br><span class="line"> </span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>class array&lt;&gt;其实就是把数组按照容器的要求重写了一下，从而使数组也拥有迭代器之类的方便处理的东西。</p>
<h3 id="initializer-list-lt-gt-广泛应用于标准库中"><a href="#initializer-list-lt-gt-广泛应用于标准库中" class="headerlink" title="initializer_list&lt;&gt;广泛应用于标准库中"></a>initializer_list&lt;&gt;广泛应用于标准库中</h3><p>所有容器都接受指定任意数量的值用于构建或赋值或insert()或assign()；algorithm中的max()和min()也愿意接受任意参数。</p>
<h2 id="explicit-关键字"><a href="#explicit-关键字" class="headerlink" title="explicit 关键字"></a>explicit 关键字</h2><p>C++提供了关键字explicit，可以阻止不应该允许的经过转换<strong>构造函数</strong>进行的<strong>隐式转换</strong>的发生。声明为explicit的构造函数不能在隐式转换中使用。</p>
<p>C++中的explicit关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式).</p>
<p> <strong>explicit关键字的作用就是防止类构造函数的隐式自动转换.</strong></p>
<p>注意：当类的声明和定义分别在两个文件中时，explicit只能写在在声明中，不能写在定义中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Test1&#123;</span><br><span class="line">public :</span><br><span class="line">      explicit Test(int num):n(num)&#123;&#125;</span><br><span class="line">private:</span><br><span class="line">       int n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	Test1 x1 = 10; // error 不能提供隐式转换。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="range-based-for-statement"><a href="#range-based-for-statement" class="headerlink" title="range-based for statement"></a>range-based for statement</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for( decl : coll )&#123;</span><br><span class="line">	statement...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>个人感觉有点类似于python的in range()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//例1</span><br><span class="line">for(int i : &#123;2, 3, 4, 5, 6&#125;)&#123;</span><br><span class="line">	cout &lt;&lt; i&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//例2</span><br><span class="line">vector&lt;int&gt; vec;</span><br><span class="line">...</span><br><span class="line">for( auto elem : vec )&#123;</span><br><span class="line">	cout &lt;&lt; elem  &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">for( auto&amp; elem : vec)&#123;</span><br><span class="line">	elem *= 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Variadic Templates</title>
    <url>/%E5%AD%A6%E4%B9%A0/Cpp/cpp11%E6%96%B0%E7%89%B9%E6%80%A7/VariadicTemplates/</url>
    <content><![CDATA[<p>C++ 11引入了的一个新特性为 Variadic Templates， 即可变参数模板。同时还有一些小的改动，如可以去掉模板表达式的空格、引入空指针nullptr和自动判断当前数据类型的AUTO等。</p>
<span id="more"></span>

<h1 id="Variadic-Templates"><a href="#Variadic-Templates" class="headerlink" title="Variadic Templates"></a>Variadic Templates</h1><p>C++ 11支持任意参数类型和任意参数个数实现。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用可变参数模板一定会有一个空调用来结束递归调用。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可变参数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt; <span class="comment">//这里的 ... 是关键字的一部分， 即typename...。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T&amp; firstArg, <span class="keyword">const</span> Types&amp;... args)</span></span>&#123;	<span class="comment">//这里的...要写在自定义类型Types后面</span></span><br><span class="line">    cout &lt;&lt; firstArg &lt;&lt; endl;		</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(args...);									<span class="comment">//这里的...要写在args后面。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.注意三种不同的…的应用环境，这些都是语法规则，所以记住即可。</p>
<p>…  就是所谓的一个包。</p>
<p>2.还要注意的是，在可变模板参数内部可以使用**sizeof…(args)**得到实参的个数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sizeof...(args) 是C++ 11的新特性。</span><br></pre></td></tr></table></figure>

<p>3.如果同时定义了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tempalte &lt;typename... Types&gt;</span><br><span class="line">void print(Types&amp;... args)&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译时不会报错，如果泛化和特化的同时定义，优先调用特化。所以这个定义永远不会被调用。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>1.<strong>实现函数的递归调用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;functional&gt;</span><br><span class="line"></span><br><span class="line">class CustomerHash&#123;</span><br><span class="line">public:</span><br><span class="line">	std::size_t operator() (const Customer&amp; c) const &#123;</span><br><span class="line">		//这里的返回类型是std::size_t，所以会调用返回类型相同的hash_val函数定义。</span><br><span class="line">		return hash_val(c.fname, c.lname, c.no);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//首先调用下面这个函数，再递归调用其他函数。</span><br><span class="line">template &lt;typename... Types&gt;</span><br><span class="line">inline size_t hash_val( const Types&amp;... args)&#123;</span><br><span class="line">	size_t seed = 0;</span><br><span class="line">	hash_val(seed, args...);</span><br><span class="line">	return seed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//可以接受任意个参数的hash_val 函数。</span><br><span class="line">template&lt;typename T, typename... Types&gt;</span><br><span class="line">inline void hash_val(size_t&amp; seed, const T&amp; val, const Type&amp;... args)&#123;</span><br><span class="line">	hash_combine(seed, val);</span><br><span class="line">	//递归调用</span><br><span class="line">	hash_val(seed, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//仅支持一个参数的hash_val函数，更加特化。</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void hash_val(size_t&amp; seed, const T&amp; val)&#123;</span><br><span class="line">	hash_combine(seed, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//hash_combine函数</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void hash_combine&lt;size_t&amp; seed, const T&amp; val)&#123;</span><br><span class="line">	seed ^= std::hash&lt;T&gt;()(val) + 0x9e3779b9 + (seed &lt;&lt;6) + (seed&gt;&gt;2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.<strong>容器tuple实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template &lt;typename... Values&gt; class tuple;</span><br><span class="line">template&lt;&gt; class tuple&lt;&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename Head, typename... Tail&gt;</span><br><span class="line">class tuple&lt;Head, Tail...&gt; </span><br><span class="line">	:private tuple&lt;Tail...&gt;&#123; // 注意这里的私有继承</span><br><span class="line">	typedef tuple&lt;Tail...&gt; inherited;</span><br><span class="line">public:</span><br><span class="line">	tuple()&#123;&#125;</span><br><span class="line">	tuple(Head v, Tail... vtail):m_head(v),inherited(vtail...)&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	Head head()&#123;return m_head&#125;</span><br><span class="line">	inherited&amp; tail()&#123;return *this;&#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">	Head m_head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Spaces-in-template-Expressions"><a href="#Spaces-in-template-Expressions" class="headerlink" title="Spaces in template Expressions"></a>Spaces in template Expressions</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;&lt;list&gt; &gt; vec; // ok in each C++ version.</span><br><span class="line">vector&lt;&lt;list&gt;&gt; ves; //ok since C++ 11</span><br></pre></td></tr></table></figure>

<h1 id="Nullptr"><a href="#Nullptr" class="headerlink" title="Nullptr"></a>Nullptr</h1><p>Ｃ++中的NULL＝０，所以使用NULL有时会发生歧义，因此，引进了一种新的基本数据类型</p>
<p>std::nullptr_t, 定义于＜cstddef&gt;中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// \inlude\stddef.h</span><br><span class="line">#if defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 201103L</span><br><span class="line">#ifndef _GXX_NULLPTR_T</span><br><span class="line">#define _GXX_NULLPTR_T</span><br><span class="line">	typedef decltype(nullptr) nullptr_t;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun(nullptr);        //calls f(void*)</span><br></pre></td></tr></table></figure>

<h1 id="AUTO"><a href="#AUTO" class="headerlink" title="AUTO"></a>AUTO</h1><p>在C++11中，你可以通过使用auto来声明一个对象或者变量而不用具体指出其数据类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto i = 42; // i has type int</span><br><span class="line">double f();</span><br><span class="line">auto d = f(); // d has type double</span><br></pre></td></tr></table></figure>

<p>使用auto能够避免一些非常长或者非常复杂的表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; vec;</span><br><span class="line">auto pos = v.begin();  // vector&lt;string&gt;::iterator</span><br><span class="line">auto l = [](intx)-&gt;bool&#123;  //l has the type of a lamba</span><br><span class="line">	...            // taking an int and returning a bool.</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>=default =delete</title>
    <url>/%E5%AD%A6%E4%B9%A0/Cpp/cpp11%E6%96%B0%E7%89%B9%E6%80%A7/deafult/</url>
    <content><![CDATA[<p> 如果你自信定义了一个ctor，那么编译器就不会再给你一个 default ctor。 如果你强制加上一个 =default，就可以重新获得并使用default ctor。</p>
<span id="more"></span>

<h3 id="default"><a href="#default" class="headerlink" title="=default"></a>=default</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Zoo&#123;</span><br><span class="line">public:</span><br><span class="line">	Zoo(int i1, int i2):d1(i1),da(i2)&#123;&#125;</span><br><span class="line">	Zoo(const Zoo&amp;) =delete;</span><br><span class="line">	Zoo(Zoo&amp;&amp;) =default;</span><br><span class="line">	Zoo&amp; operator=(coonst Zoo&amp;) =default;</span><br><span class="line">	Zoo&amp; operator=(coonst Zoo&amp;&amp;) =delete;</span><br><span class="line">	</span><br><span class="line">	virtual ~Zoo()&#123;&#125;</span><br><span class="line">private:</span><br><span class="line">	int d1,d2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是default使用的范围有限，只能适用于big-five.</p>
<h3 id="delete"><a href="#delete" class="headerlink" title="=delete"></a>=delete</h3><p>禁止使用默认编译器生成的默认函数。</p>
<p>delete 关键字可用于任何函数，不仅仅局限于类的成员函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">public:</span><br><span class="line">	//构造函数</span><br><span class="line">	Foo(int i):_i(i)&#123;&#125;</span><br><span class="line">	Foo() =default;</span><br><span class="line">	</span><br><span class="line">	//拷贝构造</span><br><span class="line">	Foo(const Foo&amp;):_i(x._i)&#123;&#125;</span><br><span class="line">	//Foo(const Foo&amp;)=default; //error Foo(const Foo&amp;) cannot be ovewrloaded</span><br><span class="line">	//Foo(const Foo&amp;)=delete; //error Foo(const Foo&amp;) cannot be ovewrloaded</span><br><span class="line">	</span><br><span class="line">	//拷贝赋值</span><br><span class="line">	Foo&amp; operator=(const Foo&amp; x)&#123;_i = x._i; return *this&#125;</span><br><span class="line">	//Foo&amp; operator=(const Foo&amp; x)=default; //error Foo(const Foo&amp;) cannot be ovewrloaded</span><br><span class="line">	//Foo&amp; operator=(const Foo&amp; x)=delete;  //error Foo(const Foo&amp;) cannot be ovewrloaded</span><br><span class="line">	//普通函数</span><br><span class="line">	//void func1()=default; //error Foo(const Foo&amp;) cannot be defaulted;</span><br><span class="line">	void func2()=delete;</span><br><span class="line">	</span><br><span class="line">	//析构函数</span><br><span class="line">	//~Foo()=delete;</span><br><span class="line">	~foo()=default;</span><br><span class="line">private:</span><br><span class="line">	int _i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(1)拷贝构造和拷贝赋值只能有一个定义。(猜想Big-Five是否都是这样的？)</p>
<p>(2)=default只能用于Big_five，用在普通函数上会报错</p>
<p>(3)如果析构函数定义为删除的，语法上是可以的，但是在使用对象时肯定会报错，因为一个对象的生命周期总会结束的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Empty&#123;&#125;;</span><br><span class="line">//编译器处理完之后</span><br><span class="line">class Empty&#123;</span><br><span class="line">public:</span><br><span class="line">	Empty()&#123; ... &#125;</span><br><span class="line">	Empty(const Empty&amp; e1)&#123; ... &#125;</span><br><span class="line">	~Empty()&#123;...&#125;</span><br><span class="line">	</span><br><span class="line">	Empty&amp; operator=(const Empty&amp; e1)&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立一个空类，C++编译器处理完之后会为它声明一个ctor、copy ctor、copy assignment operator、dtor.所有这些函数都是 public 以及 inline的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//示例： No-Copy：将拷贝构造函数和拷贝赋值运算符定义为删除的</span><br><span class="line">struct NoCopy</span><br><span class="line">&#123;</span><br><span class="line">    NoCopy() = default;</span><br><span class="line">    NoCopy(const NoCopy&amp;) = delete;</span><br><span class="line">    NoCopy &amp;operator=(const NoCopy&amp;) = delete;</span><br><span class="line">    ~NoCopy() = default;</span><br><span class="line">    //other members</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//示例：NoDtor：将析构函数定义为删除的</span><br><span class="line">struct NoDtor</span><br><span class="line">&#123;</span><br><span class="line">    NoDtor() = default;</span><br><span class="line">    ~NoDtor() = delete; </span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">NoDtor nd;                   //error</span><br><span class="line">NoDtor *p = new NoDtor();    //OK</span><br><span class="line">delete p;                    //error</span><br></pre></td></tr></table></figure>

<p>为什么new可以，定义变量不可以？</p>
<p>原因：因为nd是定义在栈上的变量，在作用域结束以后会自动调用析构函数，调用析构函数是由操作系统自动完成的，当编译器发现无法调用析构函数时就会报错。而new出来的对象是在堆上的，操作系统不会自动调用析构函数，需要我们手动销毁，只要我们不销毁就不会调用析构函数，也就不会出错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//示例：Private-Copy：将拷贝构造函数和拷贝构造运算符定义为私有的</span><br><span class="line">class PrivateCopy</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    PrivateCopy(const PrivateCopy&amp;);</span><br><span class="line">    PrivateCopy operator=(const PrivateCopy&amp;);</span><br><span class="line">public:</span><br><span class="line">    PrivateCopy() = default;</span><br><span class="line">    ~PrivateCopy();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个class不能被ordinary user code拷贝，但是可以被friends和members拷贝。</p>
<h3 id="boost-noncopyable"><a href="#boost-noncopyable" class="headerlink" title="boost::noncopyable"></a>boost::noncopyable</h3><p>noncopyable为实现不可拷贝的类提供了简单清晰的解决办法。</p>
<p>使用boost::noncopyable禁用（delete）了拷贝构造，无法调用拷贝构造函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class do_not_copy:boost:：noncopyable//注意这里，使用默认的私有继承是允许的</span><br><span class="line">&#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>我们也可以显式写出private或者public修饰词，但效果是相同的。因此直接这样写少输入了一些代码，也更清晰，并且表明了HAS-A关系（而不是IS-A）。</p>
<p>如果有其他人误写了代码，企图拷贝构造或者赋值这个对象，那么将不能通过编译器的审查：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do_not_copy d1；//一个不可拷贝对象</span><br><span class="line"></span><br><span class="line">do_notcopy d2（d1）；//企图拷贝构造，编译出错！</span><br><span class="line"></span><br><span class="line">do_not_copy d3；//另一个不可拷贝对象</span><br><span class="line"></span><br><span class="line">d3=d1；//企图拷贝赋值，编译出错！</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 2.2</title>
    <url>/%E5%AD%A6%E4%B9%A0/Cpp/cppPrimer/cppPrimerCh02_2/</url>
    <content><![CDATA[<p>C++ Primer 第二篇第四章学习笔记。<span id="more"></span></p>
<h1 id="第二篇-基本语言"><a href="#第二篇-基本语言" class="headerlink" title="第二篇 基本语言"></a>第二篇 基本语言</h1><h2 id="第二章-表达式"><a href="#第二章-表达式" class="headerlink" title="第二章  表达式"></a>第二章  表达式</h2><p>基本算术运算符、逻辑运算符、赋值运算符、条件运算符与其他语言一致。</p>
<h3 id="sizeof-操作符"><a href="#sizeof-操作符" class="headerlink" title="sizeof 操作符"></a>sizeof 操作符</h3><p>siseof 操作符的作用是返回一个对象或类型名的字节长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//三种用法</span><br><span class="line">sizeof (type name );</span><br><span class="line">sizeof ( object );</span><br><span class="line">sizeof object;</span><br></pre></td></tr></table></figure>

<p>返回值的类型是size_t ，这是一种与机器相关的typedef 定义。</p>
<p>应用在指针类型上的sizeof 操作符，返回的是包含该类型地址所需的内存长度。但是应用在引用类型上的sizeof 操作符。返回的是包含被引用对象所需的内存长度。</p>
<h3 id="new-和delete-表达式"><a href="#new-和delete-表达式" class="headerlink" title="new 和delete 表达式"></a>new 和delete 表达式</h3><p>系统为每个程序都提供了一个在程序执行时可用的内存池。这个可用内存池被称为程序的空闲存储区。</p>
<p>运行时刻的内存分配被称为动态内存分配。</p>
<p>动态内存分配由new 表达式应用在一个类型指示符上来完成。类型指示符可以是内置类型或用户定义类型。new 表达式返回指向新分配的对象的指针。 </p>
<p>delete 表达式应用在”<strong>指向我们用new 表达式分配的</strong>“对象指针上来做到这一点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *pi = new int(1024);</span><br><span class="line">delete pi;</span><br><span class="line">int *pin = new int[10];</span><br><span class="line">delete [] pin;</span><br></pre></td></tr></table></figure>

<h3 id="位操作符和bitset"><a href="#位操作符和bitset" class="headerlink" title="位操作符和bitset"></a>位操作符和bitset</h3><p>位操作符把操作数解释成有序的位集合，这些位可能是独立的也可能组成域，每个位可以含有0 off 或1 on 。位操作符允许程序员设置或测试独立的位或位域。如果一个对象被用作一组位或位域的离散集合那么这样的对象称为位向量 位。向量是一种用来记录一组项目或条件的是/否信息的紧缩方法</p>
<p>标准库提供了一个bitset 类它支持位向量的类抽象。bitset 对象封装了位向量的语义。</p>
<img src = "/images/cpp/bitset.png">

<p>bitset 有三种声明方式在缺省定义中我们只需简单地指明位向量的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bitset&gt;</span><br><span class="line">bitset&lt; 32 &gt; bitvec;</span><br><span class="line">//声明了一个含有32位的bitset 对象,位的顺序从0到31,缺省情况下所有的位都被初始化为0</span><br></pre></td></tr></table></figure>

<h3 id="强制类型装换"><a href="#强制类型装换" class="headerlink" title="强制类型装换"></a>强制类型装换</h3><p>强制类型转换很可能会引入一些难以发现的错误。尤其是(void *)类型的指针。</p>
<img src = "/images/cpp/cast.png">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//4种类型的转换的格式</span><br><span class="line">TYPE b = static_cast(TYPE)(a);</span><br></pre></td></tr></table></figure>

<p>C++为了规范C中的类型转换，加强类型转换的可视性，引入了四种强制类型转换操作符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static_cast, reinterpret_cast, const_cast, dynamic_cast </span><br></pre></td></tr></table></figure>

<p>他们本质上都是模板类。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 2.3</title>
    <url>/%E5%AD%A6%E4%B9%A0/Cpp/cppPrimer/cppPrimerCh02_3/</url>
    <content><![CDATA[<p>C++ Primer 第二篇第五章学习笔记。<span id="more"></span></p>
<h1 id="第二篇-基本语言"><a href="#第二篇-基本语言" class="headerlink" title="第二篇 基本语言"></a>第二篇 基本语言</h1><h2 id="第五章-语句"><a href="#第五章-语句" class="headerlink" title="第五章  语句"></a>第五章  语句</h2><p>与其他语言差别不大。</p>
<h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if()&#123;</span><br><span class="line"></span><br><span class="line">&#125;else if()&#123;</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switch()&#123;</span><br><span class="line">	case:</span><br><span class="line">		//...</span><br><span class="line">		break;</span><br><span class="line">	case:</span><br><span class="line">		//...</span><br><span class="line">		break;</span><br><span class="line">	default:</span><br><span class="line">		//...</span><br><span class="line">		break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i=0; i&lt;n; i++)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">for(int i=0; i&lt;k; i++)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//C++这里的i是局部变量，</span><br></pre></td></tr></table></figure>

<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>break 语句终止最近的while, do while, for 或switch 语句.</p>
<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>continue 语句导致最近的循环语句的当前迭代结束,执行权被传递给条件计算部分.</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 1.1</title>
    <url>/%E5%AD%A6%E4%B9%A0/Cpp/cppPrimer/cppPrimerCh01_1/</url>
    <content><![CDATA[<p> C++ Primer 第一篇学习笔记。<span id="more"></span></p>
<h1 id="第一篇-C-概述"><a href="#第一篇-C-概述" class="headerlink" title="第一篇 C++概述"></a>第一篇 C++概述</h1><h2 id="第一章-开始"><a href="#第一章-开始" class="headerlink" title="第一章  开始"></a>第一章  开始</h2><h3 id="C-支持多种程序设计方法："><a href="#C-支持多种程序设计方法：" class="headerlink" title="C++支持多种程序设计方法："></a>C++支持多种程序设计方法：</h3><p>​    过程化程序设计方法。　主要是函数。</p>
<p>　对抽象数据类型程序设计方法。　主要是类。</p>
<p>​    面向对象程序设计方法。　主要是继承和动态绑定。</p>
<h3 id="分而治之-和-逐步求精-的思想"><a href="#分而治之-和-逐步求精-的思想" class="headerlink" title="分而治之 和 逐步求精 的思想"></a>分而治之 和 逐步求精 的思想</h3><p>​        解决大问题的一种方法是，把它分解成许多小问题，理想情况下，这些小问题可以很容易地被解决，然后再把它们合在一起，就可以解决大问题了。如果新分割的小问题解决起来还是太大，就把它分割得再小一些，重复整个过程，直到能够解决每个小问题。</p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>​    C++标准库中的名字都是在一个称作std 的名字空间中声明的，这些名字在我们的程序文本文件中是不可见的，除非我们显式地使它们可见，using 指示符告诉编译器要使用在名字空间std 中声明的名字。</p>
<h3 id="预处理器指示符"><a href="#预处理器指示符" class="headerlink" title="预处理器指示符"></a>预处理器指示符</h3><p>如果文件名用尖括号&lt; 和&gt; 括起来表明这个文件是一个工程或标准头文件，查找过程会检查预定义的目录，我们可以通过设置搜索路径环境变量或命令行选项来修改这些目录。如果文件名用一对引号括起来。则表明该文件是用户提供的头文件查找该文件时将从当前文件目录开始。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;some_file.h&gt;</span><br><span class="line">#include &quot;my_file.h&quot;</span><br><span class="line"></span><br><span class="line">#ifndef BOOKSTORE_H</span><br><span class="line">#define BOOKSTORE_H</span><br><span class="line">/* Bookstore.h 的内容 */</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>编译C++程序时编译器自动定义了一个预处理器名字__cplusplus （注意前面有两个下划线）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef __cplusplus</span><br><span class="line">	// 我们要编译C++</span><br><span class="line">	// extern &quot;C&quot;</span><br><span class="line">	extern &quot;C&quot;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__LINE__ 用来记录文件已经被编译的行数 。</span><br><span class="line"></span><br><span class="line">__FILE__ 包含正在被编译的文件的名字。</span><br><span class="line"></span><br><span class="line">__TIME__  和 __DATE__ </span><br></pre></td></tr></table></figure>

<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>终端输入也被称为标准输入standard input，与预定义的iostream 对象 cin ，绑定在一起，直接向终端输出，也被称为标准输出standard output， 与预定义的iostream 对象cout 绑定在一起，第三个预定义iostream 对象cerr 称为标准错误standard error ，也与终端绑定cerr 通常用来产生给程序用户的警告或错误信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br></pre></td></tr></table></figure>

<p>除了显式地使用换行符外我们还可以使用预定义的iostream 操纵符 endl.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//为了打开一个文件供输入或输出除了iostream 头文件外还必须包含头文件</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">ofstream outFile(nameOfFile);</span><br></pre></td></tr></table></figure>



<h2 id="第二章-C-浏览"><a href="#第二章-C-浏览" class="headerlink" title="第二章  C++浏览"></a>第二章  C++浏览</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>虽然C++对数组类型提供了内置支持，但是这种支持仅限于用来读写单个元素的机制，C++不支持数组的抽象，也不支持对整个数组的操作。</p>
<h3 id="动态内存分配和指针"><a href="#动态内存分配和指针" class="headerlink" title="动态内存分配和指针"></a>动态内存分配和指针</h3><p>在C++中指针的主要用处是管理和操纵动态分配的内存。<br>静态与动态内存分配的两个主要区别是：<br>    1.静态对象是有名字的变量，我们直接对其进行操作，而动态对象是没有名字的变量，我们通过指针间接地对它进行操作。<br>    2.静态对象的分配与释放由编译器自动处理，程序员需要理解这一点，但不需要做任何事情，相反，动态对象的分配与释放必须由程序员显式地管理，相对来说比较容易出错，它通过new 和delete 两个表达式来完成。</p>
<h4 id="new的两种分配方式："><a href="#new的两种分配方式：" class="headerlink" title="new的两种分配方式："></a>new的两种分配方式：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//第一种：分配特定类型的单个对象</span><br><span class="line">int *pint = new int( 1024 );</span><br><span class="line">//第二种：用于分配特定类型和维数的数组</span><br><span class="line">int *pia = new int[ 4 ];</span><br></pre></td></tr></table></figure>

<h4 id="delete的释放方法："><a href="#delete的释放方法：" class="headerlink" title="delete的释放方法："></a>delete的释放方法：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//单一对象的delete 表达式形式如下</span><br><span class="line">// 删除单个对象</span><br><span class="line">delete pint;</span><br><span class="line">//数组形式的delete 表达式如下</span><br><span class="line">// 删除一个对象数组</span><br><span class="line">delete [] pia;</span><br></pre></td></tr></table></figure>

<h3 id="Class-概述"><a href="#Class-概述" class="headerlink" title="Class 概述"></a>Class 概述</h3><h4 id="类名和类体："><a href="#类名和类体：" class="headerlink" title="类名和类体："></a>类名和类体：</h4><p>类定义包括两个部分：类头class head 由关键字class 与相关联的类名构成。类体class body 由花括号括起来以分号结束。类头本身也用作类的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在程序中声明IntArray 类但是不提供定义</span><br><span class="line">class IntArray;</span><br></pre></td></tr></table></figure>

<p>类体包含成员定义,以及访问标签,如public 和private .类的成员包括该类能执行的操作和代表类抽象所必需的数据.这些操作称为成员函数member function 或方法 method。</p>
<h4 id="成员访问操作符：-和-gt"><a href="#成员访问操作符：-和-gt" class="headerlink" title="成员访问操作符：  .   和 -&gt;"></a>成员访问操作符：  .   和 -&gt;</h4><h4 id="public-和-private"><a href="#public-和-private" class="headerlink" title="public 和 private"></a>public 和 private</h4><p>关键字private 和public 控制对类成员的访问,出现在类体中公有public 部分的成员,在一般程序的任何地方都可以访问它们,出现在私有private 部分的成员,只能在该类的成员函数或友元friend 中被访问.</p>
<p>由于C++不允许成员函数与数据成员共享同一个名字，所以在这样的情况下，一般的习惯是在数据成员名字前面加一个下划线_。、</p>
<h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>内联函数在它的调用点上被展开,一般来说内联函数不会引入任何函数调用.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array.size() 展开为 array._size;</span><br></pre></td></tr></table></figure>

<h4 id="构造函数和函数重载"><a href="#构造函数和函数重载" class="headerlink" title="构造函数和函数重载"></a>构造函数和函数重载</h4><p>构造函数是一种特殊的类成员函数，专门用于初始化对象。如果构造函数被定义了，那么在类的每个对象第一次被使用之前，这构造函数就被自动应用在对象上。</p>
<p>为了定义一个构造函数，我们只要给它与类相同的名字即可，另外我们不能给构造函数指定返回值，但是可以给类定义多个构造函数，尽管它们都具有相同的名字，但只要编译器能够根据参数表区分它们就行。</p>
<p>被声明为static 的数据成员，是一类特殊的共享数据成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份，这是在类的所有对象之间共享数据的一种方式。</p>
<h4 id="域操作符"><a href="#域操作符" class="headerlink" title="域操作符"></a>域操作符</h4><p>双冒号:: 操作符被称为域操作符。可以非正式地把域看作是一个可视窗口， 全局域的对象在它被定义的整个文件里(一直到文件末尾)都是可见的。</p>
<p>C++类的关键特征是接口与实现的分离。接口是一些用户可以应用到类对象上的操作的集合，它由三部分构成这些操作的名字、它们的返回值、以及它们的参数表。一般地这就是该类用户所需要知道的全部内容。私有实现包括为支持公有接口所必需的算法和数据。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>在C++中被继承的类被称作基类， 新类从基类派生而来，我们把它叫做基类的派生类或子类型。</p>
<h3 id="泛型设计"><a href="#泛型设计" class="headerlink" title="泛型设计"></a>泛型设计</h3><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>C++的模板设施提供了一种机制它能够将类成函数定义内部的类型和值参数化。</p>
<p>模板机制也支持面向对象的程序设计，类模板可以作为基类或派生类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">template&lt;class T&gt;</span><br></pre></td></tr></table></figure>

<h4 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">搜索算法</span><br><span class="line">find() find_if() search() binary_search() count() count_if()</span><br><span class="line">分类排序与通用排序算法</span><br><span class="line">sort() partial_sort() merge() partition() rotate() reverse() random_shuffle()</span><br><span class="line">删除算法</span><br><span class="line">unique() remove()</span><br><span class="line">算术算法</span><br><span class="line">accumulate() partial_sum() inner_product() adjacent_difference()</span><br><span class="line">生成和变异算法</span><br><span class="line">generate() fill() transformation() copy( for_each()</span><br><span class="line">关系算法</span><br><span class="line">equal() min 和max()</span><br></pre></td></tr></table></figure>

<p>泛型算法接受一对迭代器，它们标记了要遍历元素的范围。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常处理为响应运行时刻的程序异常,提供了一个标准的语言级的设施.它支持统一的语法和风格,也允许每个程序员进行微调.</p>
<p>异常处理机制的主要构成如下:</p>
<ol>
<li><p>程序中异常出现的点.</p>
</li>
<li><p>程序中异常被处理的点.</p>
<p>典型地,程序异常的抛出与处理位于独立的函数或成员函数调用中.找到处理代码通常要涉及到展开程序调用栈,一旦异常被处理完毕就恢复正常的程序执行,但不是在发生异常的地方恢复执行过程,而是在处理异常的<br>地方恢复执行过程.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">catch(string exceptionMsg)&#123;</span><br><span class="line">    log_message( exceptionMsg );</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>catch 子句与try 块相关联,一个try 块用一个或多个catch 子句将一条或多条语句组织起来.</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line"></span><br><span class="line">&#125;catch()&#123;</span><br><span class="line"></span><br><span class="line">&#125;catrch( ... )&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命名空间-1"><a href="#命名空间-1" class="headerlink" title="命名空间"></a>命名空间</h3><p>名字空间机制允许我们封装名字，否则这些名字就有可能会污染影响全局名字空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">namespace Cplusplus_Primer_3E &#123;</span><br><span class="line">template &lt;class elemType&gt;</span><br><span class="line">class Array &#123; ... &#125;;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果名字空间内的声明对程序而言不是立即可见的，那么我们可以使用限定修饰名字符，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">namespace_identifier::entity_name</span><br></pre></td></tr></table></figure>

<p>名字空间别名允许用一个可替代的短的或更一般的名字与一个现有的名字空间关联起来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 提供一个更一般化的别名</span><br><span class="line">namespace LIB = IBM_Canada_Laboratory;</span><br><span class="line">// 提供一个更短的别名</span><br><span class="line">namespace DFA = Disney_Feature_Animation;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">using std::string;</span><br><span class="line">std::string;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 2.1</title>
    <url>/%E5%AD%A6%E4%B9%A0/Cpp/cppPrimer/cppPrimerCh02_1/</url>
    <content><![CDATA[<p>C++ Primer 第二篇第三章学习笔记。<span id="more"></span></p>
<h1 id="第二篇-基本语言"><a href="#第二篇-基本语言" class="headerlink" title="第二篇 基本语言"></a>第二篇 基本语言</h1><h2 id="第三章-C-数字类型"><a href="#第三章-C-数字类型" class="headerlink" title="第三章 C++数字类型"></a>第三章 C++数字类型</h2><h3 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h3><p>其他语言常见的所有类型：</p>
<p>int, short, long int,  long long int, double, float, char,</p>
<p>如果一个变量是在全局域内定义的那么系统会保证给它提供初始值0.</p>
<p>如果变量是在局部域l内定义的,或是通过new 表达式动态分配的.则系统不会向它提供初始值0 .这些对象被称为是未初始化的.</p>
<p>每种内置数据类型都支持一种特殊的构造函数语法,可将对象初始化为0.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ival = int();</span><br><span class="line">double dval = double();</span><br></pre></td></tr></table></figure>

<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>不同之处在于指针所指的对象的类型上，指针的类型可以指示编译器怎样解释特定地址上内存的内容，以及该内存区域应该跨越多少内存单元。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; *p1, p2;</span><br><span class="line">//p1指针，p2不是。</span><br></pre></td></tr></table></figure>

<p>如果我们要做的仅仅是持有地址值，那么指针的实际类型就不重要了。</p>
<p>C++提供了一种特殊的指针类型来支持这种需求，空void* 类型指针，它可以被任何数据指针类型的地址值赋值(函数指针不能赋值给它).</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>string 类型能够自动将C 风格的字符串转换成string 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string s1;</span><br><span class="line">const char *pc = &quot;a character array&quot;;</span><br><span class="line">s1 = pc; // ok</span><br></pre></td></tr></table></figure>

<p>反向的转换不能自动执行，对隐式地将string 对象转换成C 风格的字符串string类型没有提供支持。</p>
<p>为了防止字符数组被程序直接处理，c_str()返回了一个指向常量数组的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const char *str = s1.c_str(); // ok</span><br></pre></td></tr></table></figure>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用， 有时候又称为别名alias 。它可以用作对象的另一个名字，通过引用，我们可以间接地操纵对象，使用方式类似于指针，但是不需要指针的语法。在实际的程序中引用主要被用作函数的形式参数——通常将类对象传递给一个函数。</p>
<p>引用类型由类型标识符和一个取地址操作符来定义，引用必须被初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ival = 1024;</span><br><span class="line">// ok: refVal 是一个指向ival 的引用</span><br><span class="line">int &amp;refVal = ival;</span><br><span class="line">// 错误引用必须被初始化为指向一个对象</span><br><span class="line">int &amp;refVal2;</span><br></pre></td></tr></table></figure>

<p>一旦引用已经定义，它就不能再指向其他的对象。</p>
<p>引用的所有操作实际上都被应用在它所指的对象身上，包括取地址操作符。</p>
<p>指针和引用有两个主要区别：</p>
<p>​    1.引用必须总是指向一个对象，如果用一个引用给另一个引用赋值，那么改变的是被引用的对象，而不是引用本身。</p>
<p>​    2.引用之间的赋值是第二个不同。</p>
<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>枚举不但定义了整数常量而且还把它们组成一个集合。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum open_modes&#123; input = 1, output, append &#125;;</span><br><span class="line">//input、output 和append 是枚举成员。它们代表了能用来初始化和赋值open_modes 类型变量的值的全集</span><br></pre></td></tr></table></figure>

<p>枚举的限制：</p>
<ol>
<li> 不能打印枚举成员的实际枚举名。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//解决方案</span><br><span class="line">cout &lt;&lt; open_modes_table[ input ] &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>  不能使用枚举成员进行迭代</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 不支持</span><br><span class="line">for ( open_modes  iter = input; iter != append; ++iter )&#123;</span><br><span class="line">	// ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="volatile-限定修饰符"><a href="#volatile-限定修饰符" class="headerlink" title="volatile 限定修饰符"></a>volatile 限定修饰符</h3><p>当一个对象的值可能会在编译器的控制或监测之外被改变时，例如一个被系统时钟更新的变量，那么该对象应该声明成volatile， 因此编译器执行的某些例行优化行为不能应用在已指定为volatile 的对象上。</p>
<p>volatile 修饰符的主要目的是提示编译器，该对象的值可能在编译器未监测到的情况下被改变，因此编译器不能武断地对引用这些对象的代码作优化处理。</p>
<h3 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h3><p>pair 类也是标准库的一部分，它使得我们可以在单个对象内部把相同类型或不同类型的两个值关联起来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;utility&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以用成员访问符号访问pair 中的单个元素,它们的名字为first 和second.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pair&lt; string, string &gt; author( &quot;James&quot;, &quot;Joyce&quot; );</span><br><span class="line">author.first == &quot;James&quot;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 2.4</title>
    <url>/%E5%AD%A6%E4%B9%A0/Cpp/cppPrimer/cppPrimerCh02_4/</url>
    <content><![CDATA[<p>C++ Primer 第二篇第六章学习笔记。<span id="more"></span></p>
<h1 id="第二篇-基本语言"><a href="#第二篇-基本语言" class="headerlink" title="第二篇 基本语言"></a>第二篇 基本语言</h1><h3 id="第六章-抽象容器类型"><a href="#第六章-抽象容器类型" class="headerlink" title="第六章  抽象容器类型"></a>第六章  抽象容器类型</h3><h4 id="顺序容器：由单一类型元素组成的一个有序集合。"><a href="#顺序容器：由单一类型元素组成的一个有序集合。" class="headerlink" title="顺序容器：由单一类型元素组成的一个有序集合。"></a>顺序容器：由单一类型元素组成的一个有序集合。</h4><ol>
<li>list：双向链表</li>
<li>vector：向量</li>
<li>deque：双端队列</li>
</ol>
<h4 id="关联容器：支持查询一个元素是否存在并且可以有效地获取元素"><a href="#关联容器：支持查询一个元素是否存在并且可以有效地获取元素" class="headerlink" title="关联容器：支持查询一个元素是否存在并且可以有效地获取元素"></a>关联容器：支持查询一个元素是否存在并且可以有效地获取元素</h4><ol>
<li>map：键值对</li>
<li>set：单一键值</li>
</ol>
<h4 id="文本查询系统"><a href="#文本查询系统" class="headerlink" title="文本查询系统"></a>文本查询系统</h4><p>任务支持：</p>
<p>1.它必须允许用户指明要打开的文本文件的名字<br>2.它必须在内部组织文本文件以便能够识别出每个单词在句子中出现的次数以及在<br>该句子中的位置<br>3.它必须支持某种形式的布尔查询语言在我们的例子中它将支持<br>        &amp;&amp; 在一行中两个单词不仅存在而且相邻<br>        || 在一行中两个单词至少有一个存在<br>        ! 在一行中该单词不存在<br>        () 把子查询组合起来的方式</p>
<p>注意：为了简化实现我们要求用空格分割每个单词包括括号和布尔操作符</p>
<h4 id="选择vector还是list"><a href="#选择vector还是list" class="headerlink" title="选择vector还是list"></a>选择vector还是list</h4><h5 id="选择依据："><a href="#选择依据：" class="headerlink" title="选择依据："></a>选择依据：</h5><p>vector deque 以及list 都是动态增长的，在这三者之中选择的准则主要是<strong>关注插入特性以及对元素的后续访问要求</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果我们需要随机访问一个容器则vector 要比list 好得多。</span><br><span class="line">如果我们已知要存储元素的个数则vector 又是一个比list 好的选择。</span><br><span class="line">如果我们需要的不只是在容器两端插入和删除元素则list 显然要比vector 好。</span><br><span class="line">除非我们需要在容器首部插入和删除元素否则vector 要比deque 好。</span><br></pre></td></tr></table></figure>

<h4 id="vector怎样自己增长"><a href="#vector怎样自己增长" class="headerlink" title="vector怎样自己增长"></a>vector怎样自己增长</h4><p>​    获取vector的容量：容量是指在容器下一次需要增长自己之前能够被加入到容器中的元素的总数，容量只与连续存储的容器相关（例如vector deque 或string）， list 不要求容量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取容器的容量</span><br><span class="line">capacity()</span><br><span class="line">//容器当前拥有元素的个数</span><br><span class="line">size()</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ivec:size:&quot;</span> &lt;&lt; ivec.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;   &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; ivec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> ix=<span class="number">0</span>; ix&lt;<span class="number">24</span>; ix++)&#123;</span><br><span class="line">        ivec.<span class="built_in">push_back</span>(ix);</span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;ivec:size:&quot;</span> &lt;&lt; ivec.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;   &quot;</span></span><br><span class="line">         	 &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; ivec.<span class="built_in">capacity</span>() &lt;&lt; endl;        </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过指针间接存储复杂的类对象。即vector中仅存储指向复杂对象的指针，就不用重新释放对象和生成对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reserve()操作允许程序员将容器的容量设置成一个显式指定的值。</span><br></pre></td></tr></table></figure>

<h4 id="定义一个顺序容器"><a href="#定义一个顺序容器" class="headerlink" title="定义一个顺序容器"></a>定义一个顺序容器</h4><p>关联的头文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#inlucde &lt;set&gt;</span><br></pre></td></tr></table></figure>

<p>声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//简单声明</span><br><span class="line">vector&lt;string&gt;  svec;</span><br><span class="line">//指定长度</span><br><span class="line">list&lt; int &gt;  ilist( list_size );</span><br><span class="line">vector&lt; string &gt; svec(get_word_count(string(&quot;Chimera&quot;)));</span><br><span class="line">//指定长度和初始值</span><br><span class="line">list&lt; int &gt; ilist( list_size, - 1 );</span><br><span class="line">vector&lt; string &gt; svec( 24, &quot;pooh&quot; );</span><br><span class="line">//利用已有对象初始化</span><br><span class="line">vector&lt; string &gt; svec2( svec );</span><br><span class="line">list&lt; int &gt; ilist2( ilist );    </span><br></pre></td></tr></table></figure>

<p>其余操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//检查是否为空</span><br><span class="line">if(svec.empty() != True)&#123;</span><br><span class="line">	cout &lt;&lt; &quot;empty.&quot;</span><br><span class="line">&#125;</span><br><span class="line">//插入尾部</span><br><span class="line">string text_word;</span><br><span class="line">while(cin &gt;&gt; text_word)&#123;</span><br><span class="line">	svec.push_back(text_word);</span><br><span class="line">&#125;</span><br><span class="line">//list 和 deque 容器也支持 push_front() 它把新元素插入在链表的前端</span><br><span class="line"></span><br><span class="line">//重新设置长度</span><br><span class="line">svec.resize( 2 * svec.size(), &quot;piglet&quot; );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>迭代器（iterator ）提供了一种一般化的方法对顺序或关联容器类型中的每个元素进行<br>连续访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">++iter;//指向下一个元素</span><br><span class="line">//iterator 算术论算只适用于vector 或deque 而不适用于list 因为list 的元素在内存中不是连续存储的.</span><br><span class="line">*iter;//指向元素的值</span><br><span class="line">/*</span><br><span class="line">返回iterator 指向元素的值</span><br><span class="line">每种容器类型都提供一个begin()和一个end()成员函数</span><br><span class="line">begin()返回一个iterator 它指向容器的第一个元素</span><br><span class="line">end()返回一个iterator 它指向容器的末元素的下一个位置</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>为了迭代任意容器类型的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(iter=container.begin(); iter!=container.end(); ++iter)&#123;</span><br><span class="line">	do_some_thing_with_element(*iter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// vector&lt;string&gt; vec;</span><br><span class="line">vector&lt;string&gt;::iterator iter = vec.begin();</span><br><span class="line">vector&lt;string&gt;::iterator iter_end = vec.end();</span><br></pre></td></tr></table></figure>

<p>利用迭代器初始化容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; svec2( svec.begin(), svec.end() );</span><br></pre></td></tr></table></figure>

<p>两个指向内置数组的指针也可以被用作元素范围标记器（range marker）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt; string &gt; vwords( words, words+4 );</span><br></pre></td></tr></table></figure>

<h4 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h4><p>1.插入：insert()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt; string &gt; svec;</span><br><span class="line">list&lt; string &gt; slist;</span><br><span class="line">string spouse( &quot;Beth&quot; );</span><br><span class="line">slist.insert(slist.begin(), spouse)</span><br><span class="line">svec.insert(svec.begin(), spouse)</span><br><span class="line"></span><br><span class="line">list&lt;string&gt;::iterator iter;</span><br><span class="line">iter = find( slist.begin(), slist.end(), son );</span><br><span class="line">slist.insert( iter, spouse );</span><br></pre></td></tr></table></figure>

<ol>
<li>insert()方法的第一种形式支持在某个位置插入指定的元素。</li>
<li>insert()方法的第二种形式支持在某个位置插入指定数量的元素。</li>
<li>insert()方法的第三种形式支持向容器插入一段范围内的元素。</li>
</ol>
<p>2.删除：erase()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string searchValue( &quot;Quasimodo&quot; );</span><br><span class="line">list&lt; string &gt;::iterator iter = find( slist.begin(), slist.end(), searchValue );</span><br><span class="line">if ( iter != slist.end() )&#123;</span><br><span class="line">	slist.erase( iter );</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>​        如同在容器尾部插入一个元素的push_back()方法相仿pop_back()方法删除容器的末元素——它不返回元素只是简单地删除它</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt; string &gt;::iterator iter = buffer.begin();</span><br><span class="line">for ( ; iter != buffer.end(); iter++ )&#123;</span><br><span class="line">	slist.push_back( *iter );</span><br><span class="line">	if ( ! do_something( slist ))</span><br><span class="line">		slist.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.交换：swap()</p>
<p>swap()可以被看作是赋值操作符的互补操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slist1.swap( slist2 );</span><br></pre></td></tr></table></figure>

<p>4.泛型算法：</p>
<p>把所有容器类型的公共操作抽取出来形成一个通用算法集合它能够被应用到全部容器类型以及内置数组类型上，这组通用算法被称作泛型算法。泛型算法通过一个iterator 对，被绑定到一个特殊的容器上。</p>
<p>示例：find()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">int ia[6] = &#123;0, 1, 2, 3, 4, 5&#125;;</span><br><span class="line">vector&lt;string&gt; svec;</span><br><span class="line">list&lt;double&gt; dlist;</span><br><span class="line"></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">// 如果找到, find()返回指向该元素的iterator</span><br><span class="line">// 对于数组, 返回指针</span><br><span class="line">vector&lt;string&gt;::iterator viter;</span><br><span class="line">list&lt;double&gt;::iterator liter;</span><br><span class="line">int *pia;</span><br><span class="line"></span><br><span class="line">pia = find( &amp;ia[0], &amp;ia[6], some_int_value );</span><br><span class="line">liter = find( dlist.begin(), dlist.end(), some_double_value );</span><br><span class="line">viter = find( svec.begin(), svec.end(), some_string_value );</span><br></pre></td></tr></table></figure>

<h4 id="存储文本行"><a href="#存储文本行" class="headerlink" title="存储文本行"></a>存储文本行</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; *retrieve_text()&#123;</span><br><span class="line"></span><br><span class="line">    string filename;</span><br><span class="line">    cout &lt;&lt; &quot;please input the filename:&quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; filename;</span><br><span class="line">    //打开文本文件</span><br><span class="line">    ifstream infile(filename.c_str(), ios::in);</span><br><span class="line">    if( ! infile )&#123;</span><br><span class="line">        cerr &lt;&lt; &quot;Open file failed.&quot; &lt;&lt; endl;</span><br><span class="line">        exit(-1)</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //读文件</span><br><span class="line">    vector&lt;string&gt; *lines_of_text = new vector&lt;string&gt;;</span><br><span class="line">    string textLine;</span><br><span class="line">    //定义别名</span><br><span class="line">    typedef pair&lt;string::size_type, int&gt; stats;</span><br><span class="line">    stats maxline;</span><br><span class="line">    int linenum = 0;</span><br><span class="line"></span><br><span class="line">    while( getline(infile, textLine, &#x27;\n&#x27;))&#123;</span><br><span class="line">        cout &lt;&lt; &quot;line read: &quot; &lt;&lt; textLine &lt;&lt; endl;</span><br><span class="line">        if(maxline.first &lt;&lt; textLine.size())&#123;</span><br><span class="line">            maxline.first = textline.size();</span><br><span class="line">            maxline.second = linenum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lines_of_text-&gt;push_back(textLine);</span><br><span class="line">        linenum++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return lines_of_text;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="找到一个子串"><a href="#找到一个子串" class="headerlink" title="找到一个子串"></a>找到一个子串</h4><p>​        string 类提供了一套查找函数都以find 的各种变化形式命名find()是最简单的实例给出一个字符串它返回匹配子串的第一个字符的索引位置或者返回一个特定的值：string::npos。</p>
<p>​    find_first_of()查找与被搜索字符串中任意一个字符相匹配的第一次出现并返回它的索引位置。</p>
<p>​        find_last_of()查找字符串中的与搜索字符串任意元素相匹配 的最后一个字符 find_last_not_of()查找字符串中的与搜索字符串任意字符全不匹配的最后一个字符这些操作都有一个可选的第二参数来指明起始的查找位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//存储单词及其位置</span><br><span class="line">typedef pair&lt;short, short&gt; location;</span><br><span class="line">typedef vector&lt;location&gt; loc;</span><br><span class="line">typedef vector&lt;string&gt; text;</span><br><span class="line">typedef pair&lt;text *, loc *&gt; text_loc;</span><br><span class="line"></span><br><span class="line">text_loc* separate_words(const vector&lt;string&gt; *text_file)&#123;</span><br><span class="line">    //words:包含独立单词的集合</span><br><span class="line">    //locations：包含相关的行列信息。</span><br><span class="line">    vector&lt;string&gt; *words = new vector&lt;string&gt;;</span><br><span class="line">    vector&lt;location&gt; *locations = new vector&lt;location&gt;;</span><br><span class="line">    short line_pos = 0; //当前行号。</span><br><span class="line">    //迭代文本每行。</span><br><span class="line">    for (; line_pos &lt; text_file.size(); line_pos++)&#123;</span><br><span class="line">        // textline: 待处理的当前文本行</span><br><span class="line">        // word_pos: 文本行中的当前列位置</span><br><span class="line">        short word_pos = 0;</span><br><span class="line">        string textline = (*text_file)[ line_pos ];</span><br><span class="line">        string::size_type pos = 0, prev_pos = 0;</span><br><span class="line">        while (( pos = textline.find_first_of( &#x27; &#x27;, pos )) != string::npos )&#123;</span><br><span class="line">            // 存储当前单词子串的拷贝</span><br><span class="line">            words-&gt;push_back(</span><br><span class="line">            textline.substr( prev_pos, pos - prev_pos ));</span><br><span class="line">            // 将行/列信息存储为pair</span><br><span class="line">            locations -&gt;push_back(</span><br><span class="line">            make_pair( line_pos, word_pos ));</span><br><span class="line">            // 为下一次迭代修改位置信息</span><br><span class="line">            ++word_pos; prev_pos = ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        // 现在处理最后一个单词</span><br><span class="line">        words-&gt;push_back(textline.substr( prev_pos, pos - prev_pos ));</span><br><span class="line">        locations-&gt;push_back(make_pair( line_pos, word_pos ));</span><br><span class="line">    &#125;</span><br><span class="line">    return new text_loc( words, locations );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理标点符号"><a href="#处理标点符号" class="headerlink" title="处理标点符号"></a>处理标点符号</h4><p>定义一个字符串，包括所有希望去掉的字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string filt_elem(&quot;\&quot;,.:;!?)(\\/&quot;);</span><br></pre></td></tr></table></figure>

<p>用find_first_of()操作在我们的字符串里找到每个匹配元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (( pos = word.find_first_of( filt_elems, pos ))!= string::npos )</span><br></pre></td></tr></table></figure>

<p>用erase()去掉字符串中的标点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">word.erase(pos, 1);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//删除标点符号</span><br><span class="line">void filter_text(vector&lt;string&gt; *words, string filter)&#123;</span><br><span class="line">    vector&lt;string&gt;::iterator iter = words-&gt;begin();</span><br><span class="line">    vector&lt;string&gt;::iterator iter_end = words-&gt;end();</span><br><span class="line">    //如果没有提供filter,则默认使用最小值.</span><br><span class="line">    if (!filter.size())&#123;</span><br><span class="line">        filter.insert(0, &quot;\&quot;,.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //迭代</span><br><span class="line">    while( iter != iter_end)&#123;</span><br><span class="line">        string::size_type pos = 0;</span><br><span class="line">        //遂于每个找到的元素将其删除。</span><br><span class="line">        while((pos = (*iter).find_first_of(filter, pos)) != string::npos)&#123;</span><br><span class="line">            (*iter).erase(pos, 1);</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任意其他形式的字符串"><a href="#任意其他形式的字符串" class="headerlink" title="任意其他形式的字符串"></a>任意其他形式的字符串</h4><p>文本查询系统的一件麻烦事情就是需要识别不同时态的同一个词如cry cries 和cried不同数目的同一个词如baby babies 以及大小写不同的同一个词如home 和Home。</p>
<h4 id="其他string操作"><a href="#其他string操作" class="headerlink" title="其他string操作"></a>其他string操作</h4><p>erase():</p>
<p>​    1.指定位置删除字符串元素。</p>
<p>​    2.利用一对迭代器来删除字符串元素。</p>
<p>​    3.利用单个迭代器来删除字符串元素。</p>
<p>insert():</p>
<p>​    1.将另外的字符插入到指定的位置。</p>
<p>​    2.支持插入new_string 的一个子部分。</p>
<p>assign()、append()：</p>
<p>​    1.把一个string 对象的部分拷贝或连接到另一个string 对象上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s3.assign( s1, 0, 4 ).append( &#x27; &#x27; ).append( s2, 0, 4 );</span><br></pre></td></tr></table></figure>

<p>swap()：</p>
<p>​    1.交换两个string 的值。</p>
<p>at():</p>
<p>​    1.对索引值的范围检查如果索引是有效的则at()返回相关的字符元素与下标操作符的方式相同但是如果索引无效则at()抛出out_of_range 异常.</p>
<p>compare():</p>
<p>​    1.提供了两个字符串的字典序比较</p>
<p>replace():</p>
<p>​    1.用一个或多个字符替换字符串中的一个或多个现有的字符(现有字符与替换字符的数目可以不等).</p>
<h4 id="生成文本位置map"><a href="#生成文本位置map" class="headerlink" title="生成文本位置map"></a>生成文本位置map</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">string query(&quot;pickle&quot;)</span><br><span class="line">vector&lt;location&gt; *locat;</span><br><span class="line">//返回与“pickle”相关的vector&lt;location&gt;*</span><br><span class="line">locat = text_map[ query ];</span><br></pre></td></tr></table></figure>

<p>6.12.1 定义并生成map</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#为了定义map对象，要指明键值对的类型。</span><br><span class="line">map&lt;strint, int&gt; word_count;</span><br><span class="line"></span><br><span class="line">class employee;</span><br><span class="line">map&lt;int, employee*&gt; personnel;</span><br></pre></td></tr></table></figure>

<p>用下标操作符把map 初始化至一组元素集合会使每个值都被初始化为缺省值,然后再被赋值为显式的值如果元素是类对象而且它的缺省初始化和赋值的运算量都很大,就会影响程序的性能尽管不会影响程序的正确性。</p>
<p>有两种情况需要考虑<br>1.map 中还没有单词在这种情况下需要插入键/值对<br>2.单词已经被插入在这种情况下需要用另外的行列信息修改该项的位置vector</p>
<p>6.12.2 查找并获取map中的元素</p>
<p>1.Count(keyValue) ：</p>
<p>count()返回map 中keyValue 出现的次数，当然对于map而言返回值只能是0 或1。如果返回值非0 我们就可以安全地使用下标操作符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ( word_count.count( &quot;wrinkles&quot; ))</span><br><span class="line">	count = word_count[ &quot;wrinkles&quot; ];</span><br></pre></td></tr></table></figure>

<p>2.Find(keyValue) ：</p>
<p>如果实例存在则find()返回指向该实例的iterator ，如果不存在则返回等于end()的iterator。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ( it != word_count.end() )</span><br><span class="line">	count = (*it).second;</span><br></pre></td></tr></table></figure>

<p>指向map 中元素的iterator 指向一个pair 对象，其中first 拥有键， second 拥有值。</p>
<p>6.12.3 对map 进行迭代</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ( ! text_map-&gt;empty() )</span><br><span class="line">	display_map_text( text_map );</span><br></pre></td></tr></table></figure>

<p>可以通过迭代器从begin() 到 end()来遍历map。</p>
<p>6.12.4 单词转换map</p>
<p>结合以上几节实现将单词存到map。</p>
<p>6.12.5 从map中删除元素</p>
<p>​    从map 中删除元素的erase()操作有三种变化形式，为了删除一个独立的元素，我们传递给erase()一个键值或iterator，为了删除一列元素我们传递给erase()一对lieator。</p>
<h4 id="创建单词排除集"><a href="#创建单词排除集" class="headerlink" title="创建单词排除集"></a>创建单词排除集</h4><p>​    当只想知道一个值是会存在时set 是最合适的。set 的操作可以与map的进行对比。</p>
<p>6.13.1 定义set 并放入元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;set&gt;</span><br><span class="line">set&lt;string&gt; exclusion_set.</span><br><span class="line">#插入元素</span><br><span class="line">exclusion_set.insert( &quot;the&quot; );</span><br><span class="line">exclusion_set.insert( &quot;and&quot; );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6.13.2 搜索一个元素</p>
<p>同样也是find()和count()函数。</p>
<p>6.13.3 迭代一个set 对象、</p>
<p>set 只能含有每个键值的惟一实例，所以可用来保证同一元素指挥出现一次。</p>
<p>set 支持操作size() empty()和erase() 同上节描述的map 类型相同另外泛型算法提<br>供了一组set 特有的函数如set_union()和set_difference() 我们将在第17 章利用它们来支<br>持查询语言</p>
<h4 id="完整的程序"><a href="#完整的程序" class="headerlink" title="完整的程序"></a>完整的程序</h4><p>详情见github仓库。</p>
<h4 id="multimap-和multiset"><a href="#multimap-和multiset" class="headerlink" title="multimap 和multiset"></a>multimap 和multiset</h4><p>map 和set 只能包含每个键的单个实例而multiset 和multimap 允许要被存储的键出现<br>多次.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line">multimap&lt; key_type, value_type &gt; multimapName;</span><br><span class="line">// 按string 索引, 存有list&lt;string&gt;</span><br><span class="line">multimap&lt; string, list&lt; string &gt; &gt; synonyms;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">multiset&lt; type &gt; multisetName;</span><br></pre></td></tr></table></figure>

<p>如何迭代？</p>
<p>​        一种迭代策略是联合使用由find()返回的iterator（指向第一个实例和由count()返回的值）。</p>
<p>更精彩的策略是使用由multiset 和multimap 的特殊操作equal_range()返回的iterator 对值。如果这个值存在则iteratior对中的第一个iterator 指向该值的第一个实例且第二个iterator 指向这个值的最后实例的下一位置。如果最后的实例是multiset 的末元素则第二个iterator 等于end()。</p>
<p>​        插入和删除操作与关联容器set 和map 相同，equal_range()可以用来提供iterator 对。以便标记出要被删除的多个元素的范围。</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈容器支持的操作：</p>
<p>empty():如果为空返回true，否则返回false。</p>
<p>size():返回栈中元素个数。</p>
<p>pop():删除，但不返回栈顶元素。</p>
<p>top():返回，但不删除栈顶元素。</p>
<p>push(item):放入新的栈顶元素。</p>
<p>头文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stack&gt;</span><br></pre></td></tr></table></figure>

<p>​        栈类型被称为容器适配器（container adapter），因为它把栈抽象施加在底层容器集上缺省情况下栈用容器类型deque ，实现因为deque为容器前端的插入和删除提供了有效支持，而vector 则不。也可以显示的定义所用的底层容器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack&lt; int, list&lt;int&gt; &gt; intStack;</span><br></pre></td></tr></table></figure>

<h4 id="队列和优先级队列"><a href="#队列和优先级队列" class="headerlink" title="队列和优先级队列"></a>队列和优先级队列</h4><p>​        队列抽象体现了先进先出的存储和检索策略。进入队列的对象被放在尾部下一个被取出的元素取自队列的首部。</p>
<p>​        标准库提供了两种风格的队列：FIFO 队列 和 priority_queue 优先级队列    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;queue&gt;</span><br></pre></td></tr></table></figure>

<p>empty():如果为空返回true，否则返回false。</p>
<p>size():返回栈中元素个数。</p>
<p>pop():删除，但不返回栈顶元素。在priority_queue 中队首元素代表优先级最高的元素.</p>
<p>front:返回，但不删除栈顶元素。它只能应用在一般队列上.<br>back():返回，但不删除队尾元素。它只能应用在一般队列上.<br>top() 返回但不删除priority_queue 的优先级最高的元素只能应用在priority_queue 上.push(item):在队尾放入一个新元素对于priority_queue 将根据优先级排序.</p>
<p>priority_queue 的元素被强加了顺序关系,以便元素可以从大到小管理。这里所谓最大即<br>等价于拥有最高优先级。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 3.1</title>
    <url>/%E5%AD%A6%E4%B9%A0/Cpp/cppPrimer/cppPrimerCh03_1/</url>
    <content><![CDATA[<p> C++ Primer 第三篇第七章学习笔记。<span id="more"></span></p>
<h1 id="第三篇-基于过程的程序设计"><a href="#第三篇-基于过程的程序设计" class="headerlink" title="第三篇  基于过程的程序设计"></a>第三篇  基于过程的程序设计</h1><h2 id="第七章-函数"><a href="#第七章-函数" class="headerlink" title="第七章 函数"></a>第七章 函数</h2><p>函数声明由函数返回类型、函数名、和参数表构成。这三个元素被称为函数声明或函数原型。一个函数可在一个文件中被声明多次。</p>
<p>函数类型和内置数组类型不能用作返同类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 非法: 数组不能作返回类型</span><br><span class="line">int[10] foo_bar();</span><br><span class="line">// ok: 指向数组的第一个元素的指针</span><br><span class="line">int *foo_bar();</span><br></pre></td></tr></table></figure>

<p>类类型和容器类型可以被直接返回，但是效率很低。</p>
<p>为了修改实参，有两种方法：</p>
<p>​        1.参数被声明成指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// pswap()交换v1 和v2 指向的值</span><br><span class="line">void pswap( int *v1, int *v2 ) &#123;</span><br><span class="line">	int tmp = *v2;</span><br><span class="line">	*v2 = *v1;</span><br><span class="line">	*v1 = tmp;</span><br><span class="line">&#125;</span><br><span class="line">//调用</span><br><span class="line">pswap( &amp;i, &amp;j );</span><br></pre></td></tr></table></figure>

<p>​        2.参数声明成引用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// rswap() 交换v1 和v2 引用的值</span><br><span class="line">	void rswap( int &amp;v1, int &amp;v2 ) &#123;</span><br><span class="line">	int tmp = v2;</span><br><span class="line">	v2 = v1;</span><br><span class="line">	v1 = tmp;</span><br><span class="line">&#125;</span><br><span class="line">//调用</span><br><span class="line">rswap( i, j );</span><br></pre></td></tr></table></figure>

<p>如果一个参数可能在函数中指向不同的对象，或者这个参数可能不指向任何对象，则必须使用指针参数。</p>
<p>引用参数的一个重要用法是，它允许我们在有效地实现重载操作符的同时，还能保证用法的直观性。</p>
<h3 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h3><p>有时候我们无法列出传递给函数的所有实参的类型和数目。在这种情况下我们可以用省略号指定函数参数表。</p>
<p>省略号挂起类型检查机制。它们的出现告知编译器当函数被调用时可以有0 个或多个实参，而实参的类型未知。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void foo( parm_list, ... );</span><br><span class="line">void foo( ... );</span><br></pre></td></tr></table></figure>

<p>此外：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void f();</span><br><span class="line">void f(...);</span><br><span class="line">//声明不等价。</span><br></pre></td></tr></table></figure>

<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>当声明一个返回引用的函数时，程序员应当知道下面两个易犯的错误：</p>
<p>​    1. 返回一个指向局部对象的引用，局部对象的生命期随函数的结束而结束。在函数结束后该引用变成未定义内存的别名。</p>
<p>​    2.函数返回一个左值，对返回值的任何修改都将改变被返回的实际对象。为防止对引用返回值的无意修改，返回值应该被声明为const。</p>
<h3 id="inline函数"><a href="#inline函数" class="headerlink" title="inline函数"></a>inline函数</h3><p>调用函数比直接计算条件操作符要慢得多。inline 内联函数给出了一种解决方案。若一个函数被指定为inline 函数，则它将在程序中每个调用点上被内联地展开。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inline int min( int v1, int v2 ) &#123; </span><br><span class="line">	//do some thing.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>inline 机制用来优化,小的只有几行的,经常被调用的函数.</p>
<p>inline 函数对编译器而言必须是可见的,以便它能够在调用点内联展开.该函数与非inline函数不同的是.inline 函数必须在调用该函数的每个文本文件中定义.</p>
<h3 id="链接指示符-extern-“C”"><a href="#链接指示符-extern-“C”" class="headerlink" title="链接指示符:  extern “C”"></a>链接指示符:  extern “C”</h3><p>​        用链接指示符告诉编译器,该函数是用其他的程序设计语言编写的.链接指示符有两种形式:  既可以是单一语句形式也可以是复合语句形式.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 单一语句形式的链接指示符</span><br><span class="line">extern &quot;C&quot; void exit(int);</span><br><span class="line">// 复合语句形式的链接指示符</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">    int printf( const char* ... );</span><br><span class="line">    int scanf( const char* ... );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链接指示符不能出现在函数体中，把链接指示符放在头文件中更合适。</p>
<h3 id="处理命令行选项"><a href="#处理命令行选项" class="headerlink" title="处理命令行选项"></a>处理命令行选项</h3><p>命令行选项是main()的实参，在main()函数中，我们可以通过一个名为argv 的C 风格字符串数组访问它。</p>
<p>最好是把处理命令行选项的细节封装起来，使得它不会扰乱main()。</p>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>当一个函数名没有被调用操作符修饰时，会被解释成指向该类型函数的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lexicoCompare;</span><br><span class="line">//会被解释成类型</span><br><span class="line">//int (*)( const string &amp;, const string &amp; );</span><br><span class="line">//将取地址操作符作用在函数名上也能产生指向该函数类型的指针</span><br><span class="line">&amp;lexicoCompare;</span><br></pre></td></tr></table></figure>

<p>函数指针可以用0 来初始化或赋值，以表示该指针不指向任何函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int (*pfi2s)( const string &amp;, const string &amp; ) = 0;</span><br></pre></td></tr></table></figure>

<p>指向函数的指针可以被用来调用它所指向的函数，调用函数时，不需要解引用操作符，无论是用函数名直接调用函数，还是用指针间接调用函数，两者的写法是一样的。</p>
<h4 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int (*testCases[10])();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// typedefs 使声明更易读</span><br><span class="line">typedef int (*PFV)(); // 定义函数类型指针的typedef</span><br><span class="line">PFV testCases[10];</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 3.2</title>
    <url>/%E5%AD%A6%E4%B9%A0/Cpp/cppPrimer/cppPrimerCh03_2/</url>
    <content><![CDATA[<p>C++primer第三篇第八章学习笔记。<span id="more"></span></p>
<h1 id="第三篇-基于过程的程序设计"><a href="#第三篇-基于过程的程序设计" class="headerlink" title="第三篇 基于过程的程序设计"></a>第三篇 基于过程的程序设计</h1><h2 id="第八章-域和生命期"><a href="#第八章-域和生命期" class="headerlink" title="第八章  域和生命期"></a>第八章  域和生命期</h2><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>C++支持三种形式的域局部域、名字空间域、以及类域。</p>
<h4 id="局部域"><a href="#局部域" class="headerlink" title="局部域"></a>局部域</h4><p>局部域是包含在函数定义或者函数块中的程序文本部分。每一个函数都有一个独立的局部域，在函数中的每个复合语句或块也有一个独立的局部域。、</p>
<p>局部域内的名字解析：首先查找使用该名字的域，如果找到一个声明，则该名字被解析。如果没有找到，则查找包含该域的域这个过程会一直继续下去直到找到<br>一个声明或已经查找完整个全局域如果后一种情况发生 即没有找到该名字的声明则这<br>个名字的用法将被标记为错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int low;</span><br><span class="line">int binSearch( const vector&lt;int&gt; &amp;vec, int val )&#123;</span><br><span class="line">    // low 的局部声明</span><br><span class="line">    // 隐藏了全局域中的声明</span><br><span class="line">    int low = 0;</span><br><span class="line">    // ...</span><br><span class="line">    // low 是局部变量</span><br><span class="line">    while ( low &lt;= high )&#123; </span><br><span class="line">    	// ...</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="名字空间域"><a href="#名字空间域" class="headerlink" title="名字空间域"></a>名字空间域</h4><p>名字空间域是不包含在函数声明、函数定义或者类定义内的程序文本部分。程序的最外层的名字空间域被称作全局域。对象、函数、类型以及模板都可以在全局域中定义，程序员也可以利用名字空间定义来定义用户声明的的名字空间。它们被嵌套在全局域内，每个用户声明的名字空间都是一个不同的域，它们都与全局域不同，与全局域相同的是，用户声明的名字空间，可以包含对象、函数、类型和模板的声明与定义，以及被嵌套其内的用户声明的名字空间。</p>
<h4 id="类域"><a href="#类域" class="headerlink" title="类域"></a>类域</h4><p>每个类定义都引入了一个独立的类域。</p>
<h4 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h4><p>在一个程序中，一个全局对象只能有一个定义，因为在使用文件中的对象之前必须先要声明这个对象，所以对于一个由多个文件构成的程序来说，它应该能够只声明一个对象而不定义它。</p>
<p>关键字extern 为声明但不定义一个对象提供了一种方法，实际上它类似于函数声明，承诺了该对象会在其他地方被定义，或者在此文本文件中的其他地方，或者在程序的其他文本文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern int i;</span><br></pre></td></tr></table></figure>

<h4 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h4><p>在局部域中的变量声明引入了局部对象。有三种局部对象：自动对象、寄存器对象以及局部静态对象。<br>区分这些对象的是对象所在存储区的属性和生命期。自动对象所在存储区从声明它的函数被调用时开始一直到该函数结束为止。寄存器对象是一种自动对象，它支持对其值的快速存。取局部静态对象的存储区在该程序的整个执行期间一直存在。</p>
<h4 id="动态分配的对象"><a href="#动态分配的对象" class="headerlink" title="动态分配的对象"></a>动态分配的对象</h4><p>动态分配的对象允许程序员完全控制它的分配与释放。动态分配的对象，被分配在程序的空闲存储区的可用内存池中。</p>
<h5 id="单个对象的分配与释放"><a href="#单个对象的分配与释放" class="headerlink" title="单个对象的分配与释放"></a>单个对象的分配与释放</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *pi = new int;</span><br></pre></td></tr></table></figure>

<p>在运行时刻，从空闲存储区中分配内存，比如通过上面的new 表达式我们称之为动态内存分配，们说pi 指向的内存是被动态分配的。</p>
<p>下面三个常见程序错误都与动态内存分配有关：<br>1 应用delete 表达式失败，使内存无法返回空闲存储区，这被称作内存泄漏。<br>2 对同一内存区应用了两次delete 表达式，这通常发生在两个指针指向同一个动态分配对象的时候，这是一个很难踉踪的问题，若多个指针指向同一个对象，当通过某一个指针释放了该对象时，就会发生这样的情况，此时该对象的内存被返回给空闲存储区，然后又被分配给某个别的对象，接着指向旧对象的第二个指针被释放，新对象也就跟着消失了。<br>3 在对象被释放后读写该对象这常常会发生因为delete 表达式应用的指针没有被设置为0。</p>
<h4 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h4><p>auto_ptr 是C++标准库提供的类模板,它可以帮助程序员自动管理用new 表达式动态分配的单个对象.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;memory&gt;</span><br><span class="line">auto_ptr&lt; type_pointed_to &gt; identifier( ptr_allocated_by_new );</span><br><span class="line">auto_ptr&lt; type_pointed_to &gt; identifier( auto_ptr_of_same_type );</span><br><span class="line">auto_ptr&lt; type_pointed_to &gt; identifier;</span><br><span class="line">//type_pointed_to 代表由new 表达式创建的对象的类型</span><br></pre></td></tr></table></figure>

<h4 id="数组的动态分配与释放"><a href="#数组的动态分配与释放" class="headerlink" title="数组的动态分配与释放"></a>数组的动态分配与释放</h4><p>new 表达式也可以在空闲存储区中分配数组，在这种情况下new 表达式中的类型指示符后面必须有一对方括号，里面的维数是数组的长度，且该组数可以是一个复杂的表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//分配单个int类型对象</span><br><span class="line">int *Pi =  new int(1024)</span><br><span class="line">//分配一个含有1024个元素的数组</span><br><span class="line">int *pia = new int[1024]</span><br><span class="line">//分配一个含 4x1024 个元素的二维数组</span><br><span class="line">int (*pia2)[ 1024 ] = new int[ 4 ][ 1024 ];</span><br><span class="line">delete [] pia;</span><br></pre></td></tr></table></figure>

<p>动态分配数组的主要好处是：它的第一维不必是常量值，即在编译时刻不需要知道维数，就像局部域或全局域中的定义所引入的数组的维数一样。</p>
<p>对于用new 表达式分配的数组，只有第一维可以用运行时刻计算的表达式来指定，其他维必须是在编译时刻已知的常量值。</p>
<h4 id="常量对象的动态分配与释放"><a href="#常量对象的动态分配与释放" class="headerlink" title="常量对象的动态分配与释放"></a>常量对象的动态分配与释放</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int *pci = new const int(1024);</span><br><span class="line">delete pci;</span><br></pre></td></tr></table></figure>

<p>首先const 对象必须被初始化如果省略了括号中的初始值,就会产生编译错误,除此之外,对于具有缺省构造函数的class类型的对象,初始值可以省略.第二,用 new 表达式返回的值,作为初始值的指针,必须是一个指向const 类型的指针.</p>
<h4 id="定位new-表达式"><a href="#定位new-表达式" class="headerlink" title="定位new 表达式"></a>定位new 表达式</h4><p>new 表达式的第三种形式,可以允许程序员要求将对象创建在已经被分配好的内存中,这种形式的new 表达式被称为定位new 表达式.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;new&gt;</span><br><span class="line">new (place_address) type -specifier</span><br></pre></td></tr></table></figure>

<p>不存在与定位new 表达式相匹配的delete 表达式.</p>
<h3 id="名字空间定义"><a href="#名字空间定义" class="headerlink" title="名字空间定义"></a>名字空间定义</h3><p>名字空间允许我们更好地处理全局名字空间污染问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">namespace cplusplus_primer &#123;</span><br><span class="line">    class matrix &#123; /* ... */ &#125;;</span><br><span class="line">    void inverse ( matrix &amp; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一个名字空间内声明的实体被称为名字空间成员。名字空间成员的名字会自动地与该名字空间名复合或被其限定修饰。</p>
<p>名字空间的定义可以非连续，这对生成一个库很有帮助，它使我们更容易将库的源代码组织成接口和实现部分。</p>
<p>名字空间的定义可以嵌套。</p>
<h4 id="未命名的名字空间"><a href="#未命名的名字空间" class="headerlink" title="未命名的名字空间"></a>未命名的名字空间</h4><p>用未命名的名字空间可以用来声明一个局部于某一文件的实体。未命名的名字空间以关键字namespace 开头。后面直接跟花括号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ----- SortLib.C -----</span><br><span class="line">    namespace &#123;</span><br><span class="line">    void swap( double *d1, double *d2 ) &#123; /* ... */ &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于未命名名字空间的成员是程序实体，所以函数swap()可以在程序整个执行期间被调用，但是未命名名字空间成员名只在特定的文件中可见，在构成程序的其他文件中是不可见的。</p>
<p>在引入标准C++名字空间之前，解决此类声明局部化问题的常见方案是使用从C 语言中继承来的关键字static 。</p>
<h3 id="使用名字空间成员"><a href="#使用名字空间成员" class="headerlink" title="使用名字空间成员"></a>使用名字空间成员</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">namespace International_Business_Machines&#123;</span><br><span class="line">	/* ... */ </span><br><span class="line">&#125;</span><br><span class="line">namespace IBM = International_Business_Machines;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//通过使名字空间成员的名字可见来在程序中用该名字的非限定修饰方式引用这个成员</span><br><span class="line">//而不用前缀namespace_name::name</span><br><span class="line">namespace cplusplus_primer &#123;</span><br><span class="line">    namespace MatrixLib &#123;</span><br><span class="line">        class matrix &#123; /* ... */ &#125;;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">using cplusplus_primer::MatrixLib::matrix;  </span><br></pre></td></tr></table></figure>

<p>与其他声明一样,using 声明引入的名字有以下特性:</p>
<p>1.它在该域中必须惟一.<br>2.由外围域中的声明引入的相同名字被其隐藏.<br>3.它被嵌套域中的相同名字的声明隐藏.</p>
<p>using 声明使名字空间成员易于使用.</p>
<p><strong>using指示符</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// using 指示符: cplusplus_primer 的所有成员都变成可见的</span><br><span class="line">using namespace cplusplus_primer;</span><br></pre></td></tr></table></figure>

<p>使用多个using 指示符会引起全局名字空间污染问题，用多个选择性的using 声明来代替using 指示符会使这个问题最小化，由多个选择性的using 声明引起的二义性错误在声明点就能被检测到，因此建议使用using 声明而不是using 指示符以便更好地控制程序中的全局名字空间污染问题。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 3.4</title>
    <url>/%E5%AD%A6%E4%B9%A0/Cpp/cppPrimer/cppPrimerCh03_4/</url>
    <content><![CDATA[<p> C++ Primer 第三篇第十章学习笔记。<span id="more"></span></p>
<h1 id="第三篇-基于过程的程序设计"><a href="#第三篇-基于过程的程序设计" class="headerlink" title="第三篇 基于过程的程序设计"></a>第三篇 基于过程的程序设计</h1><h2 id="第十章-函数模板"><a href="#第十章-函数模板" class="headerlink" title="第十章  函数模板"></a>第十章  函数模板</h2><pre><code>     函数模板提供一种用来自动生成各种类型函数实例的算法。程序员对于函数接口参数和返回类型中的全部或者部分类型进行参数化， 而函数体保持不变。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;class T1, typename T2, int num&gt;</span><br><span class="line">//其中class、typename 是模板类型参数， int num 是非模板类型参数。</span><br></pre></td></tr></table></figure>

<p>在函数模板参数表中关键字typename 和class 的意义相同，可以互换，使用它们两个都可以被用来声明同一模板参数表中的不同模板类型参数。</p>
<h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>函数模板指定了怎样根据一组或更多实际类型或值构造出独立的函数。这个构造过程被称为模板实例化，这个过程是隐式发生的，它可以被看作是函数模板调用或取函数模板的地址的副作用。</p>
<p>用函数实参的类型来决定模板实参的类型和值的过程被称为模板实参推演。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 3.3</title>
    <url>/%E5%AD%A6%E4%B9%A0/Cpp/cppPrimer/cppPrimerCh03_3/</url>
    <content><![CDATA[<p> C++ Primer 第三篇第九章学习笔记。<span id="more"></span></p>
<h1 id="第三篇-基于过程的程序设计"><a href="#第三篇-基于过程的程序设计" class="headerlink" title="第三篇 基于过程的程序设计"></a>第三篇 基于过程的程序设计</h1><h2 id="第九章-重载函数"><a href="#第九章-重载函数" class="headerlink" title="第九章 重载函数"></a>第九章 重载函数</h2><p>函数重载 允许多个函数共享同一个函数名但是针对不同参数类型提供共同的操作。</p>
<p>如果两个函数的函数名相同，而参数表中参数的个数或类型不同则认为这两个函数是重载的。</p>
<p>函数的返回类型不足以区分两个重载函数。</p>
<p>当一个参数类型是const 或volatile 时在识别函数声明是否相同时并不考虑const 和volatile 修饰符。</p>
<p>但是，如果把const 或volatile 应用在指针或引用参数指向的类型上，则在判断函数声明是否相同时，就要考虑const 和volatile 修饰符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 声明了不同的函数</span><br><span class="line">void f( int* );</span><br><span class="line">void f( const int* );</span><br><span class="line">// 也声明了不同的函数</span><br><span class="line">void f( int&amp; );</span><br><span class="line">void f( const int&amp; );</span><br></pre></td></tr></table></figure>

<p>重载函数集合中的全部函数都应在同一个域中声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">void print( const string &amp; );</span><br><span class="line">void print( double ); // overloads print()</span><br><span class="line">void fooBar( int ival )</span><br><span class="line">&#123;</span><br><span class="line">    // 独立的域隐藏print()的两个实例</span><br><span class="line">    extern void print( int );</span><br><span class="line">    // 错误: print( const string &amp; )在这个域中被隐藏</span><br><span class="line">    print( &quot;Value : &quot; );</span><br><span class="line">    print( ival ); // ok: print( int ) 可见</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// using 声明</span><br><span class="line">using libs_R_us::max;</span><br><span class="line">using libs_R_us::print( double ); // 错误</span><br><span class="line">//用户不能在using 声明中为一个函数指定参数表</span><br></pre></td></tr></table></figure>

<h3 id="重载解析"><a href="#重载解析" class="headerlink" title="重载解析"></a>重载解析</h3><p>函数重载解析是把函数调用与重载函数集合中的一个函数相关联的过程，在存在多个同名函数的情况下，根据函数调用中指定的实参，选择其中一个函数。</p>
<p>函数重载解析的步骤如下：<br>    1 确定函数调用考虑的重载函数的集合确定函数调用中实参表的属性。<br>    2 从重载函数集合中选择函数该函数可以在给出实参个数和类型的情况下用调用中指定的实参进行调用。<br>    3 选择与调用最匹配的函数。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 3.5</title>
    <url>/%E5%AD%A6%E4%B9%A0/Cpp/cppPrimer/cppPrimerCh03_5/</url>
    <content><![CDATA[<p> C++ Primer 第三篇第十一章学习笔记。<span id="more"></span></p>
<h1 id="第三篇-基于过程的程序设计"><a href="#第三篇-基于过程的程序设计" class="headerlink" title="第三篇 基于过程的程序设计"></a>第三篇 基于过程的程序设计</h1><h2 id="第十一章-异常处理"><a href="#第十一章-异常处理" class="headerlink" title="第十一章 异常处理"></a>第十一章 异常处理</h2><p>C++程序中出现异常时检测到异常的程序段可以通过产生raise 或抛出throw 异常来通知 “异常已经发生”。</p>
<p>通过throw 语句抛出异常对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ( empty() )</span><br><span class="line">	throw popOnEmpty();</span><br><span class="line">//必须是对象。</span><br></pre></td></tr></table></figure>

<p>try 块必须包围能够抛出异常的语句try 块，以关键字try 开始，后面是花括号括起来的语句序列，在try 块之后是一组处理代码被称为catch 子句，try 块把语句分成组，并将其与相应地处理这些语句可能抛出的异常的处理语句相关联。</p>
<p>程序的控制流是下列几种情况之一：<br>1.如果没有异常发生则执行try 块中的代码和try 块相关联的处理代码被忽略程序main()返回0.</p>
<p>2.如果try块中的语句发生错误。则跳到catch语句执行对应的异常操作。</p>
<p>​      当某条语句抛出异常时，跟在该语句后面的语句将被跳过。程序执行权被转交给处理异常的catch 子句，如果没有catch 子句能够处理该异常，则程序执行权又将被转交给C++标准库中定义的函数。</p>
<p>​    try 块可以包含任何C++语句——表达式以及声明，一个try 块引入一个局部域，在try块内声明的变量不能在try 块外被引用，包括在catch 子句中。</p>
<p>​    C++的异常处理机制被称为是不可恢复的， 一旦异常被处理，程序的执行就不能够在异常被抛出的地方继续。</p>
<h3 id="异常声明"><a href="#异常声明" class="headerlink" title="异常声明"></a>异常声明</h3><p>​    catch 子句的异常声明可以是一个类型声明或一个对象声明。</p>
<p>​    当我们要获得throw 表达式的值，或者要操纵throw 表达式所创建的异常对象时，我们应该声明一个对象。当该异常被抛出时，我们把信息存储在异常对象中，如果catch 子句的异常声明声明了一个对象，则catch 子句中的语句就可以用该对象来引用由throw 表达式存储的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 新异常类:</span><br><span class="line">// 负责保存不能被压入到栈中的值</span><br><span class="line">class pushOnFull &#123;</span><br><span class="line">public:</span><br><span class="line">    pushOnFull( int i ) : _value( i ) &#123; &#125;</span><br><span class="line">    int value() &#123; return _value; &#125;</span><br><span class="line">private:</span><br><span class="line">    int _value;</span><br><span class="line">&#125;;</span><br><span class="line">void iStack::push( int value )</span><br><span class="line">&#123;</span><br><span class="line">    if ( full() )</span><br><span class="line">    // 把value 存储在异常对象中</span><br><span class="line">    throw pushOnFull( value );</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">catch ( pushOnFull eObj ) &#123;</span><br><span class="line">    cerr &lt;&lt; &quot;trying to push the value &quot; &lt;&lt; eObj.value()</span><br><span class="line">    &lt;&lt; &quot; on a full stack\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与函数参数的情形一样,catch 子句中的异常声明也可以被改变成引用声明,于是catch子句就可以直接引用由throw 表达式创建的异常对象,而不是创建一个局部拷贝了.为了防止不必要地拷贝大型类对象,class 类型的参数应该被声明为引用.<br>        在查找用来处理被抛出异常的catch 子句时因为异常而退出复合语句和函数定义这个过程被称作栈展开.</p>
<h3 id="catch-all"><a href="#catch-all" class="headerlink" title="catch-all"></a>catch-all</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 对任何异常都会进人</span><br><span class="line">catch ( ... ) &#123;</span><br><span class="line">    // 这里是我们的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常规范"><a href="#异常规范" class="headerlink" title="异常规范"></a>异常规范</h3><p>​        异常规范提供了一种方案，它能够随着函数声明，列出该函数可能抛出的异常，它保证该函数不会抛出任何<br>其他类型的异常。</p>
<p>​        异常规范跟随在函数参数表之后，它用关键字throw ，来指定后面是用括号括起来的异常类型表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class iStack &#123;</span><br><span class="line">public:</span><br><span class="line">    // ...</span><br><span class="line">void pop( int &amp;value ) throw(popOnEmpty);</span><br><span class="line">void push( int value ) throw(pushOnFull);</span><br><span class="line">private:</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 3.6</title>
    <url>/%E5%AD%A6%E4%B9%A0/Cpp/cppPrimer/cppPrimerCh03_6/</url>
    <content><![CDATA[<p> C++ Primer 第三篇第十二章学习笔记。<span id="more"></span></p>
<h1 id="第三篇-基于过程的程序设计"><a href="#第三篇-基于过程的程序设计" class="headerlink" title="第三篇 基于过程的程序设计"></a>第三篇 基于过程的程序设计</h1><h2 id="第十二章-泛型算法"><a href="#第十二章-泛型算法" class="headerlink" title="第十二章 泛型算法"></a>第十二章 泛型算法</h2><p>​        每个泛型算法的实现都独立于单独的容器类型，因为已经消除了算法的类型依赖性，所以单个的模板实例可以操作在各种容器以及内置数组类型上。</p>
<p>泛型算法一般支持两种形式来应用操作：</p>
<p>​    1.使用内置或可能是被重载的操作符</p>
<p>​    2.使用函数指针或函数对象执行操作</p>
<h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><p>函数对象与函数指针相比较有两个方面的优点：</p>
<p>首先如果被重载的调用操作符是inline函数，则编译器能够执行内联编译，提供可能的性能好处。</p>
<p>其次函数对象可以拥有任意数目的额外数据，用这些数据可以缓冲结果，也可以缓冲有助于当前操作的数据。</p>
<h4 id="三种来源"><a href="#三种来源" class="headerlink" title="三种来源"></a>三种来源</h4><p>1.标准库预定义的一组算术关系和逻辑函数对象。</p>
<p>预定义函数对象被分成算术关系和逻辑操作，每个对象都是一个类模板，其中操作数的类型被参数化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;functional&gt;</span><br><span class="line">plus&lt;int&gt; intAdd;</span><br><span class="line">int sum = intAdd(10, 20);</span><br><span class="line">//== sum = 10 + 20;</span><br></pre></td></tr></table></figure>

<p>主要用法是作为泛型算法的实参,通常被用来改变缺省的操作.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt; string &gt; svec;</span><br><span class="line">// ...</span><br><span class="line">sort( svec.begin(), svec.end(), greater&lt;string&gt;() );</span><br></pre></td></tr></table></figure>

<p>预定义的函数对象被分成算术、关系和逻辑三大类别。</p>
<p>标准库还提供了一组函数适配器，用来特殊化或者扩展一元和二元函数对象。适配器是一种特殊的类，它被分成下面两类：</p>
<p>1 绑定器：binder 通过把二元函数对象的一个实参绑定到一个特殊的值上，将其转换成一元函数对象。</p>
<p>例如为了计数一个容器中小于或等于10 的元素的个数，我们可能会向count_if()传递一个less_equal 函数对象以及一个被绑定为10 的实参。</p>
<p>2.取反器： negator 是一个将函数对象的值翻转的函数适配器。</p>
<p>例如为了计数一个容器中所有大于10 的元素的个数，我们可以向count_if()传递less_equal 函数对象的negator ，该函数对象有一个实参被绑定为10。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 03</title>
    <url>/%E5%AD%A6%E4%B9%A0/Cpp/cppPrimer/cppPrimerCh04/</url>
    <content><![CDATA[<p> C++ Primer 第四篇第十二章学习笔记。<span id="more"></span></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 4.1</title>
    <url>/%E5%AD%A6%E4%B9%A0/Cpp/cppPrimer/cppPrimerCh04_1/</url>
    <content><![CDATA[<p> C++ Primer 第四篇第十三章学习笔记。<span id="more"></span></p>
<h1 id="第四章-基于对象的程序设计"><a href="#第四章-基于对象的程序设计" class="headerlink" title="第四章 基于对象的程序设计"></a>第四章 基于对象的程序设计</h1><h2 id="第十三章-类"><a href="#第十三章-类" class="headerlink" title="第十三章 类"></a>第十三章 类</h2><h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h3><p>类定义包含两部分： 类头 + 类体。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Screen &#123; /* ... */ &#125;;</span><br><span class="line">class Screen &#123; /* ... */ &#125; myScreen, yourScreen;</span><br></pre></td></tr></table></figure>

<p>除了静态 数据成员外，数据成员不能在类体中被显式地初始化，类的数据成员通过类的构造函数进行初始化。</p>
<p>类成员的访问限制是通过类体内被标记为public、private 以及protected的部分来指定的。</p>
<p>关键字public private 和protected 被称为访问限定符。</p>
<p>在某些情况下，允许某个函数而不是整个程序可以访问类的私有成员这样做会比较方便。友元机制允许一个类授权其他的函数访问它的非公有成员。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Screen &#123;</span><br><span class="line">    friend istream&amp; operator&gt;&gt;( istream&amp;, Screen&amp; );</span><br><span class="line">    friend ostream&amp; operator&lt;&lt; ( ostream&amp;, const Screen&amp; );</span><br><span class="line">    public:</span><br><span class="line">    // ... Screen 类的其他部分</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>无论成员函数是在类体内还是外面，我们都说它在类域内。</p>
<p>这有两个含义：</p>
<p>1.成员函数的定义可以引用任何一个类成员，无论该成员是私有的还是公有的都不会破坏类访问限制。</p>
<p>2.成员函数可以直接访问它所属的类的成员，而无需使用点或箭头成员访问操作符。</p>
<p>只有被声明为const 的成员函数，才能被一个const 类对象调用。关键字const 被放在成员函数的参数表和函数体之间，对于在类体之外定义的const 成员函数，我们必须在它的定义和声明中同时指定关键字const。</p>
<p>构造函数和析构函数是两个例外，即使构造函数和析构函数不是const 成员函数，const类对象也可以调用它。</p>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>每个类成员函数都含有一个指向被调用对象的指针，这个指针被称为this。</p>
<p>为支持this 指针，必须要应用两个转变:</p>
<pre><code>1. 改变类成员函数的定义,用额外的参数this 指针,来定义每个成员函数.
2.  改变每个类成员函数的调用,加上一个额外的实参——被调用对象的地址.
</code></pre>
<h3 id="静态类成员"><a href="#静态类成员" class="headerlink" title="静态类成员"></a>静态类成员</h3><p>同全局对象相比,使用静态数据成员有两个优势:</p>
<p>1.静态数据成员没有进入程序的全局名字空间,因此不存在与程序中其他全局名字冲突的可能性<br>2.可以实现信息隐藏,静态成员可以是private 成员,而全局对象不能.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Account &#123;</span><br><span class="line">    Account( double amount, const string &amp;owner );</span><br><span class="line">    string owner() &#123; return _owner; &#125;</span><br><span class="line">private:</span><br><span class="line">    static double _interestRate;</span><br><span class="line">    double _amount;</span><br><span class="line">    string _owner;</span><br><span class="line">&#125;;</span><br><span class="line">// 静态类成员的显式初始化</span><br><span class="line">#include &quot;account.h&quot;</span><br><span class="line">double Account::_interestRate = 0.0589;</span><br></pre></td></tr></table></figure>

<p>静态数据成员的类型可以是其所属类,而非static 数据成员只能被声明为该类的对象的指针或引用.</p>
<p>静态数据成员可以被作为类成员函数的缺省实参,而非static 成员不能。</p>
<p>静态成员函数的声明，除了在类体中的函数声明前加上关键字static， 以及不能声明为const 或volatile 之外，与非静态成员函数相同，出现在类体外的函数定义不能指定关键字static。</p>
<h3 id="指向类成员的指针"><a href="#指向类成员的指针" class="headerlink" title="指向类成员的指针"></a>指向类成员的指针</h3><p>指向成员函数的指针必须与向其赋值的函数类型匹配：<br>1.参数的类型和个数</p>
<p>2.返回类型3</p>
<p>3.它所属的类类型</p>
<p>函数指针存储函数的地址,可以被用来直接调用那个函数.成员函数指针首先必须被绑定在一个对象或者一个指针上,才能得到被调用对象的this 指针,然后才调用指针所指的成员函数.</p>
<p>定义一个成员函数指针需要指定函数返回类型参数表和类.</p>
<p>静态类成员是属于该类的全局对象和函数,它们的指针是普通指针.</p>
<h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><p>一个类可以在另一个类中定义，这样的类被称为嵌套类。嵌套类是其外围类的一个成员，嵌套类的定义可以出现在其外围类的公有私有或保护区中。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 4.2</title>
    <url>/%E5%AD%A6%E4%B9%A0/Cpp/cppPrimer/cppPrimerCh04_2/</url>
    <content><![CDATA[<p> C++ Primer 第四篇第十四章学习笔记。<span id="more"></span></p>
<h1 id="第四篇-基于对象的程序设计"><a href="#第四篇-基于对象的程序设计" class="headerlink" title="第四篇  基于对象的程序设计"></a>第四篇  基于对象的程序设计</h1><h3 id="第十四章-类的初始化、赋值和析构"><a href="#第十四章-类的初始化、赋值和析构" class="headerlink" title="第十四章 类的初始化、赋值和析构"></a>第十四章 类的初始化、赋值和析构</h3><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数上惟一的语法限制是，它不能指定返回类型，甚至void 也不行。</p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>并不是每一个类都要求有析构函数，析构函数主要被用来放弃在类对象的构造函数或生命期中获得的资源，如释放互斥锁或删除由操作符new 分配的内存。</p>
<p>一般地，析构函数可以执行“类设计者希望在最后一次使用对象之后执行的任何操作”。</p>
<h3 id="类对象数组"><a href="#类对象数组" class="headerlink" title="类对象数组"></a>类对象数组</h3><p>类对象数组与内置类型数组的定义方式相同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Account table[ 16 ];</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 03</title>
    <url>/%E5%AD%A6%E4%B9%A0/Cpp/cppPrimer/cppPrimerCh04_3/</url>
    <content><![CDATA[<p> C++ Primer 第四篇第十五章学习笔记。<span id="more"></span></p>
<h1 id="第四篇-基于对象的程序设计"><a href="#第四篇-基于对象的程序设计" class="headerlink" title="第四篇 基于对象的程序设计"></a>第四篇 基于对象的程序设计</h1><h2 id="第十五章-重载操作符和用户定义的转换"><a href="#第十五章-重载操作符和用户定义的转换" class="headerlink" title="第十五章 重载操作符和用户定义的转换"></a>第十五章 重载操作符和用户定义的转换</h2><h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><p>操作符重载使得程序员能够为类类型的操作数定义预定义的操作符版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string&amp; operator=( const String &amp; );</span><br><span class="line">string&amp; operator=( const char * );</span><br></pre></td></tr></table></figure>

<p>重载的操作符在类体中被声明,声明方式同普通成员函数一样,只不过它的名字包含关键字operator ,以及紧随其后的一个预定义操作.</p>
<p>如果一个重载操作符是类成员，那么只有当跟它一起被使用的左操作数是该类的对象时，它才会被调用。</p>
<p>如果该操作符的左操作数必须是其他的类型，那么重载操作符必须是名字空间成员。</p>
<p>C++要求：赋值= 、下标[] 、调用() 和成员访问箭头-&gt; 操作符必须被定义为类成员操作符，任何把这些操作符定义为名字空间成员的定义都会被标记为编译时刻错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 错误: 必须是类成员</span><br><span class="line">char&amp; operator[]( String &amp; ,int ix );</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 5.1</title>
    <url>/%E5%AD%A6%E4%B9%A0/Cpp/cppPrimer/cppPrimerCh05_1/</url>
    <content><![CDATA[<p> C++ Primer 第五篇第十七章学习笔记。<span id="more"></span></p>
<h1 id="第五篇-面向对象的程序设计"><a href="#第五篇-面向对象的程序设计" class="headerlink" title="第五篇 面向对象的程序设计"></a>第五篇 面向对象的程序设计</h1><h2 id="第十七章-类继承和子类型"><a href="#第十七章-类继承和子类型" class="headerlink" title="第十七章 类继承和子类型"></a>第十七章 类继承和子类型</h2><p>如果基类和派生类共享相同的公有接口，则派生类被称作基类的子类型。</p>
<p>在C++中，存在特殊的类型/子类型关系，基类指针或引用可以直接引用其任何派生子类，而无需程序员介入，这种用基类的指针或引用，操纵多个类型的能力被称为多态。</p>
<p>子类多态性使得我们在编写应用程序的核心时，可以不用考虑将来需要维护的单个类型，我们利用基类指针和引用，对抽象的基类的公有接口进行编程。在运行时刻，真正要引用的类型被解析出来，并且调用适当的公有接口实例。</p>
<p>在运行时刻需要解析出被调用的函数，这个解析过程被称为动态绑定，缺省情况下，函数是在编译时刻被静态解析的，在C++中通过一种被称为虚拟函数的机制来支持动态绑定。</p>
<p>继承层次结构的主要好处是，我们可以针对抽象基类的公有接口进行编程，而不是针对组成继承层次的个别类型。通过这种方式我们的代码可以不受层次结构变化的影响</p>
<p>在C++中多态性只存在子类继承层次中。void*型的指针可以被描述为多态，但是语言本身并没有显式地支持它们——即它们必须由程序员自己来管理，程序员可以通过显式强制类型转换以及记录实际类型的判别式来做到这一点。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承关系通过类派生表c来指定。在单继承下它的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">: access-level base-class</span><br><span class="line">这里access-level 是public 、protected 或private 之一。</span><br></pre></td></tr></table></figure>

<p>声明时不用表明继承关系。实际实现时才需要实现实际关系。</p>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Query &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void eval() = 0;</span><br><span class="line">&#125;;</span><br><span class="line">class NameQuery : public Query &#123;</span><br><span class="line">public:</span><br><span class="line">    // ...</span><br><span class="line">    // 改写 virtual Query::eval() 实例29</span><br><span class="line">    void eval();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
