<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>cpp Primer chapter 2.1</title>
    <url>/%E5%AD%A6%E4%B9%A0/cppPrimerCh02_1/</url>
    <content><![CDATA[<p>C++ Primer 第二篇第三章学习笔记。<span id="more"></span></p>
<h1 id="第二篇-基本语言"><a href="#第二篇-基本语言" class="headerlink" title="第二篇 基本语言"></a>第二篇 基本语言</h1><h2 id="第三章-C-数字类型"><a href="#第三章-C-数字类型" class="headerlink" title="第三章 C++数字类型"></a>第三章 C++数字类型</h2><h3 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h3><p>其他语言常见的所有类型：</p>
<p>int, short, long int,  long long int, double, float, char,</p>
<p>如果一个变量是在全局域内定义的那么系统会保证给它提供初始值0.</p>
<p>如果变量是在局部域l内定义的,或是通过new 表达式动态分配的.则系统不会向它提供初始值0 .这些对象被称为是未初始化的.</p>
<p>每种内置数据类型都支持一种特殊的构造函数语法,可将对象初始化为0.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ival = int();</span><br><span class="line">double dval = double();</span><br></pre></td></tr></table></figure>

<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>不同之处在于指针所指的对象的类型上，指针的类型可以指示编译器怎样解释特定地址上内存的内容，以及该内存区域应该跨越多少内存单元。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; *p1, p2;</span><br><span class="line">//p1指针，p2不是。</span><br></pre></td></tr></table></figure>

<p>如果我们要做的仅仅是持有地址值，那么指针的实际类型就不重要了。</p>
<p>C++提供了一种特殊的指针类型来支持这种需求，空void* 类型指针，它可以被任何数据指针类型的地址值赋值(函数指针不能赋值给它).</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>string 类型能够自动将C 风格的字符串转换成string 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string s1;</span><br><span class="line">const char *pc = &quot;a character array&quot;;</span><br><span class="line">s1 = pc; // ok</span><br></pre></td></tr></table></figure>

<p>反向的转换不能自动执行，对隐式地将string 对象转换成C 风格的字符串string类型没有提供支持。</p>
<p>为了防止字符数组被程序直接处理，c_str()返回了一个指向常量数组的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const char *str = s1.c_str(); // ok</span><br></pre></td></tr></table></figure>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用， 有时候又称为别名alias 。它可以用作对象的另一个名字，通过引用，我们可以间接地操纵对象，使用方式类似于指针，但是不需要指针的语法。在实际的程序中引用主要被用作函数的形式参数——通常将类对象传递给一个函数。</p>
<p>引用类型由类型标识符和一个取地址操作符来定义，引用必须被初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ival = 1024;</span><br><span class="line">// ok: refVal 是一个指向ival 的引用</span><br><span class="line">int &amp;refVal = ival;</span><br><span class="line">// 错误引用必须被初始化为指向一个对象</span><br><span class="line">int &amp;refVal2;</span><br></pre></td></tr></table></figure>

<p>一旦引用已经定义，它就不能再指向其他的对象。</p>
<p>引用的所有操作实际上都被应用在它所指的对象身上，包括取地址操作符。</p>
<p>指针和引用有两个主要区别：</p>
<p>​    1.引用必须总是指向一个对象，如果用一个引用给另一个引用赋值，那么改变的是被引用的对象，而不是引用本身。</p>
<p>​    2.引用之间的赋值是第二个不同。</p>
<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>枚举不但定义了整数常量而且还把它们组成一个集合。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum open_modes&#123; input = 1, output, append &#125;;</span><br><span class="line">//input、output 和append 是枚举成员。它们代表了能用来初始化和赋值open_modes 类型变量的值的全集</span><br></pre></td></tr></table></figure>

<p>枚举的限制：</p>
<ol>
<li> 不能打印枚举成员的实际枚举名。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//解决方案</span><br><span class="line">cout &lt;&lt; open_modes_table[ input ] &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>  不能使用枚举成员进行迭代</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 不支持</span><br><span class="line">for ( open_modes  iter = input; iter != append; ++iter )&#123;</span><br><span class="line">	// ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="volatile-限定修饰符"><a href="#volatile-限定修饰符" class="headerlink" title="volatile 限定修饰符"></a>volatile 限定修饰符</h3><p>当一个对象的值可能会在编译器的控制或监测之外被改变时，例如一个被系统时钟更新的变量，那么该对象应该声明成volatile， 因此编译器执行的某些例行优化行为不能应用在已指定为volatile 的对象上。</p>
<p>volatile 修饰符的主要目的是提示编译器，该对象的值可能在编译器未监测到的情况下被改变，因此编译器不能武断地对引用这些对象的代码作优化处理。</p>
<h3 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h3><p>pair 类也是标准库的一部分，它使得我们可以在单个对象内部把相同类型或不同类型的两个值关联起来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;utility&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以用成员访问符号访问pair 中的单个元素,它们的名字为first 和second.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pair&lt; string, string &gt; author( &quot;James&quot;, &quot;Joyce&quot; );</span><br><span class="line">author.first == &quot;James&quot;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 2.2</title>
    <url>/%E5%AD%A6%E4%B9%A0/cppPrimerCh02_2/</url>
    <content><![CDATA[<p>C++ Primer 第二篇第四章学习笔记。<span id="more"></span></p>
<h1 id="第二篇-基本语言"><a href="#第二篇-基本语言" class="headerlink" title="第二篇 基本语言"></a>第二篇 基本语言</h1><h2 id="第二章-表达式"><a href="#第二章-表达式" class="headerlink" title="第二章  表达式"></a>第二章  表达式</h2><p>基本算术运算符、逻辑运算符、赋值运算符、条件运算符与其他语言一致。</p>
<h3 id="sizeof-操作符"><a href="#sizeof-操作符" class="headerlink" title="sizeof 操作符"></a>sizeof 操作符</h3><p>siseof 操作符的作用是返回一个对象或类型名的字节长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//三种用法</span><br><span class="line">sizeof (type name );</span><br><span class="line">sizeof ( object );</span><br><span class="line">sizeof object;</span><br></pre></td></tr></table></figure>

<p>返回值的类型是size_t ，这是一种与机器相关的typedef 定义。</p>
<p>应用在指针类型上的sizeof 操作符，返回的是包含该类型地址所需的内存长度。但是应用在引用类型上的sizeof 操作符。返回的是包含被引用对象所需的内存长度。</p>
<h3 id="new-和delete-表达式"><a href="#new-和delete-表达式" class="headerlink" title="new 和delete 表达式"></a>new 和delete 表达式</h3><p>系统为每个程序都提供了一个在程序执行时可用的内存池。这个可用内存池被称为程序的空闲存储区。</p>
<p>运行时刻的内存分配被称为动态内存分配。</p>
<p>动态内存分配由new 表达式应用在一个类型指示符上来完成。类型指示符可以是内置类型或用户定义类型。new 表达式返回指向新分配的对象的指针。 </p>
<p>delete 表达式应用在”<strong>指向我们用new 表达式分配的</strong>“对象指针上来做到这一点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *pi = new int(1024);</span><br><span class="line">delete pi;</span><br><span class="line">int *pin = new int[10];</span><br><span class="line">delete [] pin;</span><br></pre></td></tr></table></figure>

<h3 id="位操作符和bitset"><a href="#位操作符和bitset" class="headerlink" title="位操作符和bitset"></a>位操作符和bitset</h3><p>位操作符把操作数解释成有序的位集合，这些位可能是独立的也可能组成域，每个位可以含有0 off 或1 on 。位操作符允许程序员设置或测试独立的位或位域。如果一个对象被用作一组位或位域的离散集合那么这样的对象称为位向量 位。向量是一种用来记录一组项目或条件的是/否信息的紧缩方法</p>
<p>标准库提供了一个bitset 类它支持位向量的类抽象。bitset 对象封装了位向量的语义。</p>
<img src = "/images/cpp/bitset.png">

<p>bitset 有三种声明方式在缺省定义中我们只需简单地指明位向量的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bitset&gt;</span><br><span class="line">bitset&lt; 32 &gt; bitvec;</span><br><span class="line">//声明了一个含有32位的bitset 对象,位的顺序从0到31,缺省情况下所有的位都被初始化为0</span><br></pre></td></tr></table></figure>

<h3 id="强制类型装换"><a href="#强制类型装换" class="headerlink" title="强制类型装换"></a>强制类型装换</h3><p>强制类型转换很可能会引入一些难以发现的错误。尤其是(void *)类型的指针。</p>
<img src = "/images/cpp/cast.png">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//4种类型的转换的格式</span><br><span class="line">TYPE b = static_cast(TYPE)(a);</span><br></pre></td></tr></table></figure>

<p>C++为了规范C中的类型转换，加强类型转换的可视性，引入了四种强制类型转换操作符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static_cast, reinterpret_cast, const_cast, dynamic_cast </span><br></pre></td></tr></table></figure>

<p>他们本质上都是模板类。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 1.1</title>
    <url>/%E5%AD%A6%E4%B9%A0/cppPrimerCh01/</url>
    <content><![CDATA[<p> C++ Primer 第一篇学习笔记。<span id="more"></span></p>
<h1 id="第一篇-C-概述"><a href="#第一篇-C-概述" class="headerlink" title="第一篇 C++概述"></a>第一篇 C++概述</h1><h2 id="第一章-开始"><a href="#第一章-开始" class="headerlink" title="第一章  开始"></a>第一章  开始</h2><h3 id="C-支持多种程序设计方法："><a href="#C-支持多种程序设计方法：" class="headerlink" title="C++支持多种程序设计方法："></a>C++支持多种程序设计方法：</h3><p>​    过程化程序设计方法。　主要是函数。</p>
<p>　对抽象数据类型程序设计方法。　主要是类。</p>
<p>​    面向对象程序设计方法。　主要是继承和动态绑定。</p>
<h3 id="分而治之-和-逐步求精-的思想"><a href="#分而治之-和-逐步求精-的思想" class="headerlink" title="分而治之 和 逐步求精 的思想"></a>分而治之 和 逐步求精 的思想</h3><p>​        解决大问题的一种方法是，把它分解成许多小问题，理想情况下，这些小问题可以很容易地被解决，然后再把它们合在一起，就可以解决大问题了。如果新分割的小问题解决起来还是太大，就把它分割得再小一些，重复整个过程，直到能够解决每个小问题。</p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>​    C++标准库中的名字都是在一个称作std 的名字空间中声明的，这些名字在我们的程序文本文件中是不可见的，除非我们显式地使它们可见，using 指示符告诉编译器要使用在名字空间std 中声明的名字。</p>
<h3 id="预处理器指示符"><a href="#预处理器指示符" class="headerlink" title="预处理器指示符"></a>预处理器指示符</h3><p>如果文件名用尖括号&lt; 和&gt; 括起来表明这个文件是一个工程或标准头文件，查找过程会检查预定义的目录，我们可以通过设置搜索路径环境变量或命令行选项来修改这些目录。如果文件名用一对引号括起来。则表明该文件是用户提供的头文件查找该文件时将从当前文件目录开始。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;some_file.h&gt;</span><br><span class="line">#include &quot;my_file.h&quot;</span><br><span class="line"></span><br><span class="line">#ifndef BOOKSTORE_H</span><br><span class="line">#define BOOKSTORE_H</span><br><span class="line">/* Bookstore.h 的内容 */</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>编译C++程序时编译器自动定义了一个预处理器名字__cplusplus （注意前面有两个下划线）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef __cplusplus</span><br><span class="line">	// 我们要编译C++</span><br><span class="line">	// extern &quot;C&quot;</span><br><span class="line">	extern &quot;C&quot;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__LINE__ 用来记录文件已经被编译的行数 。</span><br><span class="line"></span><br><span class="line">__FILE__ 包含正在被编译的文件的名字。</span><br><span class="line"></span><br><span class="line">__TIME__  和 __DATE__ </span><br></pre></td></tr></table></figure>

<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>终端输入也被称为标准输入standard input，与预定义的iostream 对象 cin ，绑定在一起，直接向终端输出，也被称为标准输出standard output， 与预定义的iostream 对象cout 绑定在一起，第三个预定义iostream 对象cerr 称为标准错误standard error ，也与终端绑定cerr 通常用来产生给程序用户的警告或错误信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br></pre></td></tr></table></figure>

<p>除了显式地使用换行符外我们还可以使用预定义的iostream 操纵符 endl.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//为了打开一个文件供输入或输出除了iostream 头文件外还必须包含头文件</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">ofstream outFile(nameOfFile);</span><br></pre></td></tr></table></figure>



<h2 id="第二章-C-浏览"><a href="#第二章-C-浏览" class="headerlink" title="第二章  C++浏览"></a>第二章  C++浏览</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>虽然C++对数组类型提供了内置支持，但是这种支持仅限于用来读写单个元素的机制，C++不支持数组的抽象，也不支持对整个数组的操作。</p>
<h3 id="动态内存分配和指针"><a href="#动态内存分配和指针" class="headerlink" title="动态内存分配和指针"></a>动态内存分配和指针</h3><p>在C++中指针的主要用处是管理和操纵动态分配的内存。<br>静态与动态内存分配的两个主要区别是：<br>    1.静态对象是有名字的变量，我们直接对其进行操作，而动态对象是没有名字的变量，我们通过指针间接地对它进行操作。<br>    2.静态对象的分配与释放由编译器自动处理，程序员需要理解这一点，但不需要做任何事情，相反，动态对象的分配与释放必须由程序员显式地管理，相对来说比较容易出错，它通过new 和delete 两个表达式来完成。</p>
<h4 id="new的两种分配方式："><a href="#new的两种分配方式：" class="headerlink" title="new的两种分配方式："></a>new的两种分配方式：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//第一种：分配特定类型的单个对象</span><br><span class="line">int *pint = new int( 1024 );</span><br><span class="line">//第二种：用于分配特定类型和维数的数组</span><br><span class="line">int *pia = new int[ 4 ];</span><br></pre></td></tr></table></figure>

<h4 id="delete的释放方法："><a href="#delete的释放方法：" class="headerlink" title="delete的释放方法："></a>delete的释放方法：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//单一对象的delete 表达式形式如下</span><br><span class="line">// 删除单个对象</span><br><span class="line">delete pint;</span><br><span class="line">//数组形式的delete 表达式如下</span><br><span class="line">// 删除一个对象数组</span><br><span class="line">delete [] pia;</span><br></pre></td></tr></table></figure>

<h3 id="Class-概述"><a href="#Class-概述" class="headerlink" title="Class 概述"></a>Class 概述</h3><h4 id="类名和类体："><a href="#类名和类体：" class="headerlink" title="类名和类体："></a>类名和类体：</h4><p>类定义包括两个部分：类头class head 由关键字class 与相关联的类名构成。类体class body 由花括号括起来以分号结束。类头本身也用作类的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在程序中声明IntArray 类但是不提供定义</span><br><span class="line">class IntArray;</span><br></pre></td></tr></table></figure>

<p>类体包含成员定义,以及访问标签,如public 和private .类的成员包括该类能执行的操作和代表类抽象所必需的数据.这些操作称为成员函数member function 或方法 method。</p>
<h4 id="成员访问操作符：-和-gt"><a href="#成员访问操作符：-和-gt" class="headerlink" title="成员访问操作符：  .   和 -&gt;"></a>成员访问操作符：  .   和 -&gt;</h4><h4 id="public-和-private"><a href="#public-和-private" class="headerlink" title="public 和 private"></a>public 和 private</h4><p>关键字private 和public 控制对类成员的访问,出现在类体中公有public 部分的成员,在一般程序的任何地方都可以访问它们,出现在私有private 部分的成员,只能在该类的成员函数或友元friend 中被访问.</p>
<p>由于C++不允许成员函数与数据成员共享同一个名字，所以在这样的情况下，一般的习惯是在数据成员名字前面加一个下划线_。、</p>
<h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>内联函数在它的调用点上被展开,一般来说内联函数不会引入任何函数调用.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array.size() 展开为 array._size;</span><br></pre></td></tr></table></figure>

<h4 id="构造函数和函数重载"><a href="#构造函数和函数重载" class="headerlink" title="构造函数和函数重载"></a>构造函数和函数重载</h4><p>构造函数是一种特殊的类成员函数，专门用于初始化对象。如果构造函数被定义了，那么在类的每个对象第一次被使用之前，这构造函数就被自动应用在对象上。</p>
<p>为了定义一个构造函数，我们只要给它与类相同的名字即可，另外我们不能给构造函数指定返回值，但是可以给类定义多个构造函数，尽管它们都具有相同的名字，但只要编译器能够根据参数表区分它们就行。</p>
<p>被声明为static 的数据成员，是一类特殊的共享数据成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份，这是在类的所有对象之间共享数据的一种方式。</p>
<h4 id="域操作符"><a href="#域操作符" class="headerlink" title="域操作符"></a>域操作符</h4><p>双冒号:: 操作符被称为域操作符。可以非正式地把域看作是一个可视窗口， 全局域的对象在它被定义的整个文件里(一直到文件末尾)都是可见的。</p>
<p>C++类的关键特征是接口与实现的分离。接口是一些用户可以应用到类对象上的操作的集合，它由三部分构成这些操作的名字、它们的返回值、以及它们的参数表。一般地这就是该类用户所需要知道的全部内容。私有实现包括为支持公有接口所必需的算法和数据。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>在C++中被继承的类被称作基类， 新类从基类派生而来，我们把它叫做基类的派生类或子类型。</p>
<h3 id="泛型设计"><a href="#泛型设计" class="headerlink" title="泛型设计"></a>泛型设计</h3><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>C++的模板设施提供了一种机制它能够将类成函数定义内部的类型和值参数化。</p>
<p>模板机制也支持面向对象的程序设计，类模板可以作为基类或派生类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">template&lt;class T&gt;</span><br></pre></td></tr></table></figure>

<h4 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">搜索算法</span><br><span class="line">find() find_if() search() binary_search() count() count_if()</span><br><span class="line">分类排序与通用排序算法</span><br><span class="line">sort() partial_sort() merge() partition() rotate() reverse() random_shuffle()</span><br><span class="line">删除算法</span><br><span class="line">unique() remove()</span><br><span class="line">算术算法</span><br><span class="line">accumulate() partial_sum() inner_product() adjacent_difference()</span><br><span class="line">生成和变异算法</span><br><span class="line">generate() fill() transformation() copy( for_each()</span><br><span class="line">关系算法</span><br><span class="line">equal() min 和max()</span><br></pre></td></tr></table></figure>

<p>泛型算法接受一对迭代器，它们标记了要遍历元素的范围。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常处理为响应运行时刻的程序异常,提供了一个标准的语言级的设施.它支持统一的语法和风格,也允许每个程序员进行微调.</p>
<p>异常处理机制的主要构成如下:</p>
<ol>
<li><p>程序中异常出现的点.</p>
</li>
<li><p>程序中异常被处理的点.</p>
<p>典型地,程序异常的抛出与处理位于独立的函数或成员函数调用中.找到处理代码通常要涉及到展开程序调用栈,一旦异常被处理完毕就恢复正常的程序执行,但不是在发生异常的地方恢复执行过程,而是在处理异常的<br>地方恢复执行过程.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">catch(string exceptionMsg)&#123;</span><br><span class="line">    log_message( exceptionMsg );</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>catch 子句与try 块相关联,一个try 块用一个或多个catch 子句将一条或多条语句组织起来.</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line"></span><br><span class="line">&#125;catch()&#123;</span><br><span class="line"></span><br><span class="line">&#125;catrch( ... )&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命名空间-1"><a href="#命名空间-1" class="headerlink" title="命名空间"></a>命名空间</h3><p>名字空间机制允许我们封装名字，否则这些名字就有可能会污染影响全局名字空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">namespace Cplusplus_Primer_3E &#123;</span><br><span class="line">template &lt;class elemType&gt;</span><br><span class="line">class Array &#123; ... &#125;;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果名字空间内的声明对程序而言不是立即可见的，那么我们可以使用限定修饰名字符，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">namespace_identifier::entity_name</span><br></pre></td></tr></table></figure>

<p>名字空间别名允许用一个可替代的短的或更一般的名字与一个现有的名字空间关联起来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 提供一个更一般化的别名</span><br><span class="line">namespace LIB = IBM_Canada_Laboratory;</span><br><span class="line">// 提供一个更短的别名</span><br><span class="line">namespace DFA = Disney_Feature_Animation;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">using std::string;</span><br><span class="line">std::string;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 3.1</title>
    <url>/%E5%AD%A6%E4%B9%A0/cppPrimerCh03_1/</url>
    <content><![CDATA[<p> C++ Primer 第三篇第七章学习笔记。<span id="more"></span></p>
<h1 id="第三篇-基于过程的程序设计"><a href="#第三篇-基于过程的程序设计" class="headerlink" title="第三篇  基于过程的程序设计"></a>第三篇  基于过程的程序设计</h1><h2 id="第七章-函数"><a href="#第七章-函数" class="headerlink" title="第七章 函数"></a>第七章 函数</h2><p>函数声明由函数返回类型、函数名、和参数表构成。这三个元素被称为函数声明或函数原型。一个函数可在一个文件中被声明多次。</p>
<p>函数类型和内置数组类型不能用作返同类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 非法: 数组不能作返回类型</span><br><span class="line">int[10] foo_bar();</span><br><span class="line">// ok: 指向数组的第一个元素的指针</span><br><span class="line">int *foo_bar();</span><br></pre></td></tr></table></figure>

<p>类类型和容器类型可以被直接返回，但是效率很低。</p>
<p>为了修改实参，有两种方法：</p>
<p>​        1.参数被声明成指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// pswap()交换v1 和v2 指向的值</span><br><span class="line">void pswap( int *v1, int *v2 ) &#123;</span><br><span class="line">	int tmp = *v2;</span><br><span class="line">	*v2 = *v1;</span><br><span class="line">	*v1 = tmp;</span><br><span class="line">&#125;</span><br><span class="line">//调用</span><br><span class="line">pswap( &amp;i, &amp;j );</span><br></pre></td></tr></table></figure>

<p>​        2.参数声明成引用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// rswap() 交换v1 和v2 引用的值</span><br><span class="line">	void rswap( int &amp;v1, int &amp;v2 ) &#123;</span><br><span class="line">	int tmp = v2;</span><br><span class="line">	v2 = v1;</span><br><span class="line">	v1 = tmp;</span><br><span class="line">&#125;</span><br><span class="line">//调用</span><br><span class="line">rswap( i, j );</span><br></pre></td></tr></table></figure>

<p>如果一个参数可能在函数中指向不同的对象，或者这个参数可能不指向任何对象，则必须使用指针参数。</p>
<p>引用参数的一个重要用法是，它允许我们在有效地实现重载操作符的同时，还能保证用法的直观性。</p>
<h3 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h3><p>有时候我们无法列出传递给函数的所有实参的类型和数目。在这种情况下我们可以用省略号指定函数参数表。</p>
<p>省略号挂起类型检查机制。它们的出现告知编译器当函数被调用时可以有0 个或多个实参，而实参的类型未知。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void foo( parm_list, ... );</span><br><span class="line">void foo( ... );</span><br></pre></td></tr></table></figure>

<p>此外：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void f();</span><br><span class="line">void f(...);</span><br><span class="line">//声明不等价。</span><br></pre></td></tr></table></figure>

<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>当声明一个返回引用的函数时，程序员应当知道下面两个易犯的错误：</p>
<p>​    1. 返回一个指向局部对象的引用，局部对象的生命期随函数的结束而结束。在函数结束后该引用变成未定义内存的别名。</p>
<p>​    2.函数返回一个左值，对返回值的任何修改都将改变被返回的实际对象。为防止对引用返回值的无意修改，返回值应该被声明为const。</p>
<h3 id="inline函数"><a href="#inline函数" class="headerlink" title="inline函数"></a>inline函数</h3><p>调用函数比直接计算条件操作符要慢得多。inline 内联函数给出了一种解决方案。若一个函数被指定为inline 函数，则它将在程序中每个调用点上被内联地展开。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inline int min( int v1, int v2 ) &#123; </span><br><span class="line">	//do some thing.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>inline 机制用来优化,小的只有几行的,经常被调用的函数.</p>
<p>inline 函数对编译器而言必须是可见的,以便它能够在调用点内联展开.该函数与非inline函数不同的是.inline 函数必须在调用该函数的每个文本文件中定义.</p>
<h3 id="链接指示符-extern-“C”"><a href="#链接指示符-extern-“C”" class="headerlink" title="链接指示符:  extern “C”"></a>链接指示符:  extern “C”</h3><p>​        用链接指示符告诉编译器,该函数是用其他的程序设计语言编写的.链接指示符有两种形式:  既可以是单一语句形式也可以是复合语句形式.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 单一语句形式的链接指示符</span><br><span class="line">extern &quot;C&quot; void exit(int);</span><br><span class="line">// 复合语句形式的链接指示符</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">    int printf( const char* ... );</span><br><span class="line">    int scanf( const char* ... );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链接指示符不能出现在函数体中，把链接指示符放在头文件中更合适。</p>
<h3 id="处理命令行选项"><a href="#处理命令行选项" class="headerlink" title="处理命令行选项"></a>处理命令行选项</h3><p>命令行选项是main()的实参，在main()函数中，我们可以通过一个名为argv 的C 风格字符串数组访问它。</p>
<p>最好是把处理命令行选项的细节封装起来，使得它不会扰乱main()。</p>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>当一个函数名没有被调用操作符修饰时，会被解释成指向该类型函数的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lexicoCompare;</span><br><span class="line">//会被解释成类型</span><br><span class="line">//int (*)( const string &amp;, const string &amp; );</span><br><span class="line">//将取地址操作符作用在函数名上也能产生指向该函数类型的指针</span><br><span class="line">&amp;lexicoCompare;</span><br></pre></td></tr></table></figure>

<p>函数指针可以用0 来初始化或赋值，以表示该指针不指向任何函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int (*pfi2s)( const string &amp;, const string &amp; ) = 0;</span><br></pre></td></tr></table></figure>

<p>指向函数的指针可以被用来调用它所指向的函数，调用函数时，不需要解引用操作符，无论是用函数名直接调用函数，还是用指针间接调用函数，两者的写法是一样的。</p>
<h4 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int (*testCases[10])();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// typedefs 使声明更易读</span><br><span class="line">typedef int (*PFV)(); // 定义函数类型指针的typedef</span><br><span class="line">PFV testCases[10];</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 3.2</title>
    <url>/%E5%AD%A6%E4%B9%A0/cppPrimerCh03_2/</url>
    <content><![CDATA[<p>C++primer第三篇第八章学习笔记。<span id="more"></span></p>
<h1 id="第三篇-基于过程的程序设计"><a href="#第三篇-基于过程的程序设计" class="headerlink" title="第三篇 基于过程的程序设计"></a>第三篇 基于过程的程序设计</h1><h2 id="第八章-域和生命期"><a href="#第八章-域和生命期" class="headerlink" title="第八章  域和生命期"></a>第八章  域和生命期</h2><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>C++支持三种形式的域局部域、名字空间域、以及类域。</p>
<h4 id="局部域"><a href="#局部域" class="headerlink" title="局部域"></a>局部域</h4><p>局部域是包含在函数定义或者函数块中的程序文本部分。每一个函数都有一个独立的局部域，在函数中的每个复合语句或块也有一个独立的局部域。、</p>
<p>局部域内的名字解析：首先查找使用该名字的域，如果找到一个声明，则该名字被解析。如果没有找到，则查找包含该域的域这个过程会一直继续下去直到找到<br>一个声明或已经查找完整个全局域如果后一种情况发生 即没有找到该名字的声明则这<br>个名字的用法将被标记为错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int low;</span><br><span class="line">int binSearch( const vector&lt;int&gt; &amp;vec, int val )&#123;</span><br><span class="line">    // low 的局部声明</span><br><span class="line">    // 隐藏了全局域中的声明</span><br><span class="line">    int low = 0;</span><br><span class="line">    // ...</span><br><span class="line">    // low 是局部变量</span><br><span class="line">    while ( low &lt;= high )&#123; </span><br><span class="line">    	// ...</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="名字空间域"><a href="#名字空间域" class="headerlink" title="名字空间域"></a>名字空间域</h4><p>名字空间域是不包含在函数声明、函数定义或者类定义内的程序文本部分。程序的最外层的名字空间域被称作全局域。对象、函数、类型以及模板都可以在全局域中定义，程序员也可以利用名字空间定义来定义用户声明的的名字空间。它们被嵌套在全局域内，每个用户声明的名字空间都是一个不同的域，它们都与全局域不同，与全局域相同的是，用户声明的名字空间，可以包含对象、函数、类型和模板的声明与定义，以及被嵌套其内的用户声明的名字空间。</p>
<h4 id="类域"><a href="#类域" class="headerlink" title="类域"></a>类域</h4><p>每个类定义都引入了一个独立的类域。</p>
<h4 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h4><p>在一个程序中，一个全局对象只能有一个定义，因为在使用文件中的对象之前必须先要声明这个对象，所以对于一个由多个文件构成的程序来说，它应该能够只声明一个对象而不定义它。</p>
<p>关键字extern 为声明但不定义一个对象提供了一种方法，实际上它类似于函数声明，承诺了该对象会在其他地方被定义，或者在此文本文件中的其他地方，或者在程序的其他文本文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern int i;</span><br></pre></td></tr></table></figure>

<h4 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h4><p>在局部域中的变量声明引入了局部对象。有三种局部对象：自动对象、寄存器对象以及局部静态对象。<br>区分这些对象的是对象所在存储区的属性和生命期。自动对象所在存储区从声明它的函数被调用时开始一直到该函数结束为止。寄存器对象是一种自动对象，它支持对其值的快速存。取局部静态对象的存储区在该程序的整个执行期间一直存在。</p>
<h4 id="动态分配的对象"><a href="#动态分配的对象" class="headerlink" title="动态分配的对象"></a>动态分配的对象</h4><p>动态分配的对象允许程序员完全控制它的分配与释放。动态分配的对象，被分配在程序的空闲存储区的可用内存池中。</p>
<h5 id="单个对象的分配与释放"><a href="#单个对象的分配与释放" class="headerlink" title="单个对象的分配与释放"></a>单个对象的分配与释放</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *pi = new int;</span><br></pre></td></tr></table></figure>

<p>在运行时刻，从空闲存储区中分配内存，比如通过上面的new 表达式我们称之为动态内存分配，们说pi 指向的内存是被动态分配的。</p>
<p>下面三个常见程序错误都与动态内存分配有关：<br>1 应用delete 表达式失败，使内存无法返回空闲存储区，这被称作内存泄漏。<br>2 对同一内存区应用了两次delete 表达式，这通常发生在两个指针指向同一个动态分配对象的时候，这是一个很难踉踪的问题，若多个指针指向同一个对象，当通过某一个指针释放了该对象时，就会发生这样的情况，此时该对象的内存被返回给空闲存储区，然后又被分配给某个别的对象，接着指向旧对象的第二个指针被释放，新对象也就跟着消失了。<br>3 在对象被释放后读写该对象这常常会发生因为delete 表达式应用的指针没有被设置为0。</p>
<h4 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h4><p>auto_ptr 是C++标准库提供的类模板,它可以帮助程序员自动管理用new 表达式动态分配的单个对象.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;memory&gt;</span><br><span class="line">auto_ptr&lt; type_pointed_to &gt; identifier( ptr_allocated_by_new );</span><br><span class="line">auto_ptr&lt; type_pointed_to &gt; identifier( auto_ptr_of_same_type );</span><br><span class="line">auto_ptr&lt; type_pointed_to &gt; identifier;</span><br><span class="line">//type_pointed_to 代表由new 表达式创建的对象的类型</span><br></pre></td></tr></table></figure>

<h4 id="数组的动态分配与释放"><a href="#数组的动态分配与释放" class="headerlink" title="数组的动态分配与释放"></a>数组的动态分配与释放</h4><p>new 表达式也可以在空闲存储区中分配数组，在这种情况下new 表达式中的类型指示符后面必须有一对方括号，里面的维数是数组的长度，且该组数可以是一个复杂的表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//分配单个int类型对象</span><br><span class="line">int *Pi =  new int(1024)</span><br><span class="line">//分配一个含有1024个元素的数组</span><br><span class="line">int *pia = new int[1024]</span><br><span class="line">//分配一个含 4x1024 个元素的二维数组</span><br><span class="line">int (*pia2)[ 1024 ] = new int[ 4 ][ 1024 ];</span><br><span class="line">delete [] pia;</span><br></pre></td></tr></table></figure>

<p>动态分配数组的主要好处是：它的第一维不必是常量值，即在编译时刻不需要知道维数，就像局部域或全局域中的定义所引入的数组的维数一样。</p>
<p>对于用new 表达式分配的数组，只有第一维可以用运行时刻计算的表达式来指定，其他维必须是在编译时刻已知的常量值。</p>
<h4 id="常量对象的动态分配与释放"><a href="#常量对象的动态分配与释放" class="headerlink" title="常量对象的动态分配与释放"></a>常量对象的动态分配与释放</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int *pci = new const int(1024);</span><br><span class="line">delete pci;</span><br></pre></td></tr></table></figure>

<p>首先const 对象必须被初始化如果省略了括号中的初始值,就会产生编译错误,除此之外,对于具有缺省构造函数的class类型的对象,初始值可以省略.第二,用 new 表达式返回的值,作为初始值的指针,必须是一个指向const 类型的指针.</p>
<h4 id="定位new-表达式"><a href="#定位new-表达式" class="headerlink" title="定位new 表达式"></a>定位new 表达式</h4><p>new 表达式的第三种形式,可以允许程序员要求将对象创建在已经被分配好的内存中,这种形式的new 表达式被称为定位new 表达式.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;new&gt;</span><br><span class="line">new (place_address) type -specifier</span><br></pre></td></tr></table></figure>

<p>不存在与定位new 表达式相匹配的delete 表达式.</p>
<h3 id="名字空间定义"><a href="#名字空间定义" class="headerlink" title="名字空间定义"></a>名字空间定义</h3><p>名字空间允许我们更好地处理全局名字空间污染问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">namespace cplusplus_primer &#123;</span><br><span class="line">    class matrix &#123; /* ... */ &#125;;</span><br><span class="line">    void inverse ( matrix &amp; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一个名字空间内声明的实体被称为名字空间成员。名字空间成员的名字会自动地与该名字空间名复合或被其限定修饰。</p>
<p>名字空间的定义可以非连续，这对生成一个库很有帮助，它使我们更容易将库的源代码组织成接口和实现部分。</p>
<p>名字空间的定义可以嵌套。</p>
<h4 id="未命名的名字空间"><a href="#未命名的名字空间" class="headerlink" title="未命名的名字空间"></a>未命名的名字空间</h4><p>用未命名的名字空间可以用来声明一个局部于某一文件的实体。未命名的名字空间以关键字namespace 开头。后面直接跟花括号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ----- SortLib.C -----</span><br><span class="line">    namespace &#123;</span><br><span class="line">    void swap( double *d1, double *d2 ) &#123; /* ... */ &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于未命名名字空间的成员是程序实体，所以函数swap()可以在程序整个执行期间被调用，但是未命名名字空间成员名只在特定的文件中可见，在构成程序的其他文件中是不可见的。</p>
<p>在引入标准C++名字空间之前，解决此类声明局部化问题的常见方案是使用从C 语言中继承来的关键字static 。</p>
<h3 id="使用名字空间成员"><a href="#使用名字空间成员" class="headerlink" title="使用名字空间成员"></a>使用名字空间成员</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">namespace International_Business_Machines&#123;</span><br><span class="line">	/* ... */ </span><br><span class="line">&#125;</span><br><span class="line">namespace IBM = International_Business_Machines;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//通过使名字空间成员的名字可见来在程序中用该名字的非限定修饰方式引用这个成员</span><br><span class="line">//而不用前缀namespace_name::name</span><br><span class="line">namespace cplusplus_primer &#123;</span><br><span class="line">    namespace MatrixLib &#123;</span><br><span class="line">        class matrix &#123; /* ... */ &#125;;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">using cplusplus_primer::MatrixLib::matrix;  </span><br></pre></td></tr></table></figure>

<p>与其他声明一样,using 声明引入的名字有以下特性:</p>
<p>1.它在该域中必须惟一.<br>2.由外围域中的声明引入的相同名字被其隐藏.<br>3.它被嵌套域中的相同名字的声明隐藏.</p>
<p>using 声明使名字空间成员易于使用.</p>
<p><strong>using指示符</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// using 指示符: cplusplus_primer 的所有成员都变成可见的</span><br><span class="line">using namespace cplusplus_primer;</span><br></pre></td></tr></table></figure>

<p>使用多个using 指示符会引起全局名字空间污染问题，用多个选择性的using 声明来代替using 指示符会使这个问题最小化，由多个选择性的using 声明引起的二义性错误在声明点就能被检测到，因此建议使用using 声明而不是using 指示符以便更好地控制程序中的全局名字空间污染问题。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 3.3</title>
    <url>/%E5%AD%A6%E4%B9%A0/cppPrimerCh03_3/</url>
    <content><![CDATA[<p> C++ Primer 第三篇第九章学习笔记。<span id="more"></span></p>
<h1 id="第三篇-基于过程的程序设计"><a href="#第三篇-基于过程的程序设计" class="headerlink" title="第三篇 基于过程的程序设计"></a>第三篇 基于过程的程序设计</h1><h2 id="第九章-重载函数"><a href="#第九章-重载函数" class="headerlink" title="第九章 重载函数"></a>第九章 重载函数</h2><p>函数重载 允许多个函数共享同一个函数名但是针对不同参数类型提供共同的操作。</p>
<p>如果两个函数的函数名相同，而参数表中参数的个数或类型不同则认为这两个函数是重载的。</p>
<p>函数的返回类型不足以区分两个重载函数。</p>
<p>当一个参数类型是const 或volatile 时在识别函数声明是否相同时并不考虑const 和volatile 修饰符。</p>
<p>但是，如果把const 或volatile 应用在指针或引用参数指向的类型上，则在判断函数声明是否相同时，就要考虑const 和volatile 修饰符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 声明了不同的函数</span><br><span class="line">void f( int* );</span><br><span class="line">void f( const int* );</span><br><span class="line">// 也声明了不同的函数</span><br><span class="line">void f( int&amp; );</span><br><span class="line">void f( const int&amp; );</span><br></pre></td></tr></table></figure>

<p>重载函数集合中的全部函数都应在同一个域中声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">void print( const string &amp; );</span><br><span class="line">void print( double ); // overloads print()</span><br><span class="line">void fooBar( int ival )</span><br><span class="line">&#123;</span><br><span class="line">    // 独立的域隐藏print()的两个实例</span><br><span class="line">    extern void print( int );</span><br><span class="line">    // 错误: print( const string &amp; )在这个域中被隐藏</span><br><span class="line">    print( &quot;Value : &quot; );</span><br><span class="line">    print( ival ); // ok: print( int ) 可见</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// using 声明</span><br><span class="line">using libs_R_us::max;</span><br><span class="line">using libs_R_us::print( double ); // 错误</span><br><span class="line">//用户不能在using 声明中为一个函数指定参数表</span><br></pre></td></tr></table></figure>

<h3 id="重载解析"><a href="#重载解析" class="headerlink" title="重载解析"></a>重载解析</h3><p>函数重载解析是把函数调用与重载函数集合中的一个函数相关联的过程，在存在多个同名函数的情况下，根据函数调用中指定的实参，选择其中一个函数。</p>
<p>函数重载解析的步骤如下：<br>    1 确定函数调用考虑的重载函数的集合确定函数调用中实参表的属性。<br>    2 从重载函数集合中选择函数该函数可以在给出实参个数和类型的情况下用调用中指定的实参进行调用。<br>    3 选择与调用最匹配的函数。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 2.3</title>
    <url>/%E5%AD%A6%E4%B9%A0/cppPrimerCh02_3/</url>
    <content><![CDATA[<p>C++ Primer 第二篇第五章学习笔记。<span id="more"></span></p>
<h1 id="第二篇-基本语言"><a href="#第二篇-基本语言" class="headerlink" title="第二篇 基本语言"></a>第二篇 基本语言</h1><h2 id="第五章-语句"><a href="#第五章-语句" class="headerlink" title="第五章  语句"></a>第五章  语句</h2><p>与其他语言差别不大。</p>
<h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if()&#123;</span><br><span class="line"></span><br><span class="line">&#125;else if()&#123;</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switch()&#123;</span><br><span class="line">	case:</span><br><span class="line">		//...</span><br><span class="line">		break;</span><br><span class="line">	case:</span><br><span class="line">		//...</span><br><span class="line">		break;</span><br><span class="line">	default:</span><br><span class="line">		//...</span><br><span class="line">		break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i=0; i&lt;n; i++)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">for(int i=0; i&lt;k; i++)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//C++这里的i是局部变量，</span><br></pre></td></tr></table></figure>

<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>break 语句终止最近的while, do while, for 或switch 语句.</p>
<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>continue 语句导致最近的循环语句的当前迭代结束,执行权被传递给条件计算部分.</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 3.5</title>
    <url>/%E5%AD%A6%E4%B9%A0/cppPrimerCh03_5/</url>
    <content><![CDATA[<p> C++ Primer 第三篇第十一章学习笔记。<span id="more"></span></p>
<h1 id="第三篇-基于过程的程序设计"><a href="#第三篇-基于过程的程序设计" class="headerlink" title="第三篇 基于过程的程序设计"></a>第三篇 基于过程的程序设计</h1><h2 id="第十一章-异常处理"><a href="#第十一章-异常处理" class="headerlink" title="第十一章 异常处理"></a>第十一章 异常处理</h2><p>C++程序中出现异常时检测到异常的程序段可以通过产生raise 或抛出throw 异常来通知 “异常已经发生”。</p>
<p>通过throw 语句抛出异常对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ( empty() )</span><br><span class="line">	throw popOnEmpty();</span><br><span class="line">//必须是对象。</span><br></pre></td></tr></table></figure>

<p>try 块必须包围能够抛出异常的语句try 块，以关键字try 开始，后面是花括号括起来的语句序列，在try 块之后是一组处理代码被称为catch 子句，try 块把语句分成组，并将其与相应地处理这些语句可能抛出的异常的处理语句相关联。</p>
<p>程序的控制流是下列几种情况之一：<br>1.如果没有异常发生则执行try 块中的代码和try 块相关联的处理代码被忽略程序main()返回0.</p>
<p>2.如果try块中的语句发生错误。则跳到catch语句执行对应的异常操作。</p>
<p>​      当某条语句抛出异常时，跟在该语句后面的语句将被跳过。程序执行权被转交给处理异常的catch 子句，如果没有catch 子句能够处理该异常，则程序执行权又将被转交给C++标准库中定义的函数。</p>
<p>​    try 块可以包含任何C++语句——表达式以及声明，一个try 块引入一个局部域，在try块内声明的变量不能在try 块外被引用，包括在catch 子句中。</p>
<p>​    C++的异常处理机制被称为是不可恢复的， 一旦异常被处理，程序的执行就不能够在异常被抛出的地方继续。</p>
<h3 id="异常声明"><a href="#异常声明" class="headerlink" title="异常声明"></a>异常声明</h3><p>​    catch 子句的异常声明可以是一个类型声明或一个对象声明。</p>
<p>​    当我们要获得throw 表达式的值，或者要操纵throw 表达式所创建的异常对象时，我们应该声明一个对象。当该异常被抛出时，我们把信息存储在异常对象中，如果catch 子句的异常声明声明了一个对象，则catch 子句中的语句就可以用该对象来引用由throw 表达式存储的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 新异常类:</span><br><span class="line">// 负责保存不能被压入到栈中的值</span><br><span class="line">class pushOnFull &#123;</span><br><span class="line">public:</span><br><span class="line">    pushOnFull( int i ) : _value( i ) &#123; &#125;</span><br><span class="line">    int value() &#123; return _value; &#125;</span><br><span class="line">private:</span><br><span class="line">    int _value;</span><br><span class="line">&#125;;</span><br><span class="line">void iStack::push( int value )</span><br><span class="line">&#123;</span><br><span class="line">    if ( full() )</span><br><span class="line">    // 把value 存储在异常对象中</span><br><span class="line">    throw pushOnFull( value );</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">catch ( pushOnFull eObj ) &#123;</span><br><span class="line">    cerr &lt;&lt; &quot;trying to push the value &quot; &lt;&lt; eObj.value()</span><br><span class="line">    &lt;&lt; &quot; on a full stack\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与函数参数的情形一样,catch 子句中的异常声明也可以被改变成引用声明,于是catch子句就可以直接引用由throw 表达式创建的异常对象,而不是创建一个局部拷贝了.为了防止不必要地拷贝大型类对象,class 类型的参数应该被声明为引用.<br>        在查找用来处理被抛出异常的catch 子句时因为异常而退出复合语句和函数定义这个过程被称作栈展开.</p>
<h3 id="catch-all"><a href="#catch-all" class="headerlink" title="catch-all"></a>catch-all</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 对任何异常都会进人</span><br><span class="line">catch ( ... ) &#123;</span><br><span class="line">    // 这里是我们的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常规范"><a href="#异常规范" class="headerlink" title="异常规范"></a>异常规范</h3><p>​        异常规范提供了一种方案，它能够随着函数声明，列出该函数可能抛出的异常，它保证该函数不会抛出任何<br>其他类型的异常。</p>
<p>​        异常规范跟随在函数参数表之后，它用关键字throw ，来指定后面是用括号括起来的异常类型表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class iStack &#123;</span><br><span class="line">public:</span><br><span class="line">    // ...</span><br><span class="line">void pop( int &amp;value ) throw(popOnEmpty);</span><br><span class="line">void push( int value ) throw(pushOnFull);</span><br><span class="line">private:</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 03</title>
    <url>/%E5%AD%A6%E4%B9%A0/cppPrimerCh04/</url>
    <content><![CDATA[<p> C++ Primer 第四篇第十二章学习笔记。<span id="more"></span></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 3.4</title>
    <url>/%E5%AD%A6%E4%B9%A0/cppPrimerCh03_4/</url>
    <content><![CDATA[<p> C++ Primer 第三篇第十章学习笔记。<span id="more"></span></p>
<h1 id="第三篇-基于过程的程序设计"><a href="#第三篇-基于过程的程序设计" class="headerlink" title="第三篇 基于过程的程序设计"></a>第三篇 基于过程的程序设计</h1><h2 id="第十章-函数模板"><a href="#第十章-函数模板" class="headerlink" title="第十章  函数模板"></a>第十章  函数模板</h2><pre><code>     函数模板提供一种用来自动生成各种类型函数实例的算法。程序员对于函数接口参数和返回类型中的全部或者部分类型进行参数化， 而函数体保持不变。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;class T1, typename T2, int num&gt;</span><br><span class="line">//其中class、typename 是模板类型参数， int num 是非模板类型参数。</span><br></pre></td></tr></table></figure>

<p>在函数模板参数表中关键字typename 和class 的意义相同，可以互换，使用它们两个都可以被用来声明同一模板参数表中的不同模板类型参数。</p>
<h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>函数模板指定了怎样根据一组或更多实际类型或值构造出独立的函数。这个构造过程被称为模板实例化，这个过程是隐式发生的，它可以被看作是函数模板调用或取函数模板的地址的副作用。</p>
<p>用函数实参的类型来决定模板实参的类型和值的过程被称为模板实参推演。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 4.1</title>
    <url>/%E5%AD%A6%E4%B9%A0/cppPrimerCh04_1/</url>
    <content><![CDATA[<p> C++ Primer 第四篇第十三章学习笔记。<span id="more"></span></p>
<h1 id="第四章-基于对象的程序设计"><a href="#第四章-基于对象的程序设计" class="headerlink" title="第四章 基于对象的程序设计"></a>第四章 基于对象的程序设计</h1><h2 id="第十三章-类"><a href="#第十三章-类" class="headerlink" title="第十三章 类"></a>第十三章 类</h2><h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h3><p>类定义包含两部分： 类头 + 类体。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Screen &#123; /* ... */ &#125;;</span><br><span class="line">class Screen &#123; /* ... */ &#125; myScreen, yourScreen;</span><br></pre></td></tr></table></figure>

<p>除了静态 数据成员外，数据成员不能在类体中被显式地初始化，类的数据成员通过类的构造函数进行初始化。</p>
<p>类成员的访问限制是通过类体内被标记为public、private 以及protected的部分来指定的。</p>
<p>关键字public private 和protected 被称为访问限定符。</p>
<p>在某些情况下，允许某个函数而不是整个程序可以访问类的私有成员这样做会比较方便。友元机制允许一个类授权其他的函数访问它的非公有成员。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Screen &#123;</span><br><span class="line">    friend istream&amp; operator&gt;&gt;( istream&amp;, Screen&amp; );</span><br><span class="line">    friend ostream&amp; operator&lt;&lt; ( ostream&amp;, const Screen&amp; );</span><br><span class="line">    public:</span><br><span class="line">    // ... Screen 类的其他部分</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>无论成员函数是在类体内还是外面，我们都说它在类域内。</p>
<p>这有两个含义：</p>
<p>1.成员函数的定义可以引用任何一个类成员，无论该成员是私有的还是公有的都不会破坏类访问限制。</p>
<p>2.成员函数可以直接访问它所属的类的成员，而无需使用点或箭头成员访问操作符。</p>
<p>只有被声明为const 的成员函数，才能被一个const 类对象调用。关键字const 被放在成员函数的参数表和函数体之间，对于在类体之外定义的const 成员函数，我们必须在它的定义和声明中同时指定关键字const。</p>
<p>构造函数和析构函数是两个例外，即使构造函数和析构函数不是const 成员函数，const类对象也可以调用它。</p>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>每个类成员函数都含有一个指向被调用对象的指针，这个指针被称为this。</p>
<p>为支持this 指针，必须要应用两个转变:</p>
<pre><code>1. 改变类成员函数的定义,用额外的参数this 指针,来定义每个成员函数.
2.  改变每个类成员函数的调用,加上一个额外的实参——被调用对象的地址.
</code></pre>
<h3 id="静态类成员"><a href="#静态类成员" class="headerlink" title="静态类成员"></a>静态类成员</h3><p>同全局对象相比,使用静态数据成员有两个优势:</p>
<p>1.静态数据成员没有进入程序的全局名字空间,因此不存在与程序中其他全局名字冲突的可能性<br>2.可以实现信息隐藏,静态成员可以是private 成员,而全局对象不能.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Account &#123;</span><br><span class="line">    Account( double amount, const string &amp;owner );</span><br><span class="line">    string owner() &#123; return _owner; &#125;</span><br><span class="line">private:</span><br><span class="line">    static double _interestRate;</span><br><span class="line">    double _amount;</span><br><span class="line">    string _owner;</span><br><span class="line">&#125;;</span><br><span class="line">// 静态类成员的显式初始化</span><br><span class="line">#include &quot;account.h&quot;</span><br><span class="line">double Account::_interestRate = 0.0589;</span><br></pre></td></tr></table></figure>

<p>静态数据成员的类型可以是其所属类,而非static 数据成员只能被声明为该类的对象的指针或引用.</p>
<p>静态数据成员可以被作为类成员函数的缺省实参,而非static 成员不能。</p>
<p>静态成员函数的声明，除了在类体中的函数声明前加上关键字static， 以及不能声明为const 或volatile 之外，与非静态成员函数相同，出现在类体外的函数定义不能指定关键字static。</p>
<h3 id="指向类成员的指针"><a href="#指向类成员的指针" class="headerlink" title="指向类成员的指针"></a>指向类成员的指针</h3><p>指向成员函数的指针必须与向其赋值的函数类型匹配：<br>1.参数的类型和个数</p>
<p>2.返回类型3</p>
<p>3.它所属的类类型</p>
<p>函数指针存储函数的地址,可以被用来直接调用那个函数.成员函数指针首先必须被绑定在一个对象或者一个指针上,才能得到被调用对象的this 指针,然后才调用指针所指的成员函数.</p>
<p>定义一个成员函数指针需要指定函数返回类型参数表和类.</p>
<p>静态类成员是属于该类的全局对象和函数,它们的指针是普通指针.</p>
<h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><p>一个类可以在另一个类中定义，这样的类被称为嵌套类。嵌套类是其外围类的一个成员，嵌套类的定义可以出现在其外围类的公有私有或保护区中。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 3.6</title>
    <url>/%E5%AD%A6%E4%B9%A0/cppPrimerCh03_6/</url>
    <content><![CDATA[<p> C++ Primer 第三篇第十二章学习笔记。<span id="more"></span></p>
<h1 id="第三篇-基于过程的程序设计"><a href="#第三篇-基于过程的程序设计" class="headerlink" title="第三篇 基于过程的程序设计"></a>第三篇 基于过程的程序设计</h1><h2 id="第十二章-泛型算法"><a href="#第十二章-泛型算法" class="headerlink" title="第十二章 泛型算法"></a>第十二章 泛型算法</h2><p>​        每个泛型算法的实现都独立于单独的容器类型，因为已经消除了算法的类型依赖性，所以单个的模板实例可以操作在各种容器以及内置数组类型上。</p>
<p>泛型算法一般支持两种形式来应用操作：</p>
<p>​    1.使用内置或可能是被重载的操作符</p>
<p>​    2.使用函数指针或函数对象执行操作</p>
<h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><p>函数对象与函数指针相比较有两个方面的优点：</p>
<p>首先如果被重载的调用操作符是inline函数，则编译器能够执行内联编译，提供可能的性能好处。</p>
<p>其次函数对象可以拥有任意数目的额外数据，用这些数据可以缓冲结果，也可以缓冲有助于当前操作的数据。</p>
<h4 id="三种来源"><a href="#三种来源" class="headerlink" title="三种来源"></a>三种来源</h4><p>1.标准库预定义的一组算术关系和逻辑函数对象。</p>
<p>预定义函数对象被分成算术关系和逻辑操作，每个对象都是一个类模板，其中操作数的类型被参数化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;functional&gt;</span><br><span class="line">plus&lt;int&gt; intAdd;</span><br><span class="line">int sum = intAdd(10, 20);</span><br><span class="line">//== sum = 10 + 20;</span><br></pre></td></tr></table></figure>

<p>主要用法是作为泛型算法的实参,通常被用来改变缺省的操作.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt; string &gt; svec;</span><br><span class="line">// ...</span><br><span class="line">sort( svec.begin(), svec.end(), greater&lt;string&gt;() );</span><br></pre></td></tr></table></figure>

<p>预定义的函数对象被分成算术、关系和逻辑三大类别。</p>
<p>标准库还提供了一组函数适配器，用来特殊化或者扩展一元和二元函数对象。适配器是一种特殊的类，它被分成下面两类：</p>
<p>1 绑定器：binder 通过把二元函数对象的一个实参绑定到一个特殊的值上，将其转换成一元函数对象。</p>
<p>例如为了计数一个容器中小于或等于10 的元素的个数，我们可能会向count_if()传递一个less_equal 函数对象以及一个被绑定为10 的实参。</p>
<p>2.取反器： negator 是一个将函数对象的值翻转的函数适配器。</p>
<p>例如为了计数一个容器中所有大于10 的元素的个数，我们可以向count_if()传递less_equal 函数对象的negator ，该函数对象有一个实参被绑定为10。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 5.1</title>
    <url>/%E5%AD%A6%E4%B9%A0/cppPrimerCh05_1/</url>
    <content><![CDATA[<p> C++ Primer 第五篇第十七章学习笔记。<span id="more"></span></p>
<h1 id="第五篇-面向对象的程序设计"><a href="#第五篇-面向对象的程序设计" class="headerlink" title="第五篇 面向对象的程序设计"></a>第五篇 面向对象的程序设计</h1><h2 id="第十七章-类继承和子类型"><a href="#第十七章-类继承和子类型" class="headerlink" title="第十七章 类继承和子类型"></a>第十七章 类继承和子类型</h2><p>如果基类和派生类共享相同的公有接口，则派生类被称作基类的子类型。</p>
<p>在C++中，存在特殊的类型/子类型关系，基类指针或引用可以直接引用其任何派生子类，而无需程序员介入，这种用基类的指针或引用，操纵多个类型的能力被称为多态。</p>
<p>子类多态性使得我们在编写应用程序的核心时，可以不用考虑将来需要维护的单个类型，我们利用基类指针和引用，对抽象的基类的公有接口进行编程。在运行时刻，真正要引用的类型被解析出来，并且调用适当的公有接口实例。</p>
<p>在运行时刻需要解析出被调用的函数，这个解析过程被称为动态绑定，缺省情况下，函数是在编译时刻被静态解析的，在C++中通过一种被称为虚拟函数的机制来支持动态绑定。</p>
<p>继承层次结构的主要好处是，我们可以针对抽象基类的公有接口进行编程，而不是针对组成继承层次的个别类型。通过这种方式我们的代码可以不受层次结构变化的影响</p>
<p>在C++中多态性只存在子类继承层次中。void*型的指针可以被描述为多态，但是语言本身并没有显式地支持它们——即它们必须由程序员自己来管理，程序员可以通过显式强制类型转换以及记录实际类型的判别式来做到这一点。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承关系通过类派生表c来指定。在单继承下它的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">: access-level base-class</span><br><span class="line">这里access-level 是public 、protected 或private 之一。</span><br></pre></td></tr></table></figure>

<p>声明时不用表明继承关系。实际实现时才需要实现实际关系。</p>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Query &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void eval() = 0;</span><br><span class="line">&#125;;</span><br><span class="line">class NameQuery : public Query &#123;</span><br><span class="line">public:</span><br><span class="line">    // ...</span><br><span class="line">    // 改写 virtual Query::eval() 实例29</span><br><span class="line">    void eval();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 4.2</title>
    <url>/%E5%AD%A6%E4%B9%A0/cppPrimerCh04_2/</url>
    <content><![CDATA[<p> C++ Primer 第四篇第十四章学习笔记。<span id="more"></span></p>
<h1 id="第四篇-基于对象的程序设计"><a href="#第四篇-基于对象的程序设计" class="headerlink" title="第四篇  基于对象的程序设计"></a>第四篇  基于对象的程序设计</h1><h3 id="第十四章-类的初始化、赋值和析构"><a href="#第十四章-类的初始化、赋值和析构" class="headerlink" title="第十四章 类的初始化、赋值和析构"></a>第十四章 类的初始化、赋值和析构</h3><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数上惟一的语法限制是，它不能指定返回类型，甚至void 也不行。</p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>并不是每一个类都要求有析构函数，析构函数主要被用来放弃在类对象的构造函数或生命期中获得的资源，如释放互斥锁或删除由操作符new 分配的内存。</p>
<p>一般地，析构函数可以执行“类设计者希望在最后一次使用对象之后执行的任何操作”。</p>
<h3 id="类对象数组"><a href="#类对象数组" class="headerlink" title="类对象数组"></a>类对象数组</h3><p>类对象数组与内置类型数组的定义方式相同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Account table[ 16 ];</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 03</title>
    <url>/%E5%AD%A6%E4%B9%A0/cppPrimerCh04_3/</url>
    <content><![CDATA[<p> C++ Primer 第四篇第十五章学习笔记。<span id="more"></span></p>
<h1 id="第四篇-基于对象的程序设计"><a href="#第四篇-基于对象的程序设计" class="headerlink" title="第四篇 基于对象的程序设计"></a>第四篇 基于对象的程序设计</h1><h2 id="第十五章-重载操作符和用户定义的转换"><a href="#第十五章-重载操作符和用户定义的转换" class="headerlink" title="第十五章 重载操作符和用户定义的转换"></a>第十五章 重载操作符和用户定义的转换</h2><h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><p>操作符重载使得程序员能够为类类型的操作数定义预定义的操作符版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string&amp; operator=( const String &amp; );</span><br><span class="line">string&amp; operator=( const char * );</span><br></pre></td></tr></table></figure>

<p>重载的操作符在类体中被声明,声明方式同普通成员函数一样,只不过它的名字包含关键字operator ,以及紧随其后的一个预定义操作.</p>
<p>如果一个重载操作符是类成员，那么只有当跟它一起被使用的左操作数是该类的对象时，它才会被调用。</p>
<p>如果该操作符的左操作数必须是其他的类型，那么重载操作符必须是名字空间成员。</p>
<p>C++要求：赋值= 、下标[] 、调用() 和成员访问箭头-&gt; 操作符必须被定义为类成员操作符，任何把这些操作符定义为名字空间成员的定义都会被标记为编译时刻错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 错误: 必须是类成员</span><br><span class="line">char&amp; operator[]( String &amp; ,int ix );</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习过程中遇到的问题-01</title>
    <url>/%E5%AD%A6%E4%B9%A0/cppProblem02/</url>
    <content><![CDATA[<h1 id="记录C-过程中遇到的一些问题"><a href="#记录C-过程中遇到的一些问题" class="headerlink" title="记录C++过程中遇到的一些问题"></a>记录C++过程中遇到的一些问题</h1><p> C++好复杂啊  + 1。(<em>¯ㅿ¯</em>;)</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习过程中遇到的问题-01</title>
    <url>/%E5%AD%A6%E4%B9%A0/cppProblem01/</url>
    <content><![CDATA[<h1 id="记录C-过程中遇到的一些问题"><a href="#记录C-过程中遇到的一些问题" class="headerlink" title="记录C++过程中遇到的一些问题"></a>记录C++过程中遇到的一些问题</h1><p> C++好复杂啊。(<em>¯ㅿ¯</em>;)</p>
<span id="more"></span>

<h2 id="输入cin-指令无效"><a href="#输入cin-指令无效" class="headerlink" title="输入cin 指令无效"></a>输入cin 指令无效</h2><p>​    在一个简单的交互程序中，使用 cin 来读取输入时，第一次读取输入的字符串正常读取，第二次读取输入的数字时命令被忽略，直接跳过执行。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; number; <span class="comment">//通常情况会进行输入读取一个数值，前提是cin正常。如果cin被核定为false，则cin就不会被执行啦。</span></span><br></pre></td></tr></table></figure>

<p>   上述例子中，由于输入字符串时，输入了结束符进行退出，所以 cin 已经被核定为false了，所以下边的 cin&gt;&gt;number 无法正常执行输入操作。</p>
<p>cin 被核定为 false 的情况：</p>
<p>​    （1）遇到结束符。</p>
<p>​    （2）遇到非法输入。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>​    使用cin.clear() 和 cin.sync() 使 cin 恢复正常状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两者需要同时使用。</span></span><br><span class="line">    cin.<span class="built_in">sync</span>();</span><br><span class="line">    cin.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>

<p>   更多的具体细节可以搜索函数的定义和功能。</p>
<h2 id="Null-与-nullptr"><a href="#Null-与-nullptr" class="headerlink" title="Null 与 nullptr"></a>Null 与 nullptr</h2><p>Null在C++中定义为0，在很多场合（尤其涉及到指针时）。因此更加提倡使用 nullptr 来代替Null。</p>
<h2 id="using用法"><a href="#using用法" class="headerlink" title="using用法"></a>using用法</h2><p>C/C++中可以使用  typedef 来定义别名。被重定义的类型并不是一个新的类型，仅仅只是原有的类型取了一个新的名字。</p>
<p>使用 typedef 重定义类型是很方便的，但它也有一些限制，比如，无法重定义一个模板。</p>
<p>而using 的别名语法覆盖了 typedef 的全部功能。using 别名语法比 typedef 更加清晰。因为 typedef 的别名语法本质上类似一种解方程的思路。而 using 语法通过赋值来定义别名，和我们平时的思考方式一致。</p>
<p>因此很多情况二者可以互换  但更多情况下最好使用using。</p>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>析构函数（destructor）是成员函数的一种，它的名字与类名相同，但前面要加<code>~</code>，没有参数和返回值。一个类有且仅有一个析构函数。如果定义类时没写析构函数，则编译器生成默认析构函数。析构函数在对象消亡时即自动被调用。可以定义析构函数在对象消亡前做善后工作。例如，对象如果在生存期间用 new 运算符动态分配了内存，则在各处写 delete 语句以确保程序的每条执行路径都能释放这片内存是比较麻烦的事情。有了析构函数，只要在析构函数中调用 delete 语句，就能确保对象运行中用 new 运算符分配的空间在对象消亡时被释放。</p>
<h2 id="const的不同用法"><a href="#const的不同用法" class="headerlink" title="const的不同用法"></a>const的不同用法</h2><p>关键问题点：const 属于修饰符 ，关键是看const 修饰的位置在那里</p>
<p>​    在 C++ 中const是用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。</p>
<p>​    C++ const 允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。如果在编程中确实有某个值保持不变，就应该明确使用const，这样可以获得编译器的帮助。</p>
<h3 id="修饰普通类型变量"><a href="#修饰普通类型变量" class="headerlink" title="修饰普通类型变量"></a>修饰普通类型变量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int num = 7;</span><br><span class="line">num = 8;//错误，num不可修改。</span><br></pre></td></tr></table></figure>

<h3 id="修饰指针变量"><a href="#修饰指针变量" class="headerlink" title="修饰指针变量"></a>修饰指针变量</h3><p>const 修饰指针变量有以下三种情况。</p>
<ul>
<li>A: const 修饰指针指向的内容，则内容为不可变量。</li>
<li>B: const 修饰指针，则指针为不可变量。</li>
<li>C: const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//A情形：</span><br><span class="line">const int *p = 8;</span><br><span class="line">//左定值，指针指向的内容不可改变。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//B情形:</span><br><span class="line">int a = 8;</span><br><span class="line">int* const p = &amp;a;</span><br><span class="line">*p =9; //正确</span><br><span class="line">int b = 7;</span><br><span class="line">p = &amp;b; //错误</span><br><span class="line">//对于 const 指针 p 其指向的内存地址不能够被改变，但其内容可以改变。简称，右定向。因为 const 位于 * 号的右边。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//C情形</span><br><span class="line">int a = 8;</span><br><span class="line">const int * const  p = &amp;a;</span><br><span class="line">//const p 的指向的内容和指向的内存地址都已固定，不可改变。</span><br></pre></td></tr></table></figure>

<p>根据 const 位于 * 号的位置不同，可总结三句话便于记忆的话：**”左定值，右定向，const修饰不变量”**。</p>
<p>int const *a 和 const int *a 的意义是相同的 他们两个的作用等价</p>
<h3 id="const参数传递和函数返回值"><a href="#const参数传递和函数返回值" class="headerlink" title="const参数传递和函数返回值"></a>const参数传递和函数返回值</h3><p>对于 const 修饰函数参数可以分为三种情况。</p>
<p>A：值传递的 const 修饰传递，一般这种情况不需要 const 修饰，因为函数会自动产生临时变量复制实参值。</p>
<p>B：当 const 参数为指针时，可以防止指针被意外篡改。</p>
<p>C：自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取 const 外加引用传递的方法。并且对于一般的 int、double 等内置类型，我们不采用引用的传递方式。</p>
<p>Const 修饰返回值分三种情况。</p>
<p>A：const 修饰内置类型的返回值，修饰与不修饰返回值作用一样。</p>
<p>B: const 修饰自定义类型的作为返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。</p>
<p>C: const 修饰返回的指针或者引用，是否返回一个指向 const 的指针，取决于我们想让用户干什么。</p>
<h3 id="const修饰类成员函数"><a href="#const修饰类成员函数" class="headerlink" title="const修饰类成员函数"></a>const修饰类成员函数</h3><p>const 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。</p>
<p><strong>注意：</strong>const 关键字不能与 static 关键字同时使用，因为 static 关键字修饰静态成员函数，静态成员函数不含有 this 指针，即不能实例化，const 成员函数必须具体到某一实例。</p>
<p>如果有个成员函数想修改对象中的某一个成员可以使用 mutable 关键字修饰这个成员，被 mutable 关键字修饰的成员可以处于不断变化中.</p>
<h2 id="int-array"><a href="#int-array" class="headerlink" title="int array[[]][][]"></a>int array[[]][][]</h2><p>如果想要将一个二维数组当作函数形参或应用， 则必须实现定义第二维的大小，相比之下，更应该使用vector&lt;vector<int> &gt;.</p>
<p>此外C++11有了一个新的array容器。</p>
<h2 id="函数返回值为引用类型"><a href="#函数返回值为引用类型" class="headerlink" title="函数返回值为引用类型"></a>函数返回值为引用类型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">Vector&lt;T&gt;&amp; Vector&lt;T&gt;::operator=(Vector&lt;T&gt; const&amp; V)&#123;  //重载 =</span><br><span class="line">    //释放原有内容</span><br><span class="line">    if(_elem)</span><br><span class="line">        delete[] _elem;</span><br><span class="line">    //整体复制</span><br><span class="line">    copyFrom(V._elem, 0, V.size());</span><br><span class="line">    //返回当前对象的引用，以便链式复制</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回类型为引用类型，需要注意返回值是全局变量、局部变量、类对象等。防止发生错误。</p>
<p>对应很多不同的情况，值得仔细研究一下。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记01</title>
    <url>/%E5%AD%A6%E4%B9%A0/gitNote01/</url>
    <content><![CDATA[<h2 id="系统的学习一下Git和Github的使用"><a href="#系统的学习一下Git和Github的使用" class="headerlink" title="系统的学习一下Git和Github的使用"></a>系统的学习一下Git和Github的使用</h2><p>​    已经了解和使用过Git和Github，但是并没有具体的学习过。通过系统学习能进一步加深影响。<span id="more"></span></p>
<p>​    参考书籍《ProGit》。</p>
<h3 id="获取Git仓库"><a href="#获取Git仓库" class="headerlink" title="获取Git仓库"></a>获取Git仓库</h3><p>​    获取方式通常有两种：</p>
<p>​        1、使用语句 git init ，将本地文件初始化为仓库。</p>
<p>​        2、使用给git clone <url>语句，clone一个已有的仓库下来。</p>
<h3 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h3><p>​    如图所示：</p>
<img src="/images/git/git_01.png" >

<p>​    文件所处的状态一定是图中几种状态之一。</p>
<p>​    查看当前不同文件的状态可以使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>

<h3 id="跟踪新文件-暂存文件"><a href="#跟踪新文件-暂存文件" class="headerlink" title="跟踪新文件/暂存文件"></a>跟踪新文件/暂存文件</h3><p>​    使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p>​    可以用 git add <file>开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适.</p>
<h3 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h3><p>​    使用参数查看状态简洁输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status --short</span><br><span class="line">git status -s</span><br></pre></td></tr></table></figure>

<p>  新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。</p>
<h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>​    通过创建   .gitignore 文件来选择忽略的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#示例</span><br><span class="line">#以下是忽略内容，使用正则表达式来匹配、</span><br><span class="line">*.[co]</span><br><span class="line">*~</span><br><span class="line">/folderName</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>文件 .gitignore 的格式规范如下：<br>• 所有空行或者以 # 开头的行都会被 Git 忽略。<br>• 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。<br>• 匹配模式可以以（/）开头防止递归。<br>• 匹配模式可以以（/）结尾指定目录。<br>• 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。</p>
<h3 id="对比差异"><a href="#对比差异" class="headerlink" title="对比差异"></a>对比差异</h3><p>git status只能反映当前文件的状态，如果想查看文件修改的内容或历史差异需要使用语句git diff.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff  #比较的是工作目录中当前文件和暂存区域快照之间的差异</span><br><span class="line">git diff --staged  </span><br><span class="line">git diff --cached </span><br><span class="line">#上面两条语句作用相同，比对已暂存文件与最后一次提交的文件差异：</span><br></pre></td></tr></table></figure>

<h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><p> 可以直接使用 git commit 来提交更新，接着会启动文本编辑器提示你输入版本更新信息。</p>
<p>也可以直接使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;版本更新信息&quot;</span><br></pre></td></tr></table></figure>

<h3 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -a </span><br><span class="line">#Git 会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤</span><br></pre></td></tr></table></figure>

<h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>情形一：</p>
<p>  直接删除文件，使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm  &lt;filename&gt;</span><br><span class="line">#如果文件修改后未暂存</span><br><span class="line">git rm -f &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p>情形二：</p>
<p>不删除文件而从跟踪状态下移除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remove --cached &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<h3 id="移动文件-重命名"><a href="#移动文件-重命名" class="headerlink" title="移动文件/重命名"></a>移动文件/重命名</h3><p>类似于Linux一样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git mv file_from file_to</span><br></pre></td></tr></table></figure>

<h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p>使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>

<p>也可以为 git log 附带一系列的总结性选项。 比如你想看到每次提交的简略统计信息，可以使用 –stat 选项</p>
<h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit amend</span><br></pre></td></tr></table></figure>

<p>用来修改提交信息或补充几个忘记提交的文件而不至于弄乱提交历史。</p>
<h3 id="取消暂存文件"><a href="#取消暂存文件" class="headerlink" title="取消暂存文件"></a>取消暂存文件</h3><p>与git add filename对应：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset HEAD &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout --&lt;fiename&gt;</span><br></pre></td></tr></table></figure>

<p> 请务必记得 git checkout – <file> 是一个危险的命令。 对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令</p>
<h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote </span><br><span class="line">#列出指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字</span><br></pre></td></tr></table></figure>

<h3 id="添加、移除远程仓库"><a href="#添加、移除远程仓库" class="headerlink" title="添加、移除远程仓库"></a>添加、移除远程仓库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add &lt;shortname&gt; &lt;url&gt; </span><br><span class="line">git remote remove &lt;ahortname&gt;</span><br></pre></td></tr></table></figure>

<p>添加一个新的远程 Git 仓库，同时指定一个方便使用的简写</p>
<h3 id="从远程仓库抓取"><a href="#从远程仓库抓取" class="headerlink" title="从远程仓库抓取"></a>从远程仓库抓取</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch &lt;remote&gt;</span><br></pre></td></tr></table></figure>

<p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p>
<h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。</p>
<h3 id="查看远程仓库的信息"><a href="#查看远程仓库的信息" class="headerlink" title="查看远程仓库的信息"></a>查看远程仓库的信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote show &lt;shortname&gt;</span><br></pre></td></tr></table></figure>

<h3 id="远程仓库重命名"><a href="#远程仓库重命名" class="headerlink" title="远程仓库重命名"></a>远程仓库重命名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote  rename name1 name2</span><br></pre></td></tr></table></figure>

<h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p>​    像其他版本控制系统（VCS）一样，Git 可以给仓库历史中的某一个提交打上标签，以示重要。</p>
<h3 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag </span><br><span class="line">git tag -l &quot;关键词&quot;</span><br></pre></td></tr></table></figure>

<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>git支持两种标签：</p>
<p>​    1.轻量标签</p>
<p>​        某个特定提交的引用。</p>
<p>​    2.附注标签</p>
<p>​     附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。</p>
<p>创建附注标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建附注标签</span><br><span class="line">git tag -a &lt;tagname&gt; -m &quot;注释信息&quot;</span><br><span class="line">#查看所有标签</span><br><span class="line">git tag </span><br><span class="line">#显示注释信息</span><br><span class="line">git show &lt;tagname&gt;</span><br></pre></td></tr></table></figure>

<p>创建轻量标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag &lt;tagname&gt;</span><br></pre></td></tr></table></figure>

<h3 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h3><p>​    默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#推送特定标签</span><br><span class="line">git push origin &lt;tagname&gt;</span><br><span class="line">#推送所有标签 </span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>

<h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -d &lt;tagname&gt;</span><br><span class="line">#注意上述命令并不会从任何远程仓库中移除这个标签，你必须用 </span><br><span class="line">git push &lt;remote&gt; :refs/tags/&lt;tagname&gt; </span><br><span class="line">#来更新你的远程仓库,或者</span><br><span class="line">git push origin --delete &lt;tagname&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Git别名"><a href="#Git别名" class="headerlink" title="Git别名"></a>Git别名</h2><p>Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#git 别名</span><br><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.unstage &#x27;reset HEAD --&#x27;</span><br><span class="line">git config --global alias.last &#x27;log -1 HEAD&#x27;</span><br></pre></td></tr></table></figure>

<p>也可以在用户的配置文件下修改：</p>
<p>Windows下.config文件路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\username\.gitconfig</span><br></pre></td></tr></table></figure>

<p>添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[alias]</span><br><span class="line">	co = checkout</span><br><span class="line">	br = branch</span><br><span class="line">	ci = commit</span><br><span class="line">	st = status</span><br><span class="line">	unstage = reset HEAD --=</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>DSA</title>
    <url>/%E5%AD%A6%E4%B9%A0/dsa/</url>
    <content><![CDATA[<h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><p>数据结构和算法的重要性毋庸置疑啊，一方面刷题，一方面学习一下。<span id="more"></span></p>
<p>参考书籍清华邓俊辉教授撰写的《数据结构（C++语言版）》。</p>
<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>​    O(1):常数时间复杂度算法</p>
<p>​    O(logn):对数时间复杂度——高效算法</p>
<p>​    O(n):多项式时间复杂度算法.某问题若存在一个复杂度在此范围以内的算法，则称该问题是可有效求解的或易解的（tractable）</p>
<p>​    O(x**n):指数复杂度，无法接受的算法。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>​        递归则是函数和过程调用的一种特殊形式，即允许函数和过程进行<br>自我调用。</p>
<p>​        递归的价值在于，许多应用问题都可简洁而准确地描述为递归形式。</p>
<p>​    递归也是一种基本而典型的算法设计模式。这一模式可以对实际问题中反复出现的结构和形式做高度概括，并从本质层面加以描述与刻画，进而导出高效的算法。</p>
<h4 id="递归的基本模式"><a href="#递归的基本模式" class="headerlink" title="递归的基本模式"></a>递归的基本模式</h4><h5 id="线性递归"><a href="#线性递归" class="headerlink" title="线性递归"></a>线性递归</h5><p>举例：数组元素求和</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组求和：数组的前A[0,n-1)个数的和与末元素A[n-1]之和。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arraySum</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span>&gt;n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (<span class="built_in">arraySum</span>(A, n<span class="number">-1</span>) + A[n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度：O(1)*递归深度 = O(1) * (n+1) = O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)</span></span><br></pre></td></tr></table></figure>

<p>​        算法可能朝着更深一层进行自我调用，且每一递归实例对自身的调用至多一次。于是，每一层次上至多只有一个实例，且它们构成一个线性的次序关系。此类递归模式因而称作“线性递归”（linear recursion），它也是递归的最基本形式。</p>
<p>​    线性递归往往对应于<em><strong>减而治之</strong></em>的算法策略：递归每深入一层，待求解问题的规模都缩减一个常数，直至最终蜕化为平凡的小（简单）问题。</p>
<h5 id="递归分析"><a href="#递归分析" class="headerlink" title="递归分析"></a>递归分析</h5><p>1.递归跟踪：作为一种直观且可视的方法，递归跟踪（recursion trace）可用以分析递归算法的总体运行时间与空间。</p>
<p>2.递推方程：通过对递归模式的数学归纳，导出复杂度定界函数的递推方程（组）及其边界条件，从而将复杂度的分析，转化为递归方程（组）的求解。</p>
<h5 id="递归模式"><a href="#递归模式" class="headerlink" title="递归模式"></a>递归模式</h5><p>1.多递归基：为保证有穷性，递归算法都必须设置递归基，且确保总能执行到。</p>
<p>举例：数组倒置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(lo &lt; hi)&#123;</span><br><span class="line">		<span class="built_in">swap</span>(A[lo], A[hi]);</span><br><span class="line">		<span class="built_in">reverse</span>(A, lo+<span class="number">1</span>, hi<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//O(hi + lo -1)</span></span><br></pre></td></tr></table></figure>

<p>2.多向递归：递归算法中，不仅递归基可能有多个，递归调用也可能有多种可供选择的分支。</p>
<p>举例：求2**n</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inline __int64 sqr ( __int64 a ) &#123; return a * a; &#125;</span><br><span class="line">__int64 power2 ( int n ) &#123; //幂函数2^n算法（优化逑弻版），n &gt;= 0</span><br><span class="line"> 	if ( 0 == n ) return 1; //逑弻基；否则，规n癿奇偶分删逑弻</span><br><span class="line">    return ( n &amp; 1 ) ? sqr ( power2 ( n &gt;&gt; 1 ) ) &lt;&lt; 1 : sqr ( power2 ( n &gt;&gt; 1 ) );</span><br><span class="line">&#125; //O(logn) = O(r)，r为输入指数n癿比特位数</span><br></pre></td></tr></table></figure>

<h5 id="递归消除"><a href="#递归消除" class="headerlink" title="递归消除"></a>递归消除</h5><p>空间成本:递归算法所消耗的空间量主要取决于递归深度，故较之同一算法的迭代版，递归版往往需耗费更多空间，并进而影响实际的运行速度。</p>
<p>举例：尾递归消除</p>
<p>在线性递归算法中，若递归调用在递归实例中恰好以最后一步操作的形式出现，则称作尾递<br>归（tail recursion）。属于尾递归形式的算法，均可以简捷地转换为等效的迭代版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#数组倒置</span><br><span class="line">void reverse(int* A, int lo, int hi)&#123;</span><br><span class="line">next:</span><br><span class="line">	if(lo &lt; hi)&#123;</span><br><span class="line">		swap(A[lo], A[hi]);</span><br><span class="line">		lo++;</span><br><span class="line">		hi--;</span><br><span class="line">		goto next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;//O(hi - lo + 1)</span><br><span class="line"></span><br><span class="line">#用while 代替 next if</span><br><span class="line">void reverse(int* A, int lo, int hi)&#123;</span><br><span class="line">	while( lo &lt; hi )&#123;</span><br><span class="line">		swap(A[lo++], A[hi--]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二分递归"><a href="#二分递归" class="headerlink" title="二分递归"></a>二分递归</h5><p>分而治之：将大问题分解为若干规模更小的子问题，再通过递归机制分别求解。这种分解持续进行，直到子问题规模缩减至平凡情况。这也就是所谓的分而治之（divide-and-conquer）策略。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arraySum(int A[], int lo, int hi)&#123;</span><br><span class="line">	if( lo == hi)&#123;</span><br><span class="line">		return A[lo];</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		int mi = (lo + hi) &gt;&gt; 1;</span><br><span class="line">		return sum(A, lo, mi) + sum(A, mi+1, hi);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;//O(hi - lo +1)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记02</title>
    <url>/%E5%AD%A6%E4%B9%A0/gitNote02/</url>
    <content><![CDATA[<p>  Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。</p>
<span id="more"></span>

<h2 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h2><p>​        Git 保存的不是文件的变化或者差异，而是一系列不同时刻的快照 。在进行提交操作时，Git 会保存一个提交对象（commit object）。做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 master 分支会在每次提交时自动向前移动。</p>
<h3 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h3><p>创建新的分支实际就是创建一个新的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch &lt;branchname&gt;</span><br></pre></td></tr></table></figure>

<p>从而在当前所提交的对象上创建一个新的指针。</p>
<h3 id="查看分支所指对象"><a href="#查看分支所指对象" class="headerlink" title="查看分支所指对象"></a>查看分支所指对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --oneline  --decorate</span><br></pre></td></tr></table></figure>

<h3 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<p>此时，HEAD指针就指向了新的分支。</p>
<p><em><strong>分支切换会改变你工作目录中的文件</strong></em><br>在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。</p>
<p>不同的分支提交文件后就会产生项目分叉。</p>
<h3 id="查看分叉历史"><a href="#查看分叉历史" class="headerlink" title="查看分叉历史"></a>查看分叉历史</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --oneline --decorate --graph --all</span><br></pre></td></tr></table></figure>

<p>会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p>
<h3 id="创建分支的同时切换过去"><a href="#创建分支的同时切换过去" class="headerlink" title="创建分支的同时切换过去"></a>创建分支的同时切换过去</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;newbranchname&gt;</span><br></pre></td></tr></table></figure>

<h3 id="快进"><a href="#快进" class="headerlink" title="快进"></a>快进</h3><p>当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#先切换到你要保留的分支</span><br><span class="line">git checkout master</span><br><span class="line">#快进</span><br><span class="line">git merge &lt;branchName&gt;</span><br><span class="line">#删除已经合并的分支</span><br><span class="line">git branch -d &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>三方分别为：第一个分支，第二个分支，两分支的分叉点。</p>
<p>Git 将三方合并的结果做了一个新的快照并且自动创建一个新的提<br>交指向它。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#先切换到你要保留的分支</span><br><span class="line">git checkout master</span><br><span class="line">#三方合并</span><br><span class="line">git merge &lt;branchName&gt;</span><br><span class="line">#删除已经合并的分支</span><br><span class="line">git branch -d &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<h4 id="合并时遇到冲突"><a href="#合并时遇到冲突" class="headerlink" title="合并时遇到冲突"></a>合并时遇到冲突</h4><p>​        如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。</p>
<p>​        Git 会暂停下来，等待你去解决合并产生的冲突。你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件</p>
<p>​    在手动解决文件冲突后，可以再次提交，并确认分支合并。</p>
<h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看已有分支和当前所处分支</span><br><span class="line">git branch</span><br><span class="line">#查看已合并的分支</span><br><span class="line">git branch --merged</span><br><span class="line">#查看未合并的分支</span><br><span class="line">git branch --no-merged</span><br></pre></td></tr></table></figure>

<h2 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h2><h3 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h3><p>​        因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。</p>
<h3 id="主题分支"><a href="#主题分支" class="headerlink" title="主题分支"></a>主题分支</h3><p>​        主题分支对任何规模的项目都适用。 主题分支是一种短期分支，它被用来实现单一特性或其相关工作。</p>
<h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git ls-remote &lt;remote&gt; </span><br></pre></td></tr></table></figure>

<p>来显式地获得远程引用的完整列表， 或者通过 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote show &lt;remote&gt; </span><br></pre></td></tr></table></figure>

<p>获得远程分支的更多信息。 然而，一个更常见的做法是利用远程跟踪分支。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用过程中遇到的一些问题-01</title>
    <url>/%E5%AD%A6%E4%B9%A0/gitPushProblem/</url>
    <content><![CDATA[<h1 id="记录Git使用过程中存在的一些问题"><a href="#记录Git使用过程中存在的一些问题" class="headerlink" title="记录Git使用过程中存在的一些问题"></a>记录Git使用过程中存在的一些问题</h1><p>​    使用git的过程中总会遇到一些问题。</p>
<span id="more"></span>

<h2 id="用户绑定"><a href="#用户绑定" class="headerlink" title="用户绑定"></a>用户绑定</h2><p>​    用户使用前必须通过SSL密匙连接欸到GitHub账号。这样才能正常使用上传和下拉功能。</p>
<h2 id="push时使用-git-git"><a href="#push时使用-git-git" class="headerlink" title="push时使用 git@git"></a>push时使用 git@git</h2><p>​    向Github仓库push代码时显示;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://github.com/wz1114841863/OpenCV-SampleCode.git/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="出错原因"><a href="#出错原因" class="headerlink" title="出错原因"></a>出错原因</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/wz1114841863/OpenCV-SampleCode.git</span><br></pre></td></tr></table></figure>

<p>​    这里使用了 https传输协议，其他的解决方法并未尝试，这里直接换成了git@github</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>​    解除绑定，换成git@github：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git remote add origin git@github.com:wz1114841863/OpenCV-SampleCode.git</span><br></pre></td></tr></table></figure>

<p>​    接着重新上传，成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">Enumerating objects: 11, done.</span><br><span class="line">Counting objects: 100% (11/11), done.</span><br><span class="line">Delta compression using up to 16 threads</span><br><span class="line">Compressing objects: 100% (9/9), done.</span><br><span class="line">Writing objects: 100% (11/11), 16.79 MiB | 1.62 MiB/s, done.</span><br><span class="line">Total 11 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">To github.com:wz1114841863/OpenCV-SampleCode.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch &#x27;master&#x27; set up to track remote branch &#x27;master&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure>

<h2 id="忽略文件夹名大小写"><a href="#忽略文件夹名大小写" class="headerlink" title="忽略文件夹名大小写"></a>忽略文件夹名大小写</h2><p>git默认在提交时会忽略文件夹名的大小写，从而导致出现问题。</p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看本地仓库git忽略大小写是否打开</span><br><span class="line">$ git config --get core.ignorecase</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>true 表示忽略文件名大小写，可以将其设置为false。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config core.ignorecase false</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo_init</title>
    <url>/%E7%BD%91%E7%AB%99%E9%85%8D%E7%BD%AE/hexo-init/</url>
    <content><![CDATA[<h1 id="踩坑日记："><a href="#踩坑日记：" class="headerlink" title="踩坑日记："></a>踩坑日记：</h1><p>​    该踩的坑是一个都没少踩，记录一下自己踩的一些坑吧，好多都忘了。</p>
<p>​    <span id="more"></span></p>
<h2 id="Git不区分大小写"><a href="#Git不区分大小写" class="headerlink" title="Git不区分大小写"></a>Git不区分大小写</h2><p>​    查看别人如何实现仅显示部分内容时，都推荐使用“&lt;！– more –&gt;”来分割文章，尝试后本地可正常工作，而部署到github后点击 阅读全文 按钮后，显示文章404。最后发现url后显示为 …/others/Introduce.html 而实际上应该是 …/Others/Introduce.html，所以找不到对应文件。出现这个问题是因为windows版的git在上传文件夹时不区分大小写，导致出错，害的我以为是hexo的锅。修改为中文后就可以正显示。</p>
<img src="/images/hexo-init/hexo-init_01.png" >

<h2 id="侧边栏头像下不显示description"><a href="#侧边栏头像下不显示description" class="headerlink" title="侧边栏头像下不显示description"></a>侧边栏头像下不显示description</h2><p>​    不管如何设置全局配置文件的description都不能显示出来，后来知道next主题配置文件中有个seo的选项配置，用来优化搜索引擎，我也用不到，就全都false。</p>
<img src="/images/hexo-init/hexo-init_02.png" >

<p>​    然后依旧无法显示，查看网页源码，  …/themes/layout/_macro/sidebar.swig文件。</p>
<img src="/images/hexo-init/hexo-init_03.png" >

<p>​    可以看出，当seo = ture时显示signature，seo = false时显示description，索性我就直接在 next的主题配置文件中新加了两行：    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#test</span><br><span class="line"></span><br><span class="line">description: 今天不学习，明天变垃圾。</span><br><span class="line"></span><br><span class="line">signature: 今天不学习，明天变垃圾。</span><br></pre></td></tr></table></figure>



<p>​    就能正常显示了。</p>
<h2 id="侧边栏点击后显示报错"><a href="#侧边栏点击后显示报错" class="headerlink" title="侧边栏点击后显示报错"></a>侧边栏点击后显示报错</h2><p>​    next 主题官方的锅，menu下的每一项后的 ‘/‘与 ‘||’不能有空格。</p>
<img src="/images/hexo-init/hexo-init_04.png" > 

<h2 id="博客添加图片"><a href="#博客添加图片" class="headerlink" title="博客添加图片"></a>博客添加图片</h2><p>​    添加图片的坑更多了！！！</p>
<p>​    目前已知的方法有：</p>
<p>​        1.使用插件。（试过，但有问题，而且每个博客都会建一个文件夹来存放图片，很烦。）</p>
<p>​        2.使用图床。（需要注册图床，然后导出图片链接，快捷方法是 Typora 与 ipic 结合使用，不过ipic仅支持mac。不过也有大佬自己写了几个插件来使用。）</p>
<p>​        3.参考hexo官网，有以下描述。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 ![](/images/image.jpg) 的方法访问它们。</span><br></pre></td></tr></table></figure>

<p>​        缺点就是本地写博客时无法浏览，其他的都很方便，我就选择的是这种方式,，在source文件中自己创建了images文件夹，在Github上浏览时发现会和已有的images文件夹相加。同时注意这里使用的是绝对路径  /images/。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    还有好多坑都不记得了，不过最后还是依靠 百度+ 谷歌，全都解决了。</p>
]]></content>
      <categories>
        <category>网站配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV-Tutorials</title>
    <url>/%E5%AD%A6%E4%B9%A0/openCVtutorials/</url>
    <content><![CDATA[<h2 id="OpenCV官网例程实现"><a href="#OpenCV官网例程实现" class="headerlink" title="OpenCV官网例程实现"></a>OpenCV官网例程实现</h2><p>​    OpenCV官网提供了一系列例程，先照着实现一下，同时记录遇到的一些问题。</p>
<span id="more"></span>

<h3 id="CV与Matplotlib的颜色冲突"><a href="#CV与Matplotlib的颜色冲突" class="headerlink" title="CV与Matplotlib的颜色冲突"></a>CV与Matplotlib的颜色冲突</h3><p> OpenCV中读取彩图的颜色是以BGR来排序的，而Matplotlib中图片是以RGB排序的，因此如果想要使用pyplot来展示图片，就需要对图片的颜色域顺序进行处理，不过实现起来也很方便。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv.imread(<span class="string">&quot;o1.png&quot;</span>)</span><br><span class="line">img = img[:,:,::-<span class="number">1</span>]</span><br><span class="line">plt.show(<span class="string">&quot;Image&quot;</span>,img)</span><br></pre></td></tr></table></figure>

<h3 id="使用拉普拉斯算子获取图像边缘"><a href="#使用拉普拉斯算子获取图像边缘" class="headerlink" title="使用拉普拉斯算子获取图像边缘"></a>使用拉普拉斯算子获取图像边缘</h3><p>以下是示例和我按照示例的到的结果：</p>
<p>官方示例：</p>
<img src="/images/OpenCV/openCV_01.png">

<p>我的结果：</p>
<img src="/images/OpenCV/openCV_02.png">

<p>可以看出并没有得到示例中所展示的效果。</p>
<p>查看函数参数说明，可以看到有一项参数为：</p>
<p><strong>CV_<bit_depth>(S|U|F)C<number_of_channels></strong></p>
<p>说明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bit_depth：比特数---代表8bite,16bites,32bites,64bites...</span><br><span class="line"></span><br><span class="line">如果你现在创建了一个存储--灰度图片的Mat对象,这个图像的大小为宽100,高100,那么,现在这张灰度图片中有10000个像素点，它每一个像素点在内存空间所占的空间大小是8bite,8位--所以它对应的就是CV_8。</span><br><span class="line">-------------</span><br><span class="line"></span><br><span class="line">S|U|F:</span><br><span class="line"></span><br><span class="line">S--代表---signed int---有符号整形</span><br><span class="line"></span><br><span class="line">U--代表--unsigned int--无符号整形</span><br><span class="line"></span><br><span class="line">F--代表--float---------单精度浮点型</span><br><span class="line"></span><br><span class="line">---------</span><br><span class="line"></span><br><span class="line">C&lt;number_of_channels&gt;----代表---一张图片的通道数,比如:</span><br><span class="line"></span><br><span class="line">channels = 1：灰度图片--grayImg---是--单通道图像</span><br><span class="line"></span><br><span class="line">channels = 3：RGB彩色图像---------是--3通道图像</span><br><span class="line"></span><br><span class="line">channels = 4：带Alph通道的RGB图像--是--4通道图像</span><br><span class="line">————————————————</span><br></pre></td></tr></table></figure>

<p>修改参数为CV_8U后，调整内核大小，得到预期结果。</p>
<h3 id="绘制轮廓"><a href="#绘制轮廓" class="headerlink" title="绘制轮廓"></a>绘制轮廓</h3><p>看函数说明时，需要使用二值图片才能更好的识别轮廓。所以我就直接选择了使用二值图片去查找轮廓。但是再绘制轮廓时发现无法绘制轮廓，观察函数发现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv2.drawContours(image, contours, contourIdx, color, thickness=None, lineType=None, hierarchy=None, maxLevel=None, offset=None)</span><br></pre></td></tr></table></figure>

<p>其中要求image类型为彩色图片。所以就需要使用彩色图片从BGR-&gt;GRAY,在进行阈值化处理变为二值图片识别轮廓，最后再原图上画图。</p>
<h3 id="多对象模板匹配"><a href="#多对象模板匹配" class="headerlink" title="多对象模板匹配"></a>多对象模板匹配</h3><p>源代码见github仓库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#函数：cv.matchTemplate(), cv.minMaxLoc()</span><br><span class="line">import numpy as np</span><br><span class="line">import cv2 as cv </span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line">img7 = cv.imread(&quot;../Images/img7.jpg&quot;)</span><br><span class="line">img7 = cv.cvtColor(img7, cv.COLOR_BGR2GRAY)</span><br><span class="line">target = img7.copy()</span><br><span class="line">template = cv.imread(&quot;../Images/img7_1.png&quot;)</span><br><span class="line">template = cv.cvtColor(template, cv.COLOR_BGR2GRAY)</span><br><span class="line">w, h = template.shape[::-1]</span><br><span class="line">#列表中所有的6种比较方法</span><br><span class="line">methods = [&#x27;cv.TM_CCOEFF&#x27;, &#x27;cv.TM_CCOEFF_NORMED&#x27;, &#x27;cv.TM_CCORR&#x27;,</span><br><span class="line">            &#x27;cv.TM_CCORR_NORMED&#x27;, &#x27;cv.TM_SQDIFF&#x27;, &#x27;cv.TM_SQDIFF_NORMED&#x27;]</span><br><span class="line">for meth in methods:</span><br><span class="line">    img7 = target.copy()</span><br><span class="line">    method = eval(meth)</span><br><span class="line">    # 应用模板匹配</span><br><span class="line">    res = cv.matchTemplate(img7,template,method)</span><br><span class="line">    min_val, max_val, min_loc, max_loc = cv.minMaxLoc(res)</span><br><span class="line">    # 如果方法是TM_SQDIFF或TM_SQDIFF_NORMED，则取最小值</span><br><span class="line">    if method in [cv.TM_SQDIFF, cv.TM_SQDIFF_NORMED]:</span><br><span class="line">        top_left = min_loc</span><br><span class="line">    else:</span><br><span class="line">        top_left = max_loc</span><br><span class="line">    bottom_right = (top_left[0] + w, top_left[1] + h)</span><br><span class="line">    cv.rectangle(img7,top_left, bottom_right, 255, 2)</span><br><span class="line">    plt.subplot(121),plt.imshow(res,cmap = &#x27;gray&#x27;)</span><br><span class="line">    plt.title(&#x27;Matching Result&#x27;), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(122),plt.imshow(img7,cmap = &#x27;gray&#x27;)</span><br><span class="line">    plt.title(&#x27;Detected Point&#x27;), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.suptitle(meth)</span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line">#多对象匹配</span><br><span class="line">img22 = cv.imread(&quot;../Images/img22.png&quot;)</span><br><span class="line">img22_gray = cv.cvtColor(img22, cv.COLOR_BGR2GRAY)</span><br><span class="line">#plt.imshow(img22_gray,&#x27;gray&#x27;)</span><br><span class="line">#plt.show()</span><br><span class="line">template = cv.imread(&#x27;../Images/img22_1.png&#x27;)</span><br><span class="line">template_gray = cv.cvtColor(template, cv.COLOR_BGR2GRAY)</span><br><span class="line">#plt.imshow(template_gray,&#x27;gray&#x27;)</span><br><span class="line">#plt.show()</span><br><span class="line">w, h = template_gray.shape[:: -1]</span><br><span class="line">print(w,h)</span><br><span class="line">res = cv.matchTemplate(img22_gray, template_gray, cv.TM_CCOEFF_NORMED)</span><br><span class="line">threshold = 0.55</span><br><span class="line">loc = np.where( res &gt;= threshold)</span><br><span class="line">for pt in zip(*loc[::-1]):</span><br><span class="line">    cv.rectangle(img22, pt, (pt[0] + w , pt[1]+ h), (0,255,255), 2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">cv.imshow(&quot;image&quot;,img22 )</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">img22 = img22[:, :, :: -1]</span><br><span class="line">plt.imshow(img22)</span><br><span class="line">plt.show()</span><br><span class="line">#错误原因分析：因为匹配时采用灰度图像，所以水管被匹配到了</span><br></pre></td></tr></table></figure>

<p>遇到的问题：</p>
<p>​    刚开始绘制正方形时，整个图片全部变为黄色，后来意识到是因为阈值太低和匹配模式选择的问题。通过调整匹配模式和阈值，能大致匹配到合适位置，但由于匹配时采用的是灰度图片，所以水管口依旧被匹配到了，还需要进一步改进。</p>
<h3 id="图片绘制形状"><a href="#图片绘制形状" class="headerlink" title="图片绘制形状"></a>图片绘制形状</h3><p>由于OpenCV读取的图片以BGR格式存储，如果想用plot绘图就需要用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">img = img[:, :, :: -1]</span><br></pre></td></tr></table></figure>

<p>但是如果想要在图形上绘图就不能先转变将图片变为RGB格式，否则无法绘制矩形等形状且不报错。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Introduce</title>
    <url>/%E5%85%B6%E4%BB%96/introduce/</url>
    <content><![CDATA[<p>无意间看到可以用GitHub来发博客，便心血来潮自己也搞了一个。</p>
<span id="more"></span>正好刚考上研究生，希望能够用来记录自己的一些学习路线或者学习心得之类的，也希望自己不要太懒惰(笑)。



]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>闲聊</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu使用中遇到的问题</title>
    <url>/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/ubuntuUsing/</url>
    <content><![CDATA[<h2 id="使用Ubuntu图形界面"><a href="#使用Ubuntu图形界面" class="headerlink" title="使用Ubuntu图形界面"></a>使用Ubuntu图形界面</h2><p>​    之前使用一直都用服务器所以没有接触过Ubuntu的图形界面，还是第一次电脑上装Ubuntu系统。<span id="more"></span></p>
<h2 id="语言选择"><a href="#语言选择" class="headerlink" title="语言选择"></a>语言选择</h2><p>   没想到语言选择第一步就难住了我，安装的是中文版到但是一直没能成功设置为中文。直到看到一个鬼才方法。具体步骤如下：</p>
<p>​    1.找到Ubuntu中Language support软件</p>
<p>​    2.打开软件后添加简体中文语言包</p>
<p>​    3.现在依然显示汉语为灰色无法选中，但是可以拖动！！！将汉语那一框拖动到最上面去，然后重启就可以了。</p>
<p>参考的博客链接为：</p>
<p><a href="https://blog.csdn.net/qq_42007712/article/details/82832725?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.base&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.base">https://blog.csdn.net/qq_42007712/article/details/82832725?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.base&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.base</a></p>
]]></content>
      <categories>
        <category>系统配置</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>一些有用的小技巧</title>
    <url>/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/windowsUsing/</url>
    <content><![CDATA[<h1 id="实用小技巧"><a href="#实用小技巧" class="headerlink" title="实用小技巧"></a>实用小技巧</h1><p>遇到的一些有用的软件或者一些比较有用的设置。<span id="more"></span></p>
<h2 id="Windows右键新建中增加新建md文件"><a href="#Windows右键新建中增加新建md文件" class="headerlink" title="Windows右键新建中增加新建md文件"></a>Windows右键新建中增加新建md文件</h2><p>推荐使用Typora来编写MarkDown文档。</p>
<h3 id="添加方式"><a href="#添加方式" class="headerlink" title="添加方式"></a>添加方式</h3><p> 1.右键新建 .txt 文件，不用命名不重要， 在文件中写进以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\.md]</span><br><span class="line">@=&quot;typora.md&quot;</span><br><span class="line">&quot;icon&quot;=&quot;D:\\Typora\\typora.exe&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\.md\OpenWithProgids]</span><br><span class="line">&quot;Typora.md&quot;=&quot;&quot;</span><br><span class="line">&quot;VSCode.md&quot;=&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\.md\ShellNew]</span><br><span class="line">&quot;NullFile&quot;=&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>注意：修改上述的typora文件路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;icon&quot;=&quot;D:\\Typora\\typora.exe&quot; --&gt; “修改成你自己的文件路径”</span><br></pre></td></tr></table></figure>

<p>2.保存后重命名，修改后缀为  .reg 文件。</p>
<p>3.双击执行，一路点是就行。</p>
<h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><img src = "/images/createMd/createMd01.png">

<h2 id="Adobe-Acrobat-Pro-DC设置文档打开时铺满全局"><a href="#Adobe-Acrobat-Pro-DC设置文档打开时铺满全局" class="headerlink" title="Adobe Acrobat Pro DC设置文档打开时铺满全局"></a>Adobe Acrobat Pro DC设置文档打开时铺满全局</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>修改首选项里的页面设置，全局视图—&gt;适合宽度。</p>
<h4 id="缺点：点击书签访问时，依旧会出现不能铺满屏幕的状况。"><a href="#缺点：点击书签访问时，依旧会出现不能铺满屏幕的状况。" class="headerlink" title="缺点：点击书签访问时，依旧会出现不能铺满屏幕的状况。"></a>缺点：点击书签访问时，依旧会出现不能铺满屏幕的状况。</h4><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>选中所有书签（ctrl+A）——属性——动作——添加动作选择——执行菜单项——添加——“视图&gt;缩放&gt;适合宽度”</p>
<p>这样点击书签后，就是适合宽度了。</p>
]]></content>
      <categories>
        <category>系统配置</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>learing_route</title>
    <url>/%E5%85%B6%E4%BB%96/learing-route/</url>
    <content><![CDATA[<h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><p>​    本科专业是电子工程与技术，研究生报考的也是本院的实验室，未曾想研究方向居然是CV。塞翁失马，焉知非福。不管怎么说。也算是接触一个全新的领域，还有很多东西需要去学，所以也做一个小小的规划。<span id="more"></span></p>
<h2 id="编程语言学习"><a href="#编程语言学习" class="headerlink" title="编程语言学习"></a>编程语言学习</h2><h3 id="C-：从入门到入土"><a href="#C-：从入门到入土" class="headerlink" title="C++：从入门到入土"></a>C++：从入门到入土</h3><p>​        大学时期没有了解过C++，但是OpenCV等好多底层文件都是用C++写的，那咋办嘛，学呗。</p>
<h3 id="OpenCV-C-Python"><a href="#OpenCV-C-Python" class="headerlink" title="OpenCV: C++/Python"></a>OpenCV: C++/Python</h3><p>​        总感觉和OpenCV有种莫名的缘分(笑)，OpenCV分为C++和Python两种版本，各有优劣，应该会用到很多吧。</p>
<h3 id="Python：-人人都会的编程语言"><a href="#Python：-人人都会的编程语言" class="headerlink" title="Python： 人人都会的编程语言"></a>Python： 人人都会的编程语言</h3><p>​        python只能说 会写但没完全会。</p>
<h2 id="机器学习-深度学习"><a href="#机器学习-深度学习" class="headerlink" title="机器学习/深度学习"></a>机器学习/深度学习</h2><p>​        没了解之前确实觉得机器学习和深度学习都蛮神秘的，了解之后，嗯，都是我学不会的东西呢。</p>
<h3 id="pytorch框架"><a href="#pytorch框架" class="headerlink" title="pytorch框架"></a>pytorch框架</h3><p>​        应该需要去了解一下这个框架，跟tensorflow相比好像更容易一点。</p>
<h3 id="花书-西瓜书-鱼书"><a href="#花书-西瓜书-鱼书" class="headerlink" title="花书/西瓜书/鱼书"></a>花书/西瓜书/鱼书</h3><p>​        收藏从未停止，学习从未开始。</p>
<h2 id="计算机基础四大件："><a href="#计算机基础四大件：" class="headerlink" title="计算机基础四大件："></a>计算机基础四大件：</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>​            为什么要为难我一个电子院出身的人呢。问就是北邮特色，不会真有不会编程的北邮人吧。</p>
<h2 id="LeetCode刷题"><a href="#LeetCode刷题" class="headerlink" title="LeetCode刷题"></a>LeetCode刷题</h2><p>​            刚清空之前的刷题记录，虽然也没几道就是了(/(ㄒoㄒ)/~~)。问就是要加油啊。</p>
<h2 id="Liunx-shell编程"><a href="#Liunx-shell编程" class="headerlink" title="Liunx/shell编程"></a>Liunx/shell编程</h2><p>​            多练练手，别忘光了就好。</p>
<p>​    </p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>闲聊</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读过的书</title>
    <url>/%E5%AD%A6%E4%B9%A0/readedBooks/</url>
    <content><![CDATA[<p>  今天正好是情人节，就打算从今天开始记录自己看过的一些书，也不仅仅是学习方面的书，也包括网络小说，轻小说等等，五花八本的书都算,但起码看了得有意义，看完了没什么意思的书就没什么好记录的了。别人过节我看书，我也没有特别羡慕人家了！<span id="more"></span></p>
<h3 id="lt-lt-C-primer-gt-gt-2021-08-14"><a href="#lt-lt-C-primer-gt-gt-2021-08-14" class="headerlink" title="&lt;&lt;C++ primer&gt;&gt;  2021/08/14"></a>&lt;&lt;C++ primer&gt;&gt;  2021/08/14</h3><p>这本书看了得有两个月，C++入门经典书籍，虽然看完了我也还没入门就是了。不过这本书也不是一遍就能掌握的，以后还需要经常翻阅就是了。C++11的很多新特性也没涉及到，哭了。</p>
<h3 id="lt-lt-日常系的异能战斗-gt-gt-2021-08-18"><a href="#lt-lt-日常系的异能战斗-gt-gt-2021-08-18" class="headerlink" title="&lt;&lt;日常系的异能战斗&gt;&gt;  2021/08/18"></a>&lt;&lt;日常系的异能战斗&gt;&gt;  2021/08/18</h3><p>动画是好几年前开始看的。小说看了几卷，没想到还有机会看完全本呢。结局或许直接给个后宫结局更好一点。好看！动漫也是，虽然只有一集，但给我留了很深的印象。</p>
<img src = "/images/readedBBooks/01.png">

<h3 id="lt-lt-我的系统总想逼我表白-gt-gt-2021-08-21"><a href="#lt-lt-我的系统总想逼我表白-gt-gt-2021-08-21" class="headerlink" title="&lt;&lt;我的系统总想逼我表白&gt;&gt;  2021/08/21"></a>&lt;&lt;我的系统总想逼我表白&gt;&gt;  2021/08/21</h3><p>硬了硬了，拳头硬了。</p>
<p>不知道别人怎么看，不过很符合我的口味。国轻里面很不错的一本。对话幽默风趣，故事情节也很流畅，女主角的性格都很不错。就是结尾太仓促，不过番外很甜。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>闲聊</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL 必知必会</title>
    <url>/%E5%AD%A6%E4%B9%A0/MySQL/SQL_00/</url>
    <content><![CDATA[<p>&lt;&lt;SQL必知必会&gt;&gt;学习笔记。<span id="more"></span></p>
<h1 id="第章"><a href="#第章" class="headerlink" title="第章"></a>第章</h1>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp Primer chapter 2.4</title>
    <url>/%E5%AD%A6%E4%B9%A0/cppPrimerCh02_4/</url>
    <content><![CDATA[<p>C++ Primer 第二篇第六章学习笔记。<span id="more"></span></p>
<h1 id="第二篇-基本语言"><a href="#第二篇-基本语言" class="headerlink" title="第二篇 基本语言"></a>第二篇 基本语言</h1><h3 id="第六章-抽象容器类型"><a href="#第六章-抽象容器类型" class="headerlink" title="第六章  抽象容器类型"></a>第六章  抽象容器类型</h3><h4 id="顺序容器：由单一类型元素组成的一个有序集合。"><a href="#顺序容器：由单一类型元素组成的一个有序集合。" class="headerlink" title="顺序容器：由单一类型元素组成的一个有序集合。"></a>顺序容器：由单一类型元素组成的一个有序集合。</h4><ol>
<li>list：双向链表</li>
<li>vector：向量</li>
<li>deque：双端队列</li>
</ol>
<h4 id="关联容器：支持查询一个元素是否存在并且可以有效地获取元素"><a href="#关联容器：支持查询一个元素是否存在并且可以有效地获取元素" class="headerlink" title="关联容器：支持查询一个元素是否存在并且可以有效地获取元素"></a>关联容器：支持查询一个元素是否存在并且可以有效地获取元素</h4><ol>
<li>map：键值对</li>
<li>set：单一键值</li>
</ol>
<h4 id="文本查询系统"><a href="#文本查询系统" class="headerlink" title="文本查询系统"></a>文本查询系统</h4><p>任务支持：</p>
<p>1.它必须允许用户指明要打开的文本文件的名字<br>2.它必须在内部组织文本文件以便能够识别出每个单词在句子中出现的次数以及在<br>该句子中的位置<br>3.它必须支持某种形式的布尔查询语言在我们的例子中它将支持<br>        &amp;&amp; 在一行中两个单词不仅存在而且相邻<br>        || 在一行中两个单词至少有一个存在<br>        ! 在一行中该单词不存在<br>        () 把子查询组合起来的方式</p>
<p>注意：为了简化实现我们要求用空格分割每个单词包括括号和布尔操作符</p>
<h4 id="选择vector还是list"><a href="#选择vector还是list" class="headerlink" title="选择vector还是list"></a>选择vector还是list</h4><h5 id="选择依据："><a href="#选择依据：" class="headerlink" title="选择依据："></a>选择依据：</h5><p>vector deque 以及list 都是动态增长的，在这三者之中选择的准则主要是<strong>关注插入特性以及对元素的后续访问要求</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果我们需要随机访问一个容器则vector 要比list 好得多。</span><br><span class="line">如果我们已知要存储元素的个数则vector 又是一个比list 好的选择。</span><br><span class="line">如果我们需要的不只是在容器两端插入和删除元素则list 显然要比vector 好。</span><br><span class="line">除非我们需要在容器首部插入和删除元素否则vector 要比deque 好。</span><br></pre></td></tr></table></figure>

<h4 id="vector怎样自己增长"><a href="#vector怎样自己增长" class="headerlink" title="vector怎样自己增长"></a>vector怎样自己增长</h4><p>​    获取vector的容量：容量是指在容器下一次需要增长自己之前能够被加入到容器中的元素的总数，容量只与连续存储的容器相关（例如vector deque 或string）， list 不要求容量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取容器的容量</span><br><span class="line">capacity()</span><br><span class="line">//容器当前拥有元素的个数</span><br><span class="line">size()</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ivec:size:&quot;</span> &lt;&lt; ivec.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;   &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; ivec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> ix=<span class="number">0</span>; ix&lt;<span class="number">24</span>; ix++)&#123;</span><br><span class="line">        ivec.<span class="built_in">push_back</span>(ix);</span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;ivec:size:&quot;</span> &lt;&lt; ivec.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;   &quot;</span></span><br><span class="line">         	 &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; ivec.<span class="built_in">capacity</span>() &lt;&lt; endl;        </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过指针间接存储复杂的类对象。即vector中仅存储指向复杂对象的指针，就不用重新释放对象和生成对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reserve()操作允许程序员将容器的容量设置成一个显式指定的值。</span><br></pre></td></tr></table></figure>

<h4 id="定义一个顺序容器"><a href="#定义一个顺序容器" class="headerlink" title="定义一个顺序容器"></a>定义一个顺序容器</h4><p>关联的头文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#inlucde &lt;set&gt;</span><br></pre></td></tr></table></figure>

<p>声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//简单声明</span><br><span class="line">vector&lt;string&gt;  svec;</span><br><span class="line">//指定长度</span><br><span class="line">list&lt; int &gt;  ilist( list_size );</span><br><span class="line">vector&lt; string &gt; svec(get_word_count(string(&quot;Chimera&quot;)));</span><br><span class="line">//指定长度和初始值</span><br><span class="line">list&lt; int &gt; ilist( list_size, - 1 );</span><br><span class="line">vector&lt; string &gt; svec( 24, &quot;pooh&quot; );</span><br><span class="line">//利用已有对象初始化</span><br><span class="line">vector&lt; string &gt; svec2( svec );</span><br><span class="line">list&lt; int &gt; ilist2( ilist );    </span><br></pre></td></tr></table></figure>

<p>其余操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//检查是否为空</span><br><span class="line">if(svec.empty() != True)&#123;</span><br><span class="line">	cout &lt;&lt; &quot;empty.&quot;</span><br><span class="line">&#125;</span><br><span class="line">//插入尾部</span><br><span class="line">string text_word;</span><br><span class="line">while(cin &gt;&gt; text_word)&#123;</span><br><span class="line">	svec.push_back(text_word);</span><br><span class="line">&#125;</span><br><span class="line">//list 和 deque 容器也支持 push_front() 它把新元素插入在链表的前端</span><br><span class="line"></span><br><span class="line">//重新设置长度</span><br><span class="line">svec.resize( 2 * svec.size(), &quot;piglet&quot; );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>迭代器（iterator ）提供了一种一般化的方法对顺序或关联容器类型中的每个元素进行<br>连续访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">++iter;//指向下一个元素</span><br><span class="line">//iterator 算术论算只适用于vector 或deque 而不适用于list 因为list 的元素在内存中不是连续存储的.</span><br><span class="line">*iter;//指向元素的值</span><br><span class="line">/*</span><br><span class="line">返回iterator 指向元素的值</span><br><span class="line">每种容器类型都提供一个begin()和一个end()成员函数</span><br><span class="line">begin()返回一个iterator 它指向容器的第一个元素</span><br><span class="line">end()返回一个iterator 它指向容器的末元素的下一个位置</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>为了迭代任意容器类型的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(iter=container.begin(); iter!=container.end(); ++iter)&#123;</span><br><span class="line">	do_some_thing_with_element(*iter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// vector&lt;string&gt; vec;</span><br><span class="line">vector&lt;string&gt;::iterator iter = vec.begin();</span><br><span class="line">vector&lt;string&gt;::iterator iter_end = vec.end();</span><br></pre></td></tr></table></figure>

<p>利用迭代器初始化容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; svec2( svec.begin(), svec.end() );</span><br></pre></td></tr></table></figure>

<p>两个指向内置数组的指针也可以被用作元素范围标记器（range marker）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt; string &gt; vwords( words, words+4 );</span><br></pre></td></tr></table></figure>

<h4 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h4><p>1.插入：insert()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt; string &gt; svec;</span><br><span class="line">list&lt; string &gt; slist;</span><br><span class="line">string spouse( &quot;Beth&quot; );</span><br><span class="line">slist.insert(slist.begin(), spouse)</span><br><span class="line">svec.insert(svec.begin(), spouse)</span><br><span class="line"></span><br><span class="line">list&lt;string&gt;::iterator iter;</span><br><span class="line">iter = find( slist.begin(), slist.end(), son );</span><br><span class="line">slist.insert( iter, spouse );</span><br></pre></td></tr></table></figure>

<ol>
<li>insert()方法的第一种形式支持在某个位置插入指定的元素。</li>
<li>insert()方法的第二种形式支持在某个位置插入指定数量的元素。</li>
<li>insert()方法的第三种形式支持向容器插入一段范围内的元素。</li>
</ol>
<p>2.删除：erase()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string searchValue( &quot;Quasimodo&quot; );</span><br><span class="line">list&lt; string &gt;::iterator iter = find( slist.begin(), slist.end(), searchValue );</span><br><span class="line">if ( iter != slist.end() )&#123;</span><br><span class="line">	slist.erase( iter );</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>​        如同在容器尾部插入一个元素的push_back()方法相仿pop_back()方法删除容器的末元素——它不返回元素只是简单地删除它</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt; string &gt;::iterator iter = buffer.begin();</span><br><span class="line">for ( ; iter != buffer.end(); iter++ )&#123;</span><br><span class="line">	slist.push_back( *iter );</span><br><span class="line">	if ( ! do_something( slist ))</span><br><span class="line">		slist.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.交换：swap()</p>
<p>swap()可以被看作是赋值操作符的互补操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slist1.swap( slist2 );</span><br></pre></td></tr></table></figure>

<p>4.泛型算法：</p>
<p>把所有容器类型的公共操作抽取出来形成一个通用算法集合它能够被应用到全部容器类型以及内置数组类型上，这组通用算法被称作泛型算法。泛型算法通过一个iterator 对，被绑定到一个特殊的容器上。</p>
<p>示例：find()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">int ia[6] = &#123;0, 1, 2, 3, 4, 5&#125;;</span><br><span class="line">vector&lt;string&gt; svec;</span><br><span class="line">list&lt;double&gt; dlist;</span><br><span class="line"></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">// 如果找到, find()返回指向该元素的iterator</span><br><span class="line">// 对于数组, 返回指针</span><br><span class="line">vector&lt;string&gt;::iterator viter;</span><br><span class="line">list&lt;double&gt;::iterator liter;</span><br><span class="line">int *pia;</span><br><span class="line"></span><br><span class="line">pia = find( &amp;ia[0], &amp;ia[6], some_int_value );</span><br><span class="line">liter = find( dlist.begin(), dlist.end(), some_double_value );</span><br><span class="line">viter = find( svec.begin(), svec.end(), some_string_value );</span><br></pre></td></tr></table></figure>

<h4 id="存储文本行"><a href="#存储文本行" class="headerlink" title="存储文本行"></a>存储文本行</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; *retrieve_text()&#123;</span><br><span class="line"></span><br><span class="line">    string filename;</span><br><span class="line">    cout &lt;&lt; &quot;please input the filename:&quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; filename;</span><br><span class="line">    //打开文本文件</span><br><span class="line">    ifstream infile(filename.c_str(), ios::in);</span><br><span class="line">    if( ! infile )&#123;</span><br><span class="line">        cerr &lt;&lt; &quot;Open file failed.&quot; &lt;&lt; endl;</span><br><span class="line">        exit(-1)</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //读文件</span><br><span class="line">    vector&lt;string&gt; *lines_of_text = new vector&lt;string&gt;;</span><br><span class="line">    string textLine;</span><br><span class="line">    //定义别名</span><br><span class="line">    typedef pair&lt;string::size_type, int&gt; stats;</span><br><span class="line">    stats maxline;</span><br><span class="line">    int linenum = 0;</span><br><span class="line"></span><br><span class="line">    while( getline(infile, textLine, &#x27;\n&#x27;))&#123;</span><br><span class="line">        cout &lt;&lt; &quot;line read: &quot; &lt;&lt; textLine &lt;&lt; endl;</span><br><span class="line">        if(maxline.first &lt;&lt; textLine.size())&#123;</span><br><span class="line">            maxline.first = textline.size();</span><br><span class="line">            maxline.second = linenum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lines_of_text-&gt;push_back(textLine);</span><br><span class="line">        linenum++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return lines_of_text;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="找到一个子串"><a href="#找到一个子串" class="headerlink" title="找到一个子串"></a>找到一个子串</h4><p>​        string 类提供了一套查找函数都以find 的各种变化形式命名find()是最简单的实例给出一个字符串它返回匹配子串的第一个字符的索引位置或者返回一个特定的值：string::npos。</p>
<p>​    find_first_of()查找与被搜索字符串中任意一个字符相匹配的第一次出现并返回它的索引位置。</p>
<p>​        find_last_of()查找字符串中的与搜索字符串任意元素相匹配 的最后一个字符 find_last_not_of()查找字符串中的与搜索字符串任意字符全不匹配的最后一个字符这些操作都有一个可选的第二参数来指明起始的查找位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//存储单词及其位置</span><br><span class="line">typedef pair&lt;short, short&gt; location;</span><br><span class="line">typedef vector&lt;location&gt; loc;</span><br><span class="line">typedef vector&lt;string&gt; text;</span><br><span class="line">typedef pair&lt;text *, loc *&gt; text_loc;</span><br><span class="line"></span><br><span class="line">text_loc* separate_words(const vector&lt;string&gt; *text_file)&#123;</span><br><span class="line">    //words:包含独立单词的集合</span><br><span class="line">    //locations：包含相关的行列信息。</span><br><span class="line">    vector&lt;string&gt; *words = new vector&lt;string&gt;;</span><br><span class="line">    vector&lt;location&gt; *locations = new vector&lt;location&gt;;</span><br><span class="line">    short line_pos = 0; //当前行号。</span><br><span class="line">    //迭代文本每行。</span><br><span class="line">    for (; line_pos &lt; text_file.size(); line_pos++)&#123;</span><br><span class="line">        // textline: 待处理的当前文本行</span><br><span class="line">        // word_pos: 文本行中的当前列位置</span><br><span class="line">        short word_pos = 0;</span><br><span class="line">        string textline = (*text_file)[ line_pos ];</span><br><span class="line">        string::size_type pos = 0, prev_pos = 0;</span><br><span class="line">        while (( pos = textline.find_first_of( &#x27; &#x27;, pos )) != string::npos )&#123;</span><br><span class="line">            // 存储当前单词子串的拷贝</span><br><span class="line">            words-&gt;push_back(</span><br><span class="line">            textline.substr( prev_pos, pos - prev_pos ));</span><br><span class="line">            // 将行/列信息存储为pair</span><br><span class="line">            locations -&gt;push_back(</span><br><span class="line">            make_pair( line_pos, word_pos ));</span><br><span class="line">            // 为下一次迭代修改位置信息</span><br><span class="line">            ++word_pos; prev_pos = ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        // 现在处理最后一个单词</span><br><span class="line">        words-&gt;push_back(textline.substr( prev_pos, pos - prev_pos ));</span><br><span class="line">        locations-&gt;push_back(make_pair( line_pos, word_pos ));</span><br><span class="line">    &#125;</span><br><span class="line">    return new text_loc( words, locations );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理标点符号"><a href="#处理标点符号" class="headerlink" title="处理标点符号"></a>处理标点符号</h4><p>定义一个字符串，包括所有希望去掉的字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string filt_elem(&quot;\&quot;,.:;!?)(\\/&quot;);</span><br></pre></td></tr></table></figure>

<p>用find_first_of()操作在我们的字符串里找到每个匹配元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (( pos = word.find_first_of( filt_elems, pos ))!= string::npos )</span><br></pre></td></tr></table></figure>

<p>用erase()去掉字符串中的标点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">word.erase(pos, 1);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//删除标点符号</span><br><span class="line">void filter_text(vector&lt;string&gt; *words, string filter)&#123;</span><br><span class="line">    vector&lt;string&gt;::iterator iter = words-&gt;begin();</span><br><span class="line">    vector&lt;string&gt;::iterator iter_end = words-&gt;end();</span><br><span class="line">    //如果没有提供filter,则默认使用最小值.</span><br><span class="line">    if (!filter.size())&#123;</span><br><span class="line">        filter.insert(0, &quot;\&quot;,.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //迭代</span><br><span class="line">    while( iter != iter_end)&#123;</span><br><span class="line">        string::size_type pos = 0;</span><br><span class="line">        //遂于每个找到的元素将其删除。</span><br><span class="line">        while((pos = (*iter).find_first_of(filter, pos)) != string::npos)&#123;</span><br><span class="line">            (*iter).erase(pos, 1);</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任意其他形式的字符串"><a href="#任意其他形式的字符串" class="headerlink" title="任意其他形式的字符串"></a>任意其他形式的字符串</h4><p>文本查询系统的一件麻烦事情就是需要识别不同时态的同一个词如cry cries 和cried不同数目的同一个词如baby babies 以及大小写不同的同一个词如home 和Home。</p>
<h4 id="其他string操作"><a href="#其他string操作" class="headerlink" title="其他string操作"></a>其他string操作</h4><p>erase():</p>
<p>​    1.指定位置删除字符串元素。</p>
<p>​    2.利用一对迭代器来删除字符串元素。</p>
<p>​    3.利用单个迭代器来删除字符串元素。</p>
<p>insert():</p>
<p>​    1.将另外的字符插入到指定的位置。</p>
<p>​    2.支持插入new_string 的一个子部分。</p>
<p>assign()、append()：</p>
<p>​    1.把一个string 对象的部分拷贝或连接到另一个string 对象上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s3.assign( s1, 0, 4 ).append( &#x27; &#x27; ).append( s2, 0, 4 );</span><br></pre></td></tr></table></figure>

<p>swap()：</p>
<p>​    1.交换两个string 的值。</p>
<p>at():</p>
<p>​    1.对索引值的范围检查如果索引是有效的则at()返回相关的字符元素与下标操作符的方式相同但是如果索引无效则at()抛出out_of_range 异常.</p>
<p>compare():</p>
<p>​    1.提供了两个字符串的字典序比较</p>
<p>replace():</p>
<p>​    1.用一个或多个字符替换字符串中的一个或多个现有的字符(现有字符与替换字符的数目可以不等).</p>
<h4 id="生成文本位置map"><a href="#生成文本位置map" class="headerlink" title="生成文本位置map"></a>生成文本位置map</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">string query(&quot;pickle&quot;)</span><br><span class="line">vector&lt;location&gt; *locat;</span><br><span class="line">//返回与“pickle”相关的vector&lt;location&gt;*</span><br><span class="line">locat = text_map[ query ];</span><br></pre></td></tr></table></figure>

<p>6.12.1 定义并生成map</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#为了定义map对象，要指明键值对的类型。</span><br><span class="line">map&lt;strint, int&gt; word_count;</span><br><span class="line"></span><br><span class="line">class employee;</span><br><span class="line">map&lt;int, employee*&gt; personnel;</span><br></pre></td></tr></table></figure>

<p>用下标操作符把map 初始化至一组元素集合会使每个值都被初始化为缺省值,然后再被赋值为显式的值如果元素是类对象而且它的缺省初始化和赋值的运算量都很大,就会影响程序的性能尽管不会影响程序的正确性。</p>
<p>有两种情况需要考虑<br>1.map 中还没有单词在这种情况下需要插入键/值对<br>2.单词已经被插入在这种情况下需要用另外的行列信息修改该项的位置vector</p>
<p>6.12.2 查找并获取map中的元素</p>
<p>1.Count(keyValue) ：</p>
<p>count()返回map 中keyValue 出现的次数，当然对于map而言返回值只能是0 或1。如果返回值非0 我们就可以安全地使用下标操作符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ( word_count.count( &quot;wrinkles&quot; ))</span><br><span class="line">	count = word_count[ &quot;wrinkles&quot; ];</span><br></pre></td></tr></table></figure>

<p>2.Find(keyValue) ：</p>
<p>如果实例存在则find()返回指向该实例的iterator ，如果不存在则返回等于end()的iterator。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ( it != word_count.end() )</span><br><span class="line">	count = (*it).second;</span><br></pre></td></tr></table></figure>

<p>指向map 中元素的iterator 指向一个pair 对象，其中first 拥有键， second 拥有值。</p>
<p>6.12.3 对map 进行迭代</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ( ! text_map-&gt;empty() )</span><br><span class="line">	display_map_text( text_map );</span><br></pre></td></tr></table></figure>

<p>可以通过迭代器从begin() 到 end()来遍历map。</p>
<p>6.12.4 单词转换map</p>
<p>结合以上几节实现将单词存到map。</p>
<p>6.12.5 从map中删除元素</p>
<p>​    从map 中删除元素的erase()操作有三种变化形式，为了删除一个独立的元素，我们传递给erase()一个键值或iterator，为了删除一列元素我们传递给erase()一对lieator。</p>
<h4 id="创建单词排除集"><a href="#创建单词排除集" class="headerlink" title="创建单词排除集"></a>创建单词排除集</h4><p>​    当只想知道一个值是会存在时set 是最合适的。set 的操作可以与map的进行对比。</p>
<p>6.13.1 定义set 并放入元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;set&gt;</span><br><span class="line">set&lt;string&gt; exclusion_set.</span><br><span class="line">#插入元素</span><br><span class="line">exclusion_set.insert( &quot;the&quot; );</span><br><span class="line">exclusion_set.insert( &quot;and&quot; );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6.13.2 搜索一个元素</p>
<p>同样也是find()和count()函数。</p>
<p>6.13.3 迭代一个set 对象、</p>
<p>set 只能含有每个键值的惟一实例，所以可用来保证同一元素指挥出现一次。</p>
<p>set 支持操作size() empty()和erase() 同上节描述的map 类型相同另外泛型算法提<br>供了一组set 特有的函数如set_union()和set_difference() 我们将在第17 章利用它们来支<br>持查询语言</p>
<h4 id="完整的程序"><a href="#完整的程序" class="headerlink" title="完整的程序"></a>完整的程序</h4><p>详情见github仓库。</p>
<h4 id="multimap-和multiset"><a href="#multimap-和multiset" class="headerlink" title="multimap 和multiset"></a>multimap 和multiset</h4><p>map 和set 只能包含每个键的单个实例而multiset 和multimap 允许要被存储的键出现<br>多次.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line">multimap&lt; key_type, value_type &gt; multimapName;</span><br><span class="line">// 按string 索引, 存有list&lt;string&gt;</span><br><span class="line">multimap&lt; string, list&lt; string &gt; &gt; synonyms;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">multiset&lt; type &gt; multisetName;</span><br></pre></td></tr></table></figure>

<p>如何迭代？</p>
<p>​        一种迭代策略是联合使用由find()返回的iterator（指向第一个实例和由count()返回的值）。</p>
<p>更精彩的策略是使用由multiset 和multimap 的特殊操作equal_range()返回的iterator 对值。如果这个值存在则iteratior对中的第一个iterator 指向该值的第一个实例且第二个iterator 指向这个值的最后实例的下一位置。如果最后的实例是multiset 的末元素则第二个iterator 等于end()。</p>
<p>​        插入和删除操作与关联容器set 和map 相同，equal_range()可以用来提供iterator 对。以便标记出要被删除的多个元素的范围。</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈容器支持的操作：</p>
<p>empty():如果为空返回true，否则返回false。</p>
<p>size():返回栈中元素个数。</p>
<p>pop():删除，但不返回栈顶元素。</p>
<p>top():返回，但不删除栈顶元素。</p>
<p>push(item):放入新的栈顶元素。</p>
<p>头文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stack&gt;</span><br></pre></td></tr></table></figure>

<p>​        栈类型被称为容器适配器（container adapter），因为它把栈抽象施加在底层容器集上缺省情况下栈用容器类型deque ，实现因为deque为容器前端的插入和删除提供了有效支持，而vector 则不。也可以显示的定义所用的底层容器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack&lt; int, list&lt;int&gt; &gt; intStack;</span><br></pre></td></tr></table></figure>

<h4 id="队列和优先级队列"><a href="#队列和优先级队列" class="headerlink" title="队列和优先级队列"></a>队列和优先级队列</h4><p>​        队列抽象体现了先进先出的存储和检索策略。进入队列的对象被放在尾部下一个被取出的元素取自队列的首部。</p>
<p>​        标准库提供了两种风格的队列：FIFO 队列 和 priority_queue 优先级队列    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;queue&gt;</span><br></pre></td></tr></table></figure>

<p>empty():如果为空返回true，否则返回false。</p>
<p>size():返回栈中元素个数。</p>
<p>pop():删除，但不返回栈顶元素。在priority_queue 中队首元素代表优先级最高的元素.</p>
<p>front:返回，但不删除栈顶元素。它只能应用在一般队列上.<br>back():返回，但不删除队尾元素。它只能应用在一般队列上.<br>top() 返回但不删除priority_queue 的优先级最高的元素只能应用在priority_queue 上.push(item):在队尾放入一个新元素对于priority_queue 将根据优先级排序.</p>
<p>priority_queue 的元素被强加了顺序关系,以便元素可以从大到小管理。这里所谓最大即<br>等价于拥有最高优先级。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
