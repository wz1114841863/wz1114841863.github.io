<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++学习过程中遇到的问题-01</title>
    <url>/%E5%AD%A6%E4%B9%A0/Cpp-01/</url>
    <content><![CDATA[<h1 id="记录C-过程中遇到的一些问题"><a href="#记录C-过程中遇到的一些问题" class="headerlink" title="记录C++过程中遇到的一些问题"></a>记录C++过程中遇到的一些问题</h1><p> C++好难啊。 指针+对象。</p>
<span id="more"></span>

<h2 id="输入cin-指令无效"><a href="#输入cin-指令无效" class="headerlink" title="输入cin 指令无效"></a>输入cin 指令无效</h2><p>​    在一个简单的交互程序中，使用 cin 来读取输入时，第一次读取输入的字符串正常读取，第二次读取输入的数字时命令被忽略，直接跳过执行。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; number; <span class="comment">//通常情况会进行输入读取一个数值，前提是cin正常。如果cin被核定为false，则cin就不会被执行啦。</span></span><br></pre></td></tr></table></figure>

<p>   上述例子中，由于输入字符串时，输入了结束符进行退出，所以 cin 已经被核定为false了，所以下边的 cin&gt;&gt;number 无法正常执行输入操作。</p>
<p>cin 被核定为 false 的情况：</p>
<p>​    （1）遇到结束符。</p>
<p>​    （2）遇到非法输入。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>​    使用cin.clear() 和 cin.sync() 使 cin 恢复正常状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两者需要同时使用。</span></span><br><span class="line">    cin.<span class="built_in">sync</span>();</span><br><span class="line">    cin.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>

<p>   更多的具体细节可以搜索函数的定义和功能。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>DSA</title>
    <url>/%E5%AD%A6%E4%B9%A0/DSA/</url>
    <content><![CDATA[<h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><p>​    虽然一直知道数据结构和算法很重要，但是一直学的也不太行，毕竟不是计院学生，敲的代码也太少。<span id="more"></span></p>
<p>参考书籍清华邓俊辉教授撰写的《数据结构（C++语言版）》。</p>
<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>​    O(1):常数时间复杂度算法</p>
<p>​    O(logn):对数时间复杂度——高效算法</p>
<p>​    O(n):多项式时间复杂度算法.某问题若存在一个复杂度在此范围以内的算法，则称该问题是可有效求解的或易解的（tractable）</p>
<p>​    O(x**n):指数复杂度，无法接受的算法。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>​        递归则是函数和过程调用的一种特殊形式，即允许函数和过程进行<br>自我调用。</p>
<p>​        递归的价值在于，许多应用问题都可简洁而准确地描述为递归形式。</p>
<p>​    递归也是一种基本而典型的算法设计模式。这一模式可以对实际问题中反复出现的结构和形式做高度概括，并从本质层面加以描述与刻画，进而导出高效的算法。</p>
<h4 id="递归的基本模式"><a href="#递归的基本模式" class="headerlink" title="递归的基本模式"></a>递归的基本模式</h4><h5 id="线性递归"><a href="#线性递归" class="headerlink" title="线性递归"></a>线性递归</h5><p>举例：数组元素求和</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组求和：数组的前A[0,n-1)个数的和与末元素A[n-1]之和。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arraySum</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span>&gt;n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (<span class="built_in">arraySum</span>(A, n<span class="number">-1</span>) + A[n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度：O(1)*递归深度 = O(1) * (n+1) = O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)</span></span><br></pre></td></tr></table></figure>

<p>​        算法可能朝着更深一层进行自我调用，且每一递归实例对自身的调用至多一次。于是，每一层次上至多只有一个实例，且它们构成一个线性的次序关系。此类递归模式因而称作“线性递归”（linear recursion），它也是递归的最基本形式。</p>
<p>​    线性递归往往对应于<em><strong>减而治之</strong></em>的算法策略：递归每深入一层，待求解问题的规模都缩减一个常数，直至最终蜕化为平凡的小（简单）问题。</p>
<h5 id="递归分析"><a href="#递归分析" class="headerlink" title="递归分析"></a>递归分析</h5><p>1.递归跟踪：作为一种直观且可视的方法，递归跟踪（recursion trace）可用以分析递归算法的总体运行时间与空间。</p>
<p>2.递推方程：通过对递归模式的数学归纳，导出复杂度定界函数的递推方程（组）及其边界条件，从而将复杂度的分析，转化为递归方程（组）的求解。</p>
<h5 id="递归模式"><a href="#递归模式" class="headerlink" title="递归模式"></a>递归模式</h5><p>1.多递归基：为保证有穷性，递归算法都必须设置递归基，且确保总能执行到。</p>
<p>举例：数组倒置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(lo &lt; hi)&#123;</span><br><span class="line">		<span class="built_in">swap</span>(A[lo], A[hi]);</span><br><span class="line">		<span class="built_in">reverse</span>(A, lo+<span class="number">1</span>, hi<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//O(hi + lo -1)</span></span><br></pre></td></tr></table></figure>

<p>2.多向递归：递归算法中，不仅递归基可能有多个，递归调用也可能有多种可供选择的分支。</p>
<p>举例：求2**n</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inline __int64 sqr ( __int64 a ) &#123; return a * a; &#125;</span><br><span class="line">__int64 power2 ( int n ) &#123; //幂函数2^n算法（优化逑弻版），n &gt;= 0</span><br><span class="line"> 	if ( 0 == n ) return 1; //逑弻基；否则，规n癿奇偶分删逑弻</span><br><span class="line">    return ( n &amp; 1 ) ? sqr ( power2 ( n &gt;&gt; 1 ) ) &lt;&lt; 1 : sqr ( power2 ( n &gt;&gt; 1 ) );</span><br><span class="line">&#125; //O(logn) = O(r)，r为输入指数n癿比特位数</span><br></pre></td></tr></table></figure>

<h5 id="递归消除"><a href="#递归消除" class="headerlink" title="递归消除"></a>递归消除</h5><p>空间成本:递归算法所消耗的空间量主要取决于递归深度，故较之同一算法的迭代版，递归版往往需耗费更多空间，并进而影响实际的运行速度。</p>
<p>举例：尾递归消除</p>
<p>在线性递归算法中，若递归调用在递归实例中恰好以最后一步操作的形式出现，则称作尾递<br>归（tail recursion）。属于尾递归形式的算法，均可以简捷地转换为等效的迭代版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#数组倒置</span><br><span class="line">void reverse(int* A, int lo, int hi)&#123;</span><br><span class="line">next:</span><br><span class="line">	if(lo &lt; hi)&#123;</span><br><span class="line">		swap(A[lo], A[hi]);</span><br><span class="line">		lo++;</span><br><span class="line">		hi--;</span><br><span class="line">		goto next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;//O(hi - lo + 1)</span><br><span class="line"></span><br><span class="line">#用while 代替 next if</span><br><span class="line">void reverse(int* A, int lo, int hi)&#123;</span><br><span class="line">	while( lo &lt; hi )&#123;</span><br><span class="line">		swap(A[lo++], A[hi--]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二分递归"><a href="#二分递归" class="headerlink" title="二分递归"></a>二分递归</h5><p>分而治之：将大问题分解为若干规模更小的子问题，再通过递归机制分别求解。这种分解持续进行，直到子问题规模缩减至平凡情况。这也就是所谓的分而治之（divide-and-conquer）策略。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arraySum(int A[], int lo, int hi)&#123;</span><br><span class="line">	if( lo == hi)&#123;</span><br><span class="line">		return A[lo];</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		int mi = (lo + hi) &gt;&gt; 1;</span><br><span class="line">		return sum(A, lo, mi) + sum(A, mi+1, hi);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;//O(hi - lo +1)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV-Tutorials</title>
    <url>/%E5%AD%A6%E4%B9%A0/OpenCV-tutorials/</url>
    <content><![CDATA[<h2 id="OpenCV官网例程实现"><a href="#OpenCV官网例程实现" class="headerlink" title="OpenCV官网例程实现"></a>OpenCV官网例程实现</h2><p>​    OpenCV官网提供了一系列例程，先照着实现一下，同时记录遇到的一些问题。</p>
<span id="more"></span>

<h3 id="CV与Matplotlib的颜色冲突"><a href="#CV与Matplotlib的颜色冲突" class="headerlink" title="CV与Matplotlib的颜色冲突"></a>CV与Matplotlib的颜色冲突</h3><p> OpenCV中读取彩图的颜色是以BGR来排序的，而Matplotlib中图片是以RGB排序的，因此如果想要使用pyplot来展示图片，就需要对图片的颜色域顺序进行处理，不过实现起来也很方便。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv.imread(<span class="string">&quot;o1.png&quot;</span>)</span><br><span class="line">img = img[:,:,::-<span class="number">1</span>]</span><br><span class="line">plt.show(<span class="string">&quot;Image&quot;</span>,img)</span><br></pre></td></tr></table></figure>

<h3 id="使用拉普拉斯算子获取图像边缘"><a href="#使用拉普拉斯算子获取图像边缘" class="headerlink" title="使用拉普拉斯算子获取图像边缘"></a>使用拉普拉斯算子获取图像边缘</h3><p>以下是示例和我按照示例的到的结果：</p>
<p>官方示例：</p>
<img src="/images/OpenCV/openCV_01.png">

<p>我的结果：</p>
<img src="/images/OpenCV/openCV_02png">

<p>可以看出并没有得到示例中所展示的效果。</p>
<p>查看函数参数说明，可以看到有一项参数为：</p>
<p><strong>CV_<bit_depth>(S|U|F)C<number_of_channels></strong></p>
<p>说明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bit_depth：比特数---代表8bite,16bites,32bites,64bites...</span><br><span class="line"></span><br><span class="line">如果你现在创建了一个存储--灰度图片的Mat对象,这个图像的大小为宽100,高100,那么,现在这张灰度图片中有10000个像素点，它每一个像素点在内存空间所占的空间大小是8bite,8位--所以它对应的就是CV_8。</span><br><span class="line">-------------</span><br><span class="line"></span><br><span class="line">S|U|F:</span><br><span class="line"></span><br><span class="line">S--代表---signed int---有符号整形</span><br><span class="line"></span><br><span class="line">U--代表--unsigned int--无符号整形</span><br><span class="line"></span><br><span class="line">F--代表--float---------单精度浮点型</span><br><span class="line"></span><br><span class="line">---------</span><br><span class="line"></span><br><span class="line">C&lt;number_of_channels&gt;----代表---一张图片的通道数,比如:</span><br><span class="line"></span><br><span class="line">channels = 1：灰度图片--grayImg---是--单通道图像</span><br><span class="line"></span><br><span class="line">channels = 3：RGB彩色图像---------是--3通道图像</span><br><span class="line"></span><br><span class="line">channels = 4：带Alph通道的RGB图像--是--4通道图像</span><br><span class="line">————————————————</span><br></pre></td></tr></table></figure>

<p>修改参数为CV_8U后，调整内核大小，得到预期结果。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu使用中遇到的问题</title>
    <url>/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/UbuntuUsing/</url>
    <content><![CDATA[<h2 id="使用Ubuntu图形界面"><a href="#使用Ubuntu图形界面" class="headerlink" title="使用Ubuntu图形界面"></a>使用Ubuntu图形界面</h2><p>​    之前使用一直都用服务器所以没有接触过Ubuntu的图形界面，还是第一次电脑上装Ubuntu系统。然后就开始疯狂踩坑！！！</p>
<span id="more"></span>

<h2 id="语言选择"><a href="#语言选择" class="headerlink" title="语言选择"></a>语言选择</h2><p>   没想到语言选择第一步就难住了我，安装的是中文版到但是一直没能成功设置为中文。直到看到一个鬼才方法。具体步骤如下：</p>
<p>​    1.找到Ubuntu中Language support软件</p>
<p>​    2.打开软件后添加简体中文语言包</p>
<p>​    3.现在依然显示汉语为灰色无法选中，但是可以拖动！！！将汉语那一框拖动到最上面去，然后重启就可以了。</p>
<p>参考的博客链接为：</p>
<p><a href="https://blog.csdn.net/qq_42007712/article/details/82832725?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.base&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.base">https://blog.csdn.net/qq_42007712/article/details/82832725?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.base&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.base</a></p>
]]></content>
      <categories>
        <category>系统配置</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记01</title>
    <url>/%E5%AD%A6%E4%B9%A0/gitNote/</url>
    <content><![CDATA[<h2 id="系统的学习一下Git和Github的使用"><a href="#系统的学习一下Git和Github的使用" class="headerlink" title="系统的学习一下Git和Github的使用"></a>系统的学习一下Git和Github的使用</h2><p>​    已经了解和使用过Git和Github，但是并没有具体的学习过。通过系统学习能进一步加深影响。<span id="more"></span></p>
<p>​    参考书籍《ProGit》。</p>
<h3 id="获取Git仓库"><a href="#获取Git仓库" class="headerlink" title="获取Git仓库"></a>获取Git仓库</h3><p>​    获取方式通常有两种：</p>
<p>​        1、使用语句 git init ，将本地文件初始化为仓库。</p>
<p>​        2、使用给git clone <url>语句，clone一个已有的仓库下来。</p>
<h3 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h3><p>​    如图所示：</p>
<img src="/images/git/git_01.png" >

<p>​    文件所处的状态一定是图中几种状态之一。</p>
<p>​    查看当前不同文件的状态可以使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>

<h3 id="跟踪新文件-暂存文件"><a href="#跟踪新文件-暂存文件" class="headerlink" title="跟踪新文件/暂存文件"></a>跟踪新文件/暂存文件</h3><p>​    使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p>​    可以用 git add <file>开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适.</p>
<h3 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h3><p>​    使用参数查看状态简洁输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status --short</span><br><span class="line">git status -s</span><br></pre></td></tr></table></figure>

<p>  新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。</p>
<h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>​    通过创建   .gitignore 文件来选择忽略的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#示例</span><br><span class="line">#以下是忽略内容，使用正则表达式来匹配、</span><br><span class="line">*.[co]</span><br><span class="line">*~</span><br><span class="line">/folderName</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>文件 .gitignore 的格式规范如下：<br>• 所有空行或者以 # 开头的行都会被 Git 忽略。<br>• 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。<br>• 匹配模式可以以（/）开头防止递归。<br>• 匹配模式可以以（/）结尾指定目录。<br>• 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。</p>
<h3 id="对比差异"><a href="#对比差异" class="headerlink" title="对比差异"></a>对比差异</h3><p>git status只能反映当前文件的状态，如果想查看文件修改的内容或历史差异需要使用语句git diff.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff  #比较的是工作目录中当前文件和暂存区域快照之间的差异</span><br><span class="line">git diff --staged  </span><br><span class="line">git diff --cached </span><br><span class="line">#上面两条语句作用相同，比对已暂存文件与最后一次提交的文件差异：</span><br></pre></td></tr></table></figure>

<h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><p> 可以直接使用 git commit 来提交更新，接着会启动文本编辑器提示你输入版本更新信息。</p>
<p>也可以直接使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;版本更新信息&quot;</span><br></pre></td></tr></table></figure>

<h3 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -a </span><br><span class="line">#Git 会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤</span><br></pre></td></tr></table></figure>

<h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>情形一：</p>
<p>  直接删除文件，使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm  &lt;filename&gt;</span><br><span class="line">#如果文件修改后未暂存</span><br><span class="line">git rm -f &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p>情形二：</p>
<p>不删除文件而从跟踪状态下移除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remove --cached &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<h3 id="移动文件-重命名"><a href="#移动文件-重命名" class="headerlink" title="移动文件/重命名"></a>移动文件/重命名</h3><p>类似于Linux一样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git mv file_from file_to</span><br></pre></td></tr></table></figure>

<h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p>使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>

<p>也可以为 git log 附带一系列的总结性选项。 比如你想看到每次提交的简略统计信息，可以使用 –stat 选项</p>
<h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit amend</span><br></pre></td></tr></table></figure>

<p>用来修改提交信息或补充几个忘记提交的文件而不至于弄乱提交历史。</p>
<h3 id="取消暂存文件"><a href="#取消暂存文件" class="headerlink" title="取消暂存文件"></a>取消暂存文件</h3><p>与git add filename对应：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset HEAD &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout --&lt;fiename&gt;</span><br></pre></td></tr></table></figure>

<p> 请务必记得 git checkout – <file> 是一个危险的命令。 对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令</p>
<h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote </span><br><span class="line">#列出指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字</span><br></pre></td></tr></table></figure>

<h3 id="添加、移除远程仓库"><a href="#添加、移除远程仓库" class="headerlink" title="添加、移除远程仓库"></a>添加、移除远程仓库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add &lt;shortname&gt; &lt;url&gt; </span><br><span class="line">git remote remove &lt;ahortname&gt;</span><br></pre></td></tr></table></figure>

<p>添加一个新的远程 Git 仓库，同时指定一个方便使用的简写</p>
<h3 id="从远程仓库抓取"><a href="#从远程仓库抓取" class="headerlink" title="从远程仓库抓取"></a>从远程仓库抓取</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch &lt;remote&gt;</span><br></pre></td></tr></table></figure>

<p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p>
<h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。</p>
<h3 id="查看远程仓库的信息"><a href="#查看远程仓库的信息" class="headerlink" title="查看远程仓库的信息"></a>查看远程仓库的信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote show &lt;shortname&gt;</span><br></pre></td></tr></table></figure>

<h3 id="远程仓库重命名"><a href="#远程仓库重命名" class="headerlink" title="远程仓库重命名"></a>远程仓库重命名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote  rename name1 name2</span><br></pre></td></tr></table></figure>

<h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p>​    像其他版本控制系统（VCS）一样，Git 可以给仓库历史中的某一个提交打上标签，以示重要。</p>
<h3 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag </span><br><span class="line">git tag -l &quot;关键词&quot;</span><br></pre></td></tr></table></figure>

<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>git支持两种标签：</p>
<p>​    1.轻量标签</p>
<p>​        某个特定提交的引用。</p>
<p>​    2.附注标签</p>
<p>​     附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。</p>
<p>创建附注标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建附注标签</span><br><span class="line">git tag -a &lt;tagname&gt; -m &quot;注释信息&quot;</span><br><span class="line">#查看所有标签</span><br><span class="line">git tag </span><br><span class="line">#显示注释信息</span><br><span class="line">git show &lt;tagname&gt;</span><br></pre></td></tr></table></figure>

<p>创建轻量标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag &lt;tagname&gt;</span><br></pre></td></tr></table></figure>

<h3 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h3><p>​    默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#推送特定标签</span><br><span class="line">git push origin &lt;tagname&gt;</span><br><span class="line">#推送所有标签 </span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>

<h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -d &lt;tagname&gt;</span><br><span class="line">#注意上述命令并不会从任何远程仓库中移除这个标签，你必须用 </span><br><span class="line">git push &lt;remote&gt; :refs/tags/&lt;tagname&gt; </span><br><span class="line">#来更新你的远程仓库,或者</span><br><span class="line">git push origin --delete &lt;tagname&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Git别名"><a href="#Git别名" class="headerlink" title="Git别名"></a>Git别名</h2><p>Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#git 别名</span><br><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.unstage &#x27;reset HEAD --&#x27;</span><br><span class="line">git config --global alias.last &#x27;log -1 HEAD&#x27;</span><br></pre></td></tr></table></figure>

<p>也可以在用户的配置文件下修改：</p>
<p>Windows下.config文件路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\username\.gitconfig</span><br></pre></td></tr></table></figure>

<p>添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[alias]</span><br><span class="line">	co = checkout</span><br><span class="line">	br = branch</span><br><span class="line">	ci = commit</span><br><span class="line">	st = status</span><br><span class="line">	unstage = reset HEAD --=</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记02</title>
    <url>/%E5%AD%A6%E4%B9%A0/gitNote02/</url>
    <content><![CDATA[<p>​    <span id="more"></span></p>
<h2 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h2><p>​        Git 保存的不是文件的变化或者差异，而是一系列不同时刻的快照 。在进行提交操作时，Git 会保存一个提交对象（commit object）。做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 master 分支会在每次提交时自动向前移动。</p>
<h3 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h3><p>创建新的分支实际就是创建一个新的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch &lt;branchname&gt;</span><br></pre></td></tr></table></figure>

<p>从而在当前所提交的对象上创建一个新的指针。</p>
<h3 id="查看分支所指对象"><a href="#查看分支所指对象" class="headerlink" title="查看分支所指对象"></a>查看分支所指对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --oneline  --decorate</span><br></pre></td></tr></table></figure>

<h3 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<p>此时，HEAD指针就指向了新的分支。</p>
<p><em><strong>分支切换会改变你工作目录中的文件</strong></em><br>在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。</p>
<p>不同的分支提交文件后就会产生项目分叉。</p>
<h3 id="查看分叉历史"><a href="#查看分叉历史" class="headerlink" title="查看分叉历史"></a>查看分叉历史</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --oneline --decorate --graph --all</span><br></pre></td></tr></table></figure>

<p>会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p>
<h3 id="创建分支的同时切换过去"><a href="#创建分支的同时切换过去" class="headerlink" title="创建分支的同时切换过去"></a>创建分支的同时切换过去</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;newbranchname&gt;</span><br></pre></td></tr></table></figure>

<h3 id="快进"><a href="#快进" class="headerlink" title="快进"></a>快进</h3><p>当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#先切换到你要保留的分支</span><br><span class="line">git checkout master</span><br><span class="line">#快进</span><br><span class="line">git merge &lt;branchName&gt;</span><br><span class="line">#删除已经合并的分支</span><br><span class="line">git branch -d &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>三方分别为：第一个分支，第二个分支，两分支的分叉点。</p>
<p>Git 将三方合并的结果做了一个新的快照并且自动创建一个新的提<br>交指向它。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#先切换到你要保留的分支</span><br><span class="line">git checkout master</span><br><span class="line">#三方合并</span><br><span class="line">git merge &lt;branchName&gt;</span><br><span class="line">#删除已经合并的分支</span><br><span class="line">git branch -d &lt;branchName&gt;</span><br></pre></td></tr></table></figure>

<h4 id="合并时遇到冲突"><a href="#合并时遇到冲突" class="headerlink" title="合并时遇到冲突"></a>合并时遇到冲突</h4><p>​        如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。</p>
<p>​        Git 会暂停下来，等待你去解决合并产生的冲突。你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件</p>
<p>​    在手动解决文件冲突后，可以再次提交，并确认分支合并。</p>
<h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看已有分支和当前所处分支</span><br><span class="line">git branch</span><br><span class="line">#查看已合并的分支</span><br><span class="line">git branch --merged</span><br><span class="line">#查看未合并的分支</span><br><span class="line">git branch --no-merged</span><br></pre></td></tr></table></figure>

<h2 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h2><h3 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h3><p>​        因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。</p>
<h3 id="主题分支"><a href="#主题分支" class="headerlink" title="主题分支"></a>主题分支</h3><p>​        主题分支对任何规模的项目都适用。 主题分支是一种短期分支，它被用来实现单一特性或其相关工作。</p>
<h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git ls-remote &lt;remote&gt; </span><br></pre></td></tr></table></figure>

<p>来显式地获得远程引用的完整列表， 或者通过 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote show &lt;remote&gt; </span><br></pre></td></tr></table></figure>

<p>获得远程分支的更多信息。 然而，一个更常见的做法是利用远程跟踪分支。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用过程中遇到的一些问题-01</title>
    <url>/%E5%AD%A6%E4%B9%A0/gitPushProblem/</url>
    <content><![CDATA[<h1 id="记录Git使用过程中存在的一些问题"><a href="#记录Git使用过程中存在的一些问题" class="headerlink" title="记录Git使用过程中存在的一些问题"></a>记录Git使用过程中存在的一些问题</h1><p>​    使用git的过程中总会遇到一些问题。</p>
<span id="more"></span>

<h2 id="用户绑定"><a href="#用户绑定" class="headerlink" title="用户绑定"></a>用户绑定</h2><p>​    用户使用前必须通过SSL密匙连接欸到GitHub账号。这样才能正常使用上传和下拉功能。</p>
<h2 id="push时使用-git-git"><a href="#push时使用-git-git" class="headerlink" title="push时使用 git@git"></a>push时使用 git@git</h2><p>​    向Github仓库push代码时显示;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://github.com/wz1114841863/OpenCV-SampleCode.git/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="出错原因"><a href="#出错原因" class="headerlink" title="出错原因"></a>出错原因</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/wz1114841863/OpenCV-SampleCode.git</span><br></pre></td></tr></table></figure>

<p>​    这里使用了 https传输协议，其他的解决方法并未尝试，这里直接换成了git@github</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>​    解除绑定，换成git@github：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git remote add origin git@github.com:wz1114841863/OpenCV-SampleCode.git</span><br></pre></td></tr></table></figure>

<p>​    接着重新上传，成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">Enumerating objects: 11, done.</span><br><span class="line">Counting objects: 100% (11/11), done.</span><br><span class="line">Delta compression using up to 16 threads</span><br><span class="line">Compressing objects: 100% (9/9), done.</span><br><span class="line">Writing objects: 100% (11/11), 16.79 MiB | 1.62 MiB/s, done.</span><br><span class="line">Total 11 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">To github.com:wz1114841863/OpenCV-SampleCode.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch &#x27;master&#x27; set up to track remote branch &#x27;master&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure>

<h2 id="忽略文件夹名大小写"><a href="#忽略文件夹名大小写" class="headerlink" title="忽略文件夹名大小写"></a>忽略文件夹名大小写</h2><p>git默认在提交时会忽略文件夹名的大小写，从而导致出现问题。</p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看本地仓库git忽略大小写是否打开</span><br><span class="line">$ git config --get core.ignorecase</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>true 表示忽略文件名大小写，可以将其设置为false。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config core.ignorecase false</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo_init</title>
    <url>/%E7%BD%91%E7%AB%99%E9%85%8D%E7%BD%AE/hexo-init/</url>
    <content><![CDATA[<h1 id="踩坑日记："><a href="#踩坑日记：" class="headerlink" title="踩坑日记："></a>踩坑日记：</h1><p>​    该踩的坑是一个都没少踩，记录一下自己踩的一些坑吧，好多都忘了。</p>
<p>​    <span id="more"></span></p>
<h2 id="Git不区分大小写"><a href="#Git不区分大小写" class="headerlink" title="Git不区分大小写"></a>Git不区分大小写</h2><p>​    查看别人如何实现仅显示部分内容时，都推荐使用“&lt;！– more –&gt;”来分割文章，尝试后本地可正常工作，而部署到github后点击 阅读全文 按钮后，显示文章404。最后发现url后显示为 …/others/Introduce.html 而实际上应该是 …/Others/Introduce.html，所以找不到对应文件。出现这个问题是因为windows版的git在上传文件夹时不区分大小写，导致出错，害的我以为是hexo的锅。修改为中文后就可以正显示。</p>
<img src="/images/hexo-init/hexo-init_01.png" >

<h2 id="侧边栏头像下不显示description"><a href="#侧边栏头像下不显示description" class="headerlink" title="侧边栏头像下不显示description"></a>侧边栏头像下不显示description</h2><p>​    不管如何设置全局配置文件的description都不能显示出来，后来知道next主题配置文件中有个seo的选项配置，用来优化搜索引擎，我也用不到，就全都false。</p>
<img src="/images/hexo-init/hexo-init_02.png" >

<p>​    然后依旧无法显示，查看网页源码，  …/themes/layout/_macro/sidebar.swig文件。</p>
<img src="/images/hexo-init/hexo-init_03.png" >

<p>​    可以看出，当seo = ture时显示signature，seo = false时显示description，索性我就直接在 next的主题配置文件中新加了两行：    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#test</span><br><span class="line"></span><br><span class="line">description: 今天不学习，明天变垃圾。</span><br><span class="line"></span><br><span class="line">signature: 今天不学习，明天变垃圾。</span><br></pre></td></tr></table></figure>



<p>​    就能正常显示了。</p>
<h2 id="侧边栏点击后显示报错"><a href="#侧边栏点击后显示报错" class="headerlink" title="侧边栏点击后显示报错"></a>侧边栏点击后显示报错</h2><p>​    next 主题官方的锅，menu下的每一项后的 ‘/‘与 ‘||’不能有空格。</p>
<img src="/images/hexo-init/hexo-init_04.png" > 

<h2 id="博客添加图片"><a href="#博客添加图片" class="headerlink" title="博客添加图片"></a>博客添加图片</h2><p>​    添加图片的坑更多了！！！</p>
<p>​    目前已知的方法有：</p>
<p>​        1.使用插件。（试过，但有问题，而且每个博客都会建一个文件夹来存放图片，很烦。）</p>
<p>​        2.使用图床。（需要注册图床，然后导出图片链接，快捷方法是 Typora 与 ipic 结合使用，不过ipic仅支持mac。不过也有大佬自己写了几个插件来使用。）</p>
<p>​        3.参考hexo官网，有以下描述。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 ![](/images/image.jpg) 的方法访问它们。</span><br></pre></td></tr></table></figure>

<p>​        缺点就是本地写博客时无法浏览，其他的都很方便，我就选择的是这种方式,，在source文件中自己创建了images文件夹，在Github上浏览时发现会和已有的images文件夹相加。同时注意这里使用的是绝对路径  /images/。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    还有好多坑都不记得了，不过最后还是依靠 百度+ 谷歌，全都解决了。</p>
]]></content>
      <categories>
        <category>网站配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Introduce</title>
    <url>/%E5%85%B6%E4%BB%96/introduce/</url>
    <content><![CDATA[<p>无意间看到可以用GitHub来发博客，便心血来潮自己也搞了一个。</p>
<span id="more"></span>正好刚考上研究生，希望能够用来记录自己的一些学习路线或者学习心得之类的，也希望自己不要太懒惰(笑)。



]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>闲聊</tag>
      </tags>
  </entry>
  <entry>
    <title>learing_route</title>
    <url>/%E5%85%B6%E4%BB%96/learing-route/</url>
    <content><![CDATA[<h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><p>​    本科专业是电子工程与技术，研究生报考的也是本院的实验室，未曾想研究方向居然是CV。塞翁失马，焉知非福。不管怎么说。也算是接触一个全新的领域，还有很多东西需要去学，所以也做一个小小的规划。<span id="more"></span></p>
<h2 id="编程语言学习"><a href="#编程语言学习" class="headerlink" title="编程语言学习"></a>编程语言学习</h2><h3 id="C-：从入门到入土"><a href="#C-：从入门到入土" class="headerlink" title="C++：从入门到入土"></a>C++：从入门到入土</h3><p>​        大学时期没有了解过C++，但是OpenCV等好多底层文件都是用C++写的，那咋办嘛，学呗。</p>
<h3 id="OpenCV-C-Python"><a href="#OpenCV-C-Python" class="headerlink" title="OpenCV: C++/Python"></a>OpenCV: C++/Python</h3><p>​        总感觉和OpenCV有种莫名的缘分(笑)，OpenCV分为C++和Python两种版本，各有优劣，应该会用到很多吧。</p>
<h3 id="Python：-人人都会的编程语言"><a href="#Python：-人人都会的编程语言" class="headerlink" title="Python： 人人都会的编程语言"></a>Python： 人人都会的编程语言</h3><p>​        python只能说 会写但没完全会。</p>
<h2 id="机器学习-深度学习"><a href="#机器学习-深度学习" class="headerlink" title="机器学习/深度学习"></a>机器学习/深度学习</h2><p>​        没了解之前确实觉得机器学习和深度学习都蛮神秘的，了解之后，嗯，都是我学不会的东西呢。</p>
<h3 id="pytorch框架"><a href="#pytorch框架" class="headerlink" title="pytorch框架"></a>pytorch框架</h3><p>​        应该需要去了解一下这个框架，跟tensorflow相比好像更容易一点。</p>
<h3 id="花书-西瓜书-鱼书"><a href="#花书-西瓜书-鱼书" class="headerlink" title="花书/西瓜书/鱼书"></a>花书/西瓜书/鱼书</h3><p>​        收藏从未停止，学习从未开始。</p>
<h2 id="计算机基础四大件："><a href="#计算机基础四大件：" class="headerlink" title="计算机基础四大件："></a>计算机基础四大件：</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>​            为什么要为难我一个电子院出身的人呢。问就是北邮特色，不会真有不会编程的北邮人吧。</p>
<h2 id="LeetCode刷题"><a href="#LeetCode刷题" class="headerlink" title="LeetCode刷题"></a>LeetCode刷题</h2><p>​            刚清空之前的刷题记录，虽然也没几道就是了(/(ㄒoㄒ)/~~)。问就是要加油啊。</p>
<h2 id="Liunx-shell编程"><a href="#Liunx-shell编程" class="headerlink" title="Liunx/shell编程"></a>Liunx/shell编程</h2><p>​            多练练手，别忘光了就好。</p>
<p>​    </p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>闲聊</tag>
      </tags>
  </entry>
</search>
